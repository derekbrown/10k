{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useNFTIndexerQuery = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst react_1 = require(\"react\");\n\nconst swr_1 = tslib_1.__importDefault(require(\"swr\"));\n\nconst NFTFetchContext_1 = require(\"../context/NFTFetchContext\");\n\nconst ErrorUtils_1 = require(\"../fetcher/ErrorUtils\");\n/**\n * Fetches on-chain NFT data and pricing for the given zNFT id\n *\n * @param contractAddresses address of the contract, if null and tokenID is passed in, a ZNFT is assumed\n * @param tokenId id of NFT to fetch blockchain information for\n * @param approved Auction status approved fetch boolean true = only approved, false = only not approved, null/undefined = any\n * @param options SWR flags and an option to load currency info\n * @returns useNFTType hook results include loading, error, and chainNFT data.\n */\n\n\nfunction useNFTIndexerQuery(_ref) {\n  let {\n    collectionAddresses,\n    curatorAddress,\n    onlyAuctions,\n    approved,\n    owner,\n    limit,\n    offset\n  } = _ref;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options.onErrorRetry = ErrorUtils_1.onErrorRetry;\n  const fetcher = react_1.useContext(NFTFetchContext_1.NFTFetchContext);\n\n  if (owner && curatorAddress) {\n    throw new Error('Owner and curator address cannot be specified at the same time');\n  }\n\n  const nftListData = swr_1.default(!options.initialData && collectionAddresses ? ['useNFTIndexerGroup', owner, onlyAuctions, approved, curatorAddress, limit, offset, ...collectionAddresses] : null, function (_, owner, onlyAuctions, approved, curatorAddress, limit, offset) {\n    for (var _len = arguments.length, collectionAddresses = new Array(_len > 7 ? _len - 7 : 0), _key = 7; _key < _len; _key++) {\n      collectionAddresses[_key - 7] = arguments[_key];\n    }\n\n    if (owner) {\n      return fetcher.fetchZoraIndexerUserOwnedNFTs({\n        collectionAddresses,\n        userAddress: owner,\n        limit,\n        offset\n      });\n    }\n\n    return fetcher.fetchZoraIndexerGroupData({\n      collectionAddresses: collectionAddresses,\n      curatorAddress: curatorAddress,\n      approved,\n      onlyAuctions,\n      limit: limit || 200,\n      offset: offset || 0\n    });\n  }, options);\n  return {\n    error: nftListData.error,\n    results: nftListData.data\n  };\n}\n\nexports.useNFTIndexerQuery = useNFTIndexerQuery;","map":{"version":3,"sources":["/Users/derekbrown/workspace/10kdigits/node_modules/@zoralabs/nft-hooks/dist/hooks/useNFTIndexerQuery.js"],"names":["Object","defineProperty","exports","value","useNFTIndexerQuery","tslib_1","require","react_1","swr_1","__importDefault","NFTFetchContext_1","ErrorUtils_1","collectionAddresses","curatorAddress","onlyAuctions","approved","owner","limit","offset","options","onErrorRetry","fetcher","useContext","NFTFetchContext","Error","nftListData","default","initialData","_","fetchZoraIndexerUserOwnedNFTs","userAddress","fetchZoraIndexerGroupData","error","results","data"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,kBAAR,GAA6B,KAAK,CAAlC;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAME,KAAK,GAAGH,OAAO,CAACI,eAAR,CAAwBH,OAAO,CAAC,KAAD,CAA/B,CAAd;;AACA,MAAMI,iBAAiB,GAAGJ,OAAO,CAAC,4BAAD,CAAjC;;AACA,MAAMK,YAAY,GAAGL,OAAO,CAAC,uBAAD,CAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,kBAAT,OAAkI;AAAA,MAAtG;AAAEQ,IAAAA,mBAAF;AAAuBC,IAAAA,cAAvB;AAAuCC,IAAAA,YAAvC;AAAqDC,IAAAA,QAArD;AAA+DC,IAAAA,KAA/D;AAAsEC,IAAAA,KAAtE;AAA6EC,IAAAA;AAA7E,GAAsG;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAC9HA,EAAAA,OAAO,CAACC,YAAR,GAAuBT,YAAY,CAACS,YAApC;AACA,QAAMC,OAAO,GAAGd,OAAO,CAACe,UAAR,CAAmBZ,iBAAiB,CAACa,eAArC,CAAhB;;AACA,MAAIP,KAAK,IAAIH,cAAb,EAA6B;AACzB,UAAM,IAAIW,KAAJ,CAAU,gEAAV,CAAN;AACH;;AACD,QAAMC,WAAW,GAAGjB,KAAK,CAACkB,OAAN,CAAc,CAACP,OAAO,CAACQ,WAAT,IAAwBf,mBAAxB,GAC5B,CACE,oBADF,EAEEI,KAFF,EAGEF,YAHF,EAIEC,QAJF,EAKEF,cALF,EAMEI,KANF,EAOEC,MAPF,EAQE,GAAGN,mBARL,CAD4B,GAW5B,IAXc,EAWR,UAACgB,CAAD,EAAIZ,KAAJ,EAAWF,YAAX,EAAyBC,QAAzB,EAAmCF,cAAnC,EAAmDI,KAAnD,EAA0DC,MAA1D,EAA6F;AAAA,sCAAxBN,mBAAwB;AAAxBA,MAAAA,mBAAwB;AAAA;;AACrG,QAAII,KAAJ,EAAW;AACP,aAAOK,OAAO,CAACQ,6BAAR,CAAsC;AACzCjB,QAAAA,mBADyC;AAEzCkB,QAAAA,WAAW,EAAEd,KAF4B;AAGzCC,QAAAA,KAHyC;AAIzCC,QAAAA;AAJyC,OAAtC,CAAP;AAMH;;AACD,WAAOG,OAAO,CAACU,yBAAR,CAAkC;AACrCnB,MAAAA,mBAAmB,EAAEA,mBADgB;AAErCC,MAAAA,cAAc,EAAEA,cAFqB;AAGrCE,MAAAA,QAHqC;AAIrCD,MAAAA,YAJqC;AAKrCG,MAAAA,KAAK,EAAEA,KAAK,IAAI,GALqB;AAMrCC,MAAAA,MAAM,EAAEA,MAAM,IAAI;AANmB,KAAlC,CAAP;AAQH,GA5BmB,EA4BjBC,OA5BiB,CAApB;AA6BA,SAAO;AACHa,IAAAA,KAAK,EAAEP,WAAW,CAACO,KADhB;AAEHC,IAAAA,OAAO,EAAER,WAAW,CAACS;AAFlB,GAAP;AAIH;;AACDhC,OAAO,CAACE,kBAAR,GAA6BA,kBAA7B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useNFTIndexerQuery = void 0;\nconst tslib_1 = require(\"tslib\");\nconst react_1 = require(\"react\");\nconst swr_1 = tslib_1.__importDefault(require(\"swr\"));\nconst NFTFetchContext_1 = require(\"../context/NFTFetchContext\");\nconst ErrorUtils_1 = require(\"../fetcher/ErrorUtils\");\n/**\n * Fetches on-chain NFT data and pricing for the given zNFT id\n *\n * @param contractAddresses address of the contract, if null and tokenID is passed in, a ZNFT is assumed\n * @param tokenId id of NFT to fetch blockchain information for\n * @param approved Auction status approved fetch boolean true = only approved, false = only not approved, null/undefined = any\n * @param options SWR flags and an option to load currency info\n * @returns useNFTType hook results include loading, error, and chainNFT data.\n */\nfunction useNFTIndexerQuery({ collectionAddresses, curatorAddress, onlyAuctions, approved, owner, limit, offset, }, options = {}) {\n    options.onErrorRetry = ErrorUtils_1.onErrorRetry;\n    const fetcher = react_1.useContext(NFTFetchContext_1.NFTFetchContext);\n    if (owner && curatorAddress) {\n        throw new Error('Owner and curator address cannot be specified at the same time');\n    }\n    const nftListData = swr_1.default(!options.initialData && collectionAddresses\n        ? [\n            'useNFTIndexerGroup',\n            owner,\n            onlyAuctions,\n            approved,\n            curatorAddress,\n            limit,\n            offset,\n            ...collectionAddresses,\n        ]\n        : null, (_, owner, onlyAuctions, approved, curatorAddress, limit, offset, ...collectionAddresses) => {\n        if (owner) {\n            return fetcher.fetchZoraIndexerUserOwnedNFTs({\n                collectionAddresses,\n                userAddress: owner,\n                limit,\n                offset,\n            });\n        }\n        return fetcher.fetchZoraIndexerGroupData({\n            collectionAddresses: collectionAddresses,\n            curatorAddress: curatorAddress,\n            approved,\n            onlyAuctions,\n            limit: limit || 200,\n            offset: offset || 0,\n        });\n    }, options);\n    return {\n        error: nftListData.error,\n        results: nftListData.data,\n    };\n}\nexports.useNFTIndexerQuery = useNFTIndexerQuery;\n"]},"metadata":{},"sourceType":"script"}