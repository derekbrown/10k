{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchUserOwnedNFTs = exports.fetchZoraIndexerItem = exports.getIndexerServerTokenInfo = exports.fetchZoraIndexerList = exports.fetchZNFTGroupData = exports.fetchNFTData = exports.prepareJson = void 0;\n\nconst address_1 = require(\"@ethersproject/address\");\n\nconst addresses_1 = require(\"../constants/addresses\");\n\nconst OpenseaUtils_1 = require(\"./OpenseaUtils\");\n\nconst TransformFetchResults_1 = require(\"./TransformFetchResults\");\n/**\n * This removes undefined values to sanitize\n * data objects to work with nextJS server-side\n * page props.\n *\n * @param json Object to sanitize for JSON fields\n * @returns JSON-safe object\n */\n\n\nfunction prepareJson(json) {\n  return JSON.parse(JSON.stringify(json));\n}\n\nexports.prepareJson = prepareJson;\n/**\n * Async function to fetch auction information and metadata for any\n * NFT or zNFT. Mirrors behavior of useNFT hook but for server-side rendering.\n * Fetches all metadata and auction information server-side. Will be re-validated client-side.\n * Can pass return value directly into `initialData` for useNFT hook.\n *\n * @param tokenId: Token ID to fetch\n * @param contractAddress: Contract address to fetch token from\n * @param fetchAgent: MediaFetchAgent instance\n * @param prepareDataJSON: Sanitizes undefined fields to allow data to work with next.js\n * @returns object with nft and metadata fields, any issues throw an RequestError\n */\n\nconst fetchNFTData = async _ref => {\n  let {\n    tokenId,\n    contractAddress,\n    fetchAgent,\n    prepareDataJSON = true\n  } = _ref;\n\n  if (contractAddress && contractAddress !== addresses_1.ZORA_MEDIA_CONTRACT_BY_NETWORK[fetchAgent.networkId]) {\n    const auctionData = await fetchAgent.loadAuctionInfo(contractAddress, tokenId);\n    const nft = await fetchAgent.loadNFTData(contractAddress, tokenId, auctionData);\n    const metadata = OpenseaUtils_1.openseaDataToMetadata(nft);\n    const response = {\n      nft,\n      metadata\n    };\n\n    if (prepareDataJSON) {\n      return prepareJson(response);\n    }\n\n    return response;\n  } else {\n    const nft = await fetchAgent.loadZNFTData(tokenId);\n    const metadata = await fetchAgent.fetchIPFSMetadata(nft.nft.metadataURI);\n    const response = {\n      nft,\n      metadata\n    };\n\n    if (prepareDataJSON) {\n      return prepareJson(response);\n    }\n\n    return response;\n  }\n};\n\nexports.fetchNFTData = fetchNFTData;\n/**\n * Server-side initial data hook for zNFTGroup data hook\n *\n * @param ids list of ids (addresses for creator or owner, znft id for NFT)\n * @param type type of 'id' or 'creator' or 'owner' to determine what type of data to fetch\n * @returns NFTDataType\n */\n\nconst fetchZNFTGroupData = async _ref2 => {\n  let {\n    ids,\n    type,\n    fetchAgent,\n    prepareDataJSON = true\n  } = _ref2;\n  const nftGroup = await fetchAgent.fetchZNFTGroupData(ids, type);\n  const response = nftGroup.map(media => ({ ...media,\n    pricing: TransformFetchResults_1.addAuctionInformation(media.pricing)\n  }));\n\n  if (prepareDataJSON) {\n    return prepareJson(response);\n  }\n\n  return response;\n};\n\nexports.fetchZNFTGroupData = fetchZNFTGroupData;\n\nconst transformServerSideIndexerDataList = async (fetchAgent, response) => {\n  const auctionInfos = await fetchAgent.loadAuctionInfos(response.map(element => `${element.address.toLowerCase()}-${element.tokenId}`));\n  return response.map(tokenData => {\n    return {\n      nft: {\n        tokenData,\n        auctionData: auctionInfos.map(auction => auction instanceof Error ? undefined : auction).find(auction => (auction === null || auction === void 0 ? void 0 : auction.tokenContract.toLowerCase()) === tokenData.address.toLowerCase() && (auction === null || auction === void 0 ? void 0 : auction.tokenId) === tokenData.tokenId.toString())\n      }\n    };\n  });\n};\n/**\n * Server-side initial data hook for zora nft indexer response data\n *\n * @param fetchAgent FetchAgent class\n * @param listOptions Options of what objects to list (limited to contract address at the moment)\n *    has limit and offset fields\n * @param prepareDataJson prepare data for vercel static prop passing by cleaning up invalid JSON objects\n */\n\n\nconst fetchZoraIndexerList = async function (fetchAgent, listOptions) {\n  let prepareDataJson = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const response = await fetchAgent.fetchZoraIndexerGroupData(listOptions);\n  const result = await transformServerSideIndexerDataList(fetchAgent, response);\n\n  if (prepareDataJson) {\n    return prepareJson(result);\n  }\n\n  return result;\n};\n\nexports.fetchZoraIndexerList = fetchZoraIndexerList;\n\nconst getIndexerServerTokenInfo = _ref3 => {\n  let {\n    nft: {\n      tokenData\n    }\n  } = _ref3;\n\n  var _a, _b, _c;\n\n  return {\n    tokenId: tokenData.tokenId.toString(),\n    tokenContract: tokenData.address,\n    metadata: (_a = tokenData.metadata) === null || _a === void 0 ? void 0 : _a.json,\n    image: ((_c = (_b = tokenData.metadata) === null || _b === void 0 ? void 0 : _b.json) === null || _c === void 0 ? void 0 : _c.image_url) ? tokenData.metadata.json.image_url : tokenData.media ? tokenData.media.contentURI : null\n  };\n};\n\nexports.getIndexerServerTokenInfo = getIndexerServerTokenInfo;\n/**\n * Server-side initial data hook for zora nft indexer response data\n *\n * @param fetchAgent FetchAgent class\n * @param listOptions Options of what objects to list (limited to contract address at the moment)\n *    has limit and offset fields\n * @param prepareDataJson prepare data for vercel static prop passing by cleaning up invalid JSON objects\n */\n\nconst fetchZoraIndexerItem = async function (fetchAgent, listOptions) {\n  let prepareDataJson = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const response = await fetchAgent.fetchZoraNFTIndexerNFTs([`${address_1.getAddress(listOptions.collectionAddress)}-${listOptions.tokenId}`]);\n  const result = await transformServerSideIndexerDataList(fetchAgent, response);\n\n  if (prepareDataJson) {\n    return prepareJson(result[0]);\n  }\n\n  return result[0];\n};\n\nexports.fetchZoraIndexerItem = fetchZoraIndexerItem;\n/**\n * Server-side initial data hook for zora nft indexer response data\n *\n * @param fetchAgent FetchAgent class\n * @param listOptions Options of what objects to list (limited to contract address at the moment)\n *    has limit and offset fields\n * @param prepareDataJson prepare data for vercel static prop passing by cleaning up invalid JSON objects\n */\n\nconst fetchUserOwnedNFTs = async function (fetchAgent, _ref4) {\n  let {\n    collectionAddresses,\n    userAddress,\n    offset,\n    limit\n  } = _ref4;\n  let prepareDataJson = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const response = await fetchAgent.fetchZoraIndexerUserOwnedNFTs({\n    collectionAddresses,\n    userAddress,\n    limit,\n    offset\n  });\n  const result = await transformServerSideIndexerDataList(fetchAgent, response);\n\n  if (prepareDataJson) {\n    return prepareJson(result);\n  }\n\n  return result;\n};\n\nexports.fetchUserOwnedNFTs = fetchUserOwnedNFTs;","map":{"version":3,"sources":["/Users/derekbrown/workspace/10kdigits/node_modules/@zoralabs/nft-hooks/dist/fetcher/FetchStaticData.js"],"names":["Object","defineProperty","exports","value","fetchUserOwnedNFTs","fetchZoraIndexerItem","getIndexerServerTokenInfo","fetchZoraIndexerList","fetchZNFTGroupData","fetchNFTData","prepareJson","address_1","require","addresses_1","OpenseaUtils_1","TransformFetchResults_1","json","JSON","parse","stringify","tokenId","contractAddress","fetchAgent","prepareDataJSON","ZORA_MEDIA_CONTRACT_BY_NETWORK","networkId","auctionData","loadAuctionInfo","nft","loadNFTData","metadata","openseaDataToMetadata","response","loadZNFTData","fetchIPFSMetadata","metadataURI","ids","type","nftGroup","map","media","pricing","addAuctionInformation","transformServerSideIndexerDataList","auctionInfos","loadAuctionInfos","element","address","toLowerCase","tokenData","auction","Error","undefined","find","tokenContract","toString","listOptions","prepareDataJson","fetchZoraIndexerGroupData","result","_a","_b","_c","image","image_url","contentURI","fetchZoraNFTIndexerNFTs","getAddress","collectionAddress","collectionAddresses","userAddress","offset","limit","fetchZoraIndexerUserOwnedNFTs"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fetchUserOwnedNFTs = exports.fetchZoraIndexerItem = exports.getIndexerServerTokenInfo = exports.fetchZoraIndexerList = exports.fetchZNFTGroupData = exports.fetchNFTData = exports.prepareJson = void 0;\nconst address_1 = require(\"@ethersproject/address\");\nconst addresses_1 = require(\"../constants/addresses\");\nconst OpenseaUtils_1 = require(\"./OpenseaUtils\");\nconst TransformFetchResults_1 = require(\"./TransformFetchResults\");\n/**\n * This removes undefined values to sanitize\n * data objects to work with nextJS server-side\n * page props.\n *\n * @param json Object to sanitize for JSON fields\n * @returns JSON-safe object\n */\nfunction prepareJson(json) {\n    return JSON.parse(JSON.stringify(json));\n}\nexports.prepareJson = prepareJson;\n/**\n * Async function to fetch auction information and metadata for any\n * NFT or zNFT. Mirrors behavior of useNFT hook but for server-side rendering.\n * Fetches all metadata and auction information server-side. Will be re-validated client-side.\n * Can pass return value directly into `initialData` for useNFT hook.\n *\n * @param tokenId: Token ID to fetch\n * @param contractAddress: Contract address to fetch token from\n * @param fetchAgent: MediaFetchAgent instance\n * @param prepareDataJSON: Sanitizes undefined fields to allow data to work with next.js\n * @returns object with nft and metadata fields, any issues throw an RequestError\n */\nconst fetchNFTData = async ({ tokenId, contractAddress, fetchAgent, prepareDataJSON = true, }) => {\n    if (contractAddress &&\n        contractAddress !== addresses_1.ZORA_MEDIA_CONTRACT_BY_NETWORK[fetchAgent.networkId]) {\n        const auctionData = await fetchAgent.loadAuctionInfo(contractAddress, tokenId);\n        const nft = await fetchAgent.loadNFTData(contractAddress, tokenId, auctionData);\n        const metadata = OpenseaUtils_1.openseaDataToMetadata(nft);\n        const response = {\n            nft,\n            metadata,\n        };\n        if (prepareDataJSON) {\n            return prepareJson(response);\n        }\n        return response;\n    }\n    else {\n        const nft = await fetchAgent.loadZNFTData(tokenId);\n        const metadata = await fetchAgent.fetchIPFSMetadata(nft.nft.metadataURI);\n        const response = {\n            nft,\n            metadata,\n        };\n        if (prepareDataJSON) {\n            return prepareJson(response);\n        }\n        return response;\n    }\n};\nexports.fetchNFTData = fetchNFTData;\n/**\n * Server-side initial data hook for zNFTGroup data hook\n *\n * @param ids list of ids (addresses for creator or owner, znft id for NFT)\n * @param type type of 'id' or 'creator' or 'owner' to determine what type of data to fetch\n * @returns NFTDataType\n */\nconst fetchZNFTGroupData = async ({ ids, type, fetchAgent, prepareDataJSON = true, }) => {\n    const nftGroup = await fetchAgent.fetchZNFTGroupData(ids, type);\n    const response = nftGroup.map((media) => ({\n        ...media,\n        pricing: TransformFetchResults_1.addAuctionInformation(media.pricing),\n    }));\n    if (prepareDataJSON) {\n        return prepareJson(response);\n    }\n    return response;\n};\nexports.fetchZNFTGroupData = fetchZNFTGroupData;\nconst transformServerSideIndexerDataList = async (fetchAgent, response) => {\n    const auctionInfos = await fetchAgent.loadAuctionInfos(response.map((element) => `${element.address.toLowerCase()}-${element.tokenId}`));\n    return response.map((tokenData) => {\n        return {\n            nft: {\n                tokenData,\n                auctionData: auctionInfos\n                    .map((auction) => (auction instanceof Error ? undefined : auction))\n                    .find((auction) => (auction === null || auction === void 0 ? void 0 : auction.tokenContract.toLowerCase()) === tokenData.address.toLowerCase() &&\n                    (auction === null || auction === void 0 ? void 0 : auction.tokenId) === tokenData.tokenId.toString()),\n            },\n        };\n    });\n};\n/**\n * Server-side initial data hook for zora nft indexer response data\n *\n * @param fetchAgent FetchAgent class\n * @param listOptions Options of what objects to list (limited to contract address at the moment)\n *    has limit and offset fields\n * @param prepareDataJson prepare data for vercel static prop passing by cleaning up invalid JSON objects\n */\nconst fetchZoraIndexerList = async (fetchAgent, listOptions, prepareDataJson = true) => {\n    const response = await fetchAgent.fetchZoraIndexerGroupData(listOptions);\n    const result = await transformServerSideIndexerDataList(fetchAgent, response);\n    if (prepareDataJson) {\n        return prepareJson(result);\n    }\n    return result;\n};\nexports.fetchZoraIndexerList = fetchZoraIndexerList;\nconst getIndexerServerTokenInfo = ({ nft: { tokenData }, }) => {\n    var _a, _b, _c;\n    return ({\n        tokenId: tokenData.tokenId.toString(),\n        tokenContract: tokenData.address,\n        metadata: (_a = tokenData.metadata) === null || _a === void 0 ? void 0 : _a.json,\n        image: ((_c = (_b = tokenData.metadata) === null || _b === void 0 ? void 0 : _b.json) === null || _c === void 0 ? void 0 : _c.image_url)\n            ? tokenData.metadata.json.image_url\n            : tokenData.media\n                ? tokenData.media.contentURI\n                : null,\n    });\n};\nexports.getIndexerServerTokenInfo = getIndexerServerTokenInfo;\n/**\n * Server-side initial data hook for zora nft indexer response data\n *\n * @param fetchAgent FetchAgent class\n * @param listOptions Options of what objects to list (limited to contract address at the moment)\n *    has limit and offset fields\n * @param prepareDataJson prepare data for vercel static prop passing by cleaning up invalid JSON objects\n */\nconst fetchZoraIndexerItem = async (fetchAgent, listOptions, prepareDataJson = true) => {\n    const response = await fetchAgent.fetchZoraNFTIndexerNFTs([\n        `${address_1.getAddress(listOptions.collectionAddress)}-${listOptions.tokenId}`,\n    ]);\n    const result = await transformServerSideIndexerDataList(fetchAgent, response);\n    if (prepareDataJson) {\n        return prepareJson(result[0]);\n    }\n    return result[0];\n};\nexports.fetchZoraIndexerItem = fetchZoraIndexerItem;\n/**\n * Server-side initial data hook for zora nft indexer response data\n *\n * @param fetchAgent FetchAgent class\n * @param listOptions Options of what objects to list (limited to contract address at the moment)\n *    has limit and offset fields\n * @param prepareDataJson prepare data for vercel static prop passing by cleaning up invalid JSON objects\n */\nconst fetchUserOwnedNFTs = async (fetchAgent, { collectionAddresses, userAddress, offset, limit, }, prepareDataJson = false) => {\n    const response = await fetchAgent.fetchZoraIndexerUserOwnedNFTs({\n        collectionAddresses,\n        userAddress,\n        limit,\n        offset,\n    });\n    const result = await transformServerSideIndexerDataList(fetchAgent, response);\n    if (prepareDataJson) {\n        return prepareJson(result);\n    }\n    return result;\n};\nexports.fetchUserOwnedNFTs = fetchUserOwnedNFTs;\n"]},"metadata":{},"sourceType":"script"}