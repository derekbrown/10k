{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useOpenseaNFT = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst react_1 = require(\"react\");\n\nconst swr_1 = tslib_1.__importDefault(require(\"swr\"));\n\nconst NFTFetchContext_1 = require(\"../context/NFTFetchContext\");\n\nconst OpenseaUtils_1 = require(\"../fetcher/OpenseaUtils\");\n/**\n * Fetches on-chain NFT data and pricing for the given zNFT id\n *\n * @param contractAddress address of the contract\n * @param tokenId id of NFT to fetch blockchain information for\n * @param options SWR flags and an option to load currency info\n * @returns useNFTType hook results include loading, error, and chainNFT data.\n */\n\n\nfunction useOpenseaNFT(contractAddress, tokenId) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  const fetcher = react_1.useContext(NFTFetchContext_1.NFTFetchContext);\n  const {\n    loadCurrencyInfo = false,\n    refreshInterval,\n    initialData\n  } = options || {};\n  const nftData = swr_1.default(contractAddress && tokenId ? ['loadGenericNFT', contractAddress, tokenId] : null, (_, contractAddress, tokenId) => fetcher.loadNFTDataUntransformed(contractAddress, tokenId), {\n    dedupingInterval: 0\n  });\n  const auctionData = swr_1.default(contractAddress && tokenId ? ['loadAuctionForNFT', contractAddress, tokenId] : null, async (_, contractAddress, tokenId) => fetcher.loadAuctionInfo(contractAddress, tokenId));\n  const nftResponseData = nftData.data;\n  const currencyData = swr_1.default(nftResponseData && loadCurrencyInfo ? ['loadCurrencies', (_a = auctionData.data) === null || _a === void 0 ? void 0 : _a.auctionCurrency] : null, function (_) {\n    for (var _len = arguments.length, currencies = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      currencies[_key - 1] = arguments[_key];\n    }\n\n    return fetcher.loadCurrencies(currencies);\n  }, {\n    refreshInterval,\n    dedupingInterval: 0\n  });\n  let data = undefined;\n\n  if (nftData.data !== undefined) {\n    data = OpenseaUtils_1.transformOpenseaResponse(nftData.data, auctionData.data, currencyData.data);\n  } else {\n    data = initialData;\n  }\n\n  return {\n    currencyLoaded: !!currencyData.data,\n    error: nftData.error,\n    data\n  };\n}\n\nexports.useOpenseaNFT = useOpenseaNFT;","map":{"version":3,"sources":["/Users/derekbrown/workspace/10kdigits/node_modules/@zoralabs/nft-hooks/dist/hooks/useOpenseaNFT.js"],"names":["Object","defineProperty","exports","value","useOpenseaNFT","tslib_1","require","react_1","swr_1","__importDefault","NFTFetchContext_1","OpenseaUtils_1","contractAddress","tokenId","options","_a","fetcher","useContext","NFTFetchContext","loadCurrencyInfo","refreshInterval","initialData","nftData","default","_","loadNFTDataUntransformed","dedupingInterval","auctionData","loadAuctionInfo","nftResponseData","data","currencyData","auctionCurrency","currencies","loadCurrencies","undefined","transformOpenseaResponse","currencyLoaded","error"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useOpenseaNFT = void 0;\nconst tslib_1 = require(\"tslib\");\nconst react_1 = require(\"react\");\nconst swr_1 = tslib_1.__importDefault(require(\"swr\"));\nconst NFTFetchContext_1 = require(\"../context/NFTFetchContext\");\nconst OpenseaUtils_1 = require(\"../fetcher/OpenseaUtils\");\n/**\n * Fetches on-chain NFT data and pricing for the given zNFT id\n *\n * @param contractAddress address of the contract\n * @param tokenId id of NFT to fetch blockchain information for\n * @param options SWR flags and an option to load currency info\n * @returns useNFTType hook results include loading, error, and chainNFT data.\n */\nfunction useOpenseaNFT(contractAddress, tokenId, options = {}) {\n    var _a;\n    const fetcher = react_1.useContext(NFTFetchContext_1.NFTFetchContext);\n    const { loadCurrencyInfo = false, refreshInterval, initialData } = options || {};\n    const nftData = swr_1.default(contractAddress && tokenId ? ['loadGenericNFT', contractAddress, tokenId] : null, (_, contractAddress, tokenId) => fetcher.loadNFTDataUntransformed(contractAddress, tokenId), { dedupingInterval: 0 });\n    const auctionData = swr_1.default(contractAddress && tokenId ? ['loadAuctionForNFT', contractAddress, tokenId] : null, async (_, contractAddress, tokenId) => fetcher.loadAuctionInfo(contractAddress, tokenId));\n    const nftResponseData = nftData.data;\n    const currencyData = swr_1.default(nftResponseData && loadCurrencyInfo\n        ? ['loadCurrencies', (_a = auctionData.data) === null || _a === void 0 ? void 0 : _a.auctionCurrency]\n        : null, (_, ...currencies) => fetcher.loadCurrencies(currencies), {\n        refreshInterval,\n        dedupingInterval: 0,\n    });\n    let data = undefined;\n    if (nftData.data !== undefined) {\n        data = OpenseaUtils_1.transformOpenseaResponse(nftData.data, auctionData.data, currencyData.data);\n    }\n    else {\n        data = initialData;\n    }\n    return {\n        currencyLoaded: !!currencyData.data,\n        error: nftData.error,\n        data,\n    };\n}\nexports.useOpenseaNFT = useOpenseaNFT;\n"]},"metadata":{},"sourceType":"script"}