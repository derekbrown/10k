{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NFTDataProvider = void 0;\n\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\n\nconst nft_hooks_1 = require(\"@zoralabs/nft-hooks\");\n\nconst NFTDataContext_1 = require(\"./NFTDataContext\");\n\nlet isZNFT = p => p && !!p.zoraNFT;\n\nlet isOpensea = p => p && !!p.openseaInfo;\n\nconst NFTDataProvider = _ref => {\n  let {\n    id,\n    children,\n    contract,\n    refreshInterval,\n    initialData,\n    useBetaIndexer = false\n  } = _ref;\n\n  var _a, _b, _c, _d;\n\n  const {\n    nft: nftInitial\n  } = initialData || {};\n\n  if ((nftInitial === null || nftInitial === void 0 ? void 0 : nftInitial.tokenData) && !useBetaIndexer) {\n    throw new Error(\"useBetaIndexer={true} prop on NFTFull/NFTDataProvider/NFTPreview required when using indexer-style initialData\");\n  }\n\n  const nft = nft_hooks_1.useNFT(contract, id, {\n    loadCurrencyInfo: true,\n    initialData: nftInitial,\n    refreshInterval: refreshInterval,\n    useBetaIndexer\n  });\n  const fetchedMetadata = nft_hooks_1.useNFTMetadata(isZNFT(nft.data) ? (_a = nft.data) === null || _a === void 0 ? void 0 : _a.nft.metadataURI : undefined, initialData === null || initialData === void 0 ? void 0 : initialData.metadata);\n  const openseaMetadata = isOpensea(nft.data) ? {\n    loading: !!nft.data,\n    metadata: nft.data ? nft_hooks_1.DataTransformers.openseaDataToMetadata(nft.data) : undefined\n  } : undefined;\n  let zoraIndexerMetadata = nft && nft.data && \"zoraIndexerResponse\" in nft.data && ((_d = (_c = (_b = nft.data) === null || _b === void 0 ? void 0 : _b.zoraIndexerResponse) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.json);\n  const metadata = zoraIndexerMetadata ? {\n    metadata: zoraIndexerMetadata,\n    loading: !!zoraIndexerMetadata,\n    error: nft.error ? new Error(nft.error) : undefined\n  } : openseaMetadata || fetchedMetadata;\n  return jsx_runtime_1.jsx(NFTDataContext_1.NFTDataContext.Provider, Object.assign({\n    value: {\n      nft,\n      metadata\n    }\n  }, {\n    children: children\n  }), void 0);\n};\n\nexports.NFTDataProvider = NFTDataProvider;","map":{"version":3,"sources":["/Users/derekbrown/workspace/10kdigits/node_modules/@zoralabs/nft-components/dist/context/NFTDataProvider.js"],"names":["Object","defineProperty","exports","value","NFTDataProvider","jsx_runtime_1","require","nft_hooks_1","NFTDataContext_1","isZNFT","p","zoraNFT","isOpensea","openseaInfo","id","children","contract","refreshInterval","initialData","useBetaIndexer","_a","_b","_c","_d","nft","nftInitial","tokenData","Error","useNFT","loadCurrencyInfo","fetchedMetadata","useNFTMetadata","data","metadataURI","undefined","metadata","openseaMetadata","loading","DataTransformers","openseaDataToMetadata","zoraIndexerMetadata","zoraIndexerResponse","json","error","jsx","NFTDataContext","Provider","assign"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NFTDataProvider = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst nft_hooks_1 = require(\"@zoralabs/nft-hooks\");\nconst NFTDataContext_1 = require(\"./NFTDataContext\");\nlet isZNFT = (p) => p && !!p.zoraNFT;\nlet isOpensea = (p) => p && !!p.openseaInfo;\nconst NFTDataProvider = ({ id, children, contract, refreshInterval, initialData, useBetaIndexer = false, }) => {\n    var _a, _b, _c, _d;\n    const { nft: nftInitial } = initialData || {};\n    if ((nftInitial === null || nftInitial === void 0 ? void 0 : nftInitial.tokenData) && !useBetaIndexer) {\n        throw new Error(\"useBetaIndexer={true} prop on NFTFull/NFTDataProvider/NFTPreview required when using indexer-style initialData\");\n    }\n    const nft = nft_hooks_1.useNFT(contract, id, {\n        loadCurrencyInfo: true,\n        initialData: nftInitial,\n        refreshInterval: refreshInterval,\n        useBetaIndexer,\n    });\n    const fetchedMetadata = nft_hooks_1.useNFTMetadata(isZNFT(nft.data) ? (_a = nft.data) === null || _a === void 0 ? void 0 : _a.nft.metadataURI : undefined, initialData === null || initialData === void 0 ? void 0 : initialData.metadata);\n    const openseaMetadata = isOpensea(nft.data)\n        ? {\n            loading: !!nft.data,\n            metadata: nft.data\n                ? nft_hooks_1.DataTransformers.openseaDataToMetadata(nft.data)\n                : undefined,\n        }\n        : undefined;\n    let zoraIndexerMetadata = nft &&\n        nft.data &&\n        \"zoraIndexerResponse\" in nft.data &&\n        ((_d = (_c = (_b = nft.data) === null || _b === void 0 ? void 0 : _b.zoraIndexerResponse) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.json);\n    const metadata = zoraIndexerMetadata\n        ? {\n            metadata: zoraIndexerMetadata,\n            loading: !!zoraIndexerMetadata,\n            error: nft.error ? new Error(nft.error) : undefined,\n        }\n        : openseaMetadata || fetchedMetadata;\n    return (jsx_runtime_1.jsx(NFTDataContext_1.NFTDataContext.Provider, Object.assign({ value: { nft, metadata } }, { children: children }), void 0));\n};\nexports.NFTDataProvider = NFTDataProvider;\n"]},"metadata":{},"sourceType":"script"}