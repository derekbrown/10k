{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformGenericNFTForKey = exports.transformOpenseaResponse = exports.openseaDataToMetadata = void 0;\n\nconst RequestError_1 = require(\"./RequestError\");\n\nconst TransformFetchResults_1 = require(\"./TransformFetchResults\");\n\nconst openseaDataToMetadata = response => {\n  return {\n    name: response.openseaInfo.name,\n    description: response.openseaInfo.description,\n    image: response.openseaInfo.image_url,\n    image_thumbnail_url: response.openseaInfo.image_thumbnail_url,\n    animation_url: response.openseaInfo.animation_url\n  };\n};\n\nexports.openseaDataToMetadata = openseaDataToMetadata;\n\nconst transformOpenseaResponse = (data, auctionData, currencyData) => {\n  var _a;\n\n  return {\n    nft: {\n      tokenId: data.token_id,\n      contract: {\n        address: data.asset_contract.address,\n        name: data.asset_contract.name,\n        image: data.asset_contract.image_url,\n        symbol: data.asset_contract.symbol\n      },\n      owner: data.owner.address,\n      creator: (_a = data.creator) === null || _a === void 0 ? void 0 : _a.address,\n      metadataURI: data.token_metadata\n    },\n    openseaInfo: data,\n    pricing: TransformFetchResults_1.addAuctionInformation({\n      reserve: TransformFetchResults_1.auctionDataToPricing(auctionData)\n    }, currencyData)\n  };\n};\n\nexports.transformOpenseaResponse = transformOpenseaResponse;\n\nconst transformGenericNFTForKey = (response, key) => {\n  const [contractAddress, tokenId] = key.split(':');\n  const matchedResponse = response.find(response => response.token_id === tokenId && response.asset_contract.address === contractAddress);\n\n  if (!matchedResponse) {\n    throw new RequestError_1.RequestError('Cannot find NFT in response');\n  }\n\n  return matchedResponse;\n};\n\nexports.transformGenericNFTForKey = transformGenericNFTForKey;","map":{"version":3,"sources":["/Users/derekbrown/workspace/10kdigits/node_modules/@zoralabs/nft-hooks/dist/fetcher/OpenseaUtils.js"],"names":["Object","defineProperty","exports","value","transformGenericNFTForKey","transformOpenseaResponse","openseaDataToMetadata","RequestError_1","require","TransformFetchResults_1","response","name","openseaInfo","description","image","image_url","image_thumbnail_url","animation_url","data","auctionData","currencyData","_a","nft","tokenId","token_id","contract","address","asset_contract","symbol","owner","creator","metadataURI","token_metadata","pricing","addAuctionInformation","reserve","auctionDataToPricing","key","contractAddress","split","matchedResponse","find","RequestError"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,yBAAR,GAAoCF,OAAO,CAACG,wBAAR,GAAmCH,OAAO,CAACI,qBAAR,GAAgC,KAAK,CAA5G;;AACA,MAAMC,cAAc,GAAGC,OAAO,CAAC,gBAAD,CAA9B;;AACA,MAAMC,uBAAuB,GAAGD,OAAO,CAAC,yBAAD,CAAvC;;AACA,MAAMF,qBAAqB,GAAII,QAAD,IAAc;AACxC,SAAO;AACHC,IAAAA,IAAI,EAAED,QAAQ,CAACE,WAAT,CAAqBD,IADxB;AAEHE,IAAAA,WAAW,EAAEH,QAAQ,CAACE,WAAT,CAAqBC,WAF/B;AAGHC,IAAAA,KAAK,EAAEJ,QAAQ,CAACE,WAAT,CAAqBG,SAHzB;AAIHC,IAAAA,mBAAmB,EAAEN,QAAQ,CAACE,WAAT,CAAqBI,mBAJvC;AAKHC,IAAAA,aAAa,EAAEP,QAAQ,CAACE,WAAT,CAAqBK;AALjC,GAAP;AAOH,CARD;;AASAf,OAAO,CAACI,qBAAR,GAAgCA,qBAAhC;;AACA,MAAMD,wBAAwB,GAAG,CAACa,IAAD,EAAOC,WAAP,EAAoBC,YAApB,KAAqC;AAClE,MAAIC,EAAJ;;AACA,SAAO;AACHC,IAAAA,GAAG,EAAE;AACDC,MAAAA,OAAO,EAAEL,IAAI,CAACM,QADb;AAEDC,MAAAA,QAAQ,EAAE;AACNC,QAAAA,OAAO,EAAER,IAAI,CAACS,cAAL,CAAoBD,OADvB;AAENf,QAAAA,IAAI,EAAEO,IAAI,CAACS,cAAL,CAAoBhB,IAFpB;AAGNG,QAAAA,KAAK,EAAEI,IAAI,CAACS,cAAL,CAAoBZ,SAHrB;AAINa,QAAAA,MAAM,EAAEV,IAAI,CAACS,cAAL,CAAoBC;AAJtB,OAFT;AAQDC,MAAAA,KAAK,EAAEX,IAAI,CAACW,KAAL,CAAWH,OARjB;AASDI,MAAAA,OAAO,EAAE,CAACT,EAAE,GAAGH,IAAI,CAACY,OAAX,MAAwB,IAAxB,IAAgCT,EAAE,KAAK,KAAK,CAA5C,GAAgD,KAAK,CAArD,GAAyDA,EAAE,CAACK,OATpE;AAUDK,MAAAA,WAAW,EAAEb,IAAI,CAACc;AAVjB,KADF;AAaHpB,IAAAA,WAAW,EAAEM,IAbV;AAcHe,IAAAA,OAAO,EAAExB,uBAAuB,CAACyB,qBAAxB,CAA8C;AACnDC,MAAAA,OAAO,EAAE1B,uBAAuB,CAAC2B,oBAAxB,CAA6CjB,WAA7C;AAD0C,KAA9C,EAENC,YAFM;AAdN,GAAP;AAkBH,CApBD;;AAqBAlB,OAAO,CAACG,wBAAR,GAAmCA,wBAAnC;;AACA,MAAMD,yBAAyB,GAAG,CAACM,QAAD,EAAW2B,GAAX,KAAmB;AACjD,QAAM,CAACC,eAAD,EAAkBf,OAAlB,IAA6Bc,GAAG,CAACE,KAAJ,CAAU,GAAV,CAAnC;AACA,QAAMC,eAAe,GAAG9B,QAAQ,CAAC+B,IAAT,CAAe/B,QAAD,IAAcA,QAAQ,CAACc,QAAT,KAAsBD,OAAtB,IAAiCb,QAAQ,CAACiB,cAAT,CAAwBD,OAAxB,KAAoCY,eAAjG,CAAxB;;AACA,MAAI,CAACE,eAAL,EAAsB;AAClB,UAAM,IAAIjC,cAAc,CAACmC,YAAnB,CAAgC,6BAAhC,CAAN;AACH;;AACD,SAAOF,eAAP;AACH,CAPD;;AAQAtC,OAAO,CAACE,yBAAR,GAAoCA,yBAApC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transformGenericNFTForKey = exports.transformOpenseaResponse = exports.openseaDataToMetadata = void 0;\nconst RequestError_1 = require(\"./RequestError\");\nconst TransformFetchResults_1 = require(\"./TransformFetchResults\");\nconst openseaDataToMetadata = (response) => {\n    return {\n        name: response.openseaInfo.name,\n        description: response.openseaInfo.description,\n        image: response.openseaInfo.image_url,\n        image_thumbnail_url: response.openseaInfo.image_thumbnail_url,\n        animation_url: response.openseaInfo.animation_url,\n    };\n};\nexports.openseaDataToMetadata = openseaDataToMetadata;\nconst transformOpenseaResponse = (data, auctionData, currencyData) => {\n    var _a;\n    return {\n        nft: {\n            tokenId: data.token_id,\n            contract: {\n                address: data.asset_contract.address,\n                name: data.asset_contract.name,\n                image: data.asset_contract.image_url,\n                symbol: data.asset_contract.symbol,\n            },\n            owner: data.owner.address,\n            creator: (_a = data.creator) === null || _a === void 0 ? void 0 : _a.address,\n            metadataURI: data.token_metadata,\n        },\n        openseaInfo: data,\n        pricing: TransformFetchResults_1.addAuctionInformation({\n            reserve: TransformFetchResults_1.auctionDataToPricing(auctionData),\n        }, currencyData),\n    };\n};\nexports.transformOpenseaResponse = transformOpenseaResponse;\nconst transformGenericNFTForKey = (response, key) => {\n    const [contractAddress, tokenId] = key.split(':');\n    const matchedResponse = response.find((response) => response.token_id === tokenId && response.asset_contract.address === contractAddress);\n    if (!matchedResponse) {\n        throw new RequestError_1.RequestError('Cannot find NFT in response');\n    }\n    return matchedResponse;\n};\nexports.transformGenericNFTForKey = transformGenericNFTForKey;\n"]},"metadata":{},"sourceType":"script"}