{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MediaFetchAgent = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst dataloader_1 = tslib_1.__importDefault(require(\"dataloader\"));\n\nconst graphql_request_1 = require(\"graphql-request\");\n\nconst address_1 = require(\"@ethersproject/address\");\n\nconst RequestError_1 = require(\"./RequestError\");\n\nconst urls_1 = require(\"../constants/urls\");\n\nconst EnsReverseFetcher_1 = require(\"./EnsReverseFetcher\");\n\nconst zora_graph_1 = require(\"../graph-queries/zora-graph\");\n\nconst uniswap_1 = require(\"../graph-queries/uniswap\");\n\nconst timeouts_1 = require(\"../constants/timeouts\");\n\nconst TransformFetchResults_1 = require(\"./TransformFetchResults\");\n\nconst FetchWithTimeout_1 = require(\"./FetchWithTimeout\");\n\nconst OpenseaUtils_1 = require(\"./OpenseaUtils\");\n\nconst zora_indexer_1 = require(\"../graph-queries/zora-indexer\");\n\nconst ErrorUtils_1 = require(\"./ErrorUtils\");\n\nconst UriUtils_1 = require(\"./UriUtils\");\n/**\n * Internal agent for NFT Hooks to fetch NFT information.\n * Can be used directly for interaction with non-react web frameworks or server frameworks.\n * Uses a cached promise-based API.\n * Fetches from IPFS providers and thegraph.\n */\n\n\nclass MediaFetchAgent {\n  constructor(network) {\n    this.timeouts = timeouts_1.DEFAULT_NETWORK_TIMEOUTS_MS;\n    this.networkId = network;\n    this.loaders = {\n      mediaLoader: new dataloader_1.default(keys => this.fetchMediaGraph(keys), {\n        cache: false\n      }),\n      currencyLoader: new dataloader_1.default(keys => this.fetchCurrenciesGraph(keys), {\n        cache: false\n      }),\n      zoraNFTIndexerLoader: new dataloader_1.default(keys => this.fetchZoraNFTIndexerNFTs(keys)),\n      usernameLoader: new dataloader_1.default(keys => this.fetchZoraUsernames(keys)),\n      genericNFTLoader: new dataloader_1.default(keys => this.fetchGenericNFT(keys), {\n        cache: false,\n        maxBatchSize: 30\n      }),\n      ensLoader: new dataloader_1.default(keys => this.loadEnsBatch(keys), {\n        maxBatchSize: 100\n      }),\n      auctionInfoLoader: new dataloader_1.default(keys => this.fetchAuctionNFTInfo(keys), {\n        cache: false,\n        maxBatchSize: 300\n      })\n    };\n  }\n  /**\n   * Clear all cached responses from metadata, currency, and NFT chain information loaders\n   */\n\n\n  clearCache() {\n    Object.values(this.loaders).forEach(loader => loader.clearAll());\n  }\n  /**\n   * Gets information of currencies and trading prices from uniswap\n   * @param currencies list of currency contract ids on ethereum\n   * @returns Promise<CurrencyLookupType>\n   */\n\n\n  async loadCurrencies(currencies) {\n    const results = await this.loaders.currencyLoader.loadMany(currencies);\n    return results.reduce((last, result) => {\n      if (!(result instanceof Error)) {\n        last[result.token.id] = result;\n      }\n\n      return last;\n    }, {});\n  }\n  /**\n   * Fetch NFT content or retun URI if content shouild not be fetched\n   * @param url NFT Content URL\n   * @param contentType string mime type to fetch\n   * @returns Promise<MediaContentType> Media content information or URL\n   */\n\n\n  async fetchContent(url, contentType) {\n    if (contentType.startsWith('text/')) {\n      try {\n        const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS).fetch(UriUtils_1.convertURIToHTTPS(url));\n        return {\n          text: await response.text(),\n          type: 'text',\n          mimeType: contentType\n        };\n      } catch (e) {\n        throw new RequestError_1.RequestError('Issue fetching IPFS data', e);\n      }\n    }\n\n    return {\n      uri: url,\n      type: 'uri',\n      mimeType: contentType\n    };\n  }\n  /**\n   * Fetch Content MIME type from content URI\n   *\n   * @param url IPFS Content URI\n   * @returns mime type as a string\n   * @throws RequestError\n   */\n\n\n  async fetchContentMimeType(url) {\n    const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS).fetch(UriUtils_1.convertURIToHTTPS(url), {\n      method: 'HEAD'\n    });\n    const header = response.headers.get('content-type');\n\n    if (!header) {\n      throw new RequestError_1.RequestError('No content type returned for URI');\n    }\n\n    return header;\n  }\n  /**\n   * Un-batched fetch function to fetch a group of ZNFT data\n   *\n   * @param ids list of ids to query\n   * @param type type of ids: creator, id (of media), owner\n   * @returns\n   */\n\n\n  async fetchZNFTGroupData(ids, type) {\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n    const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {\n      fetch: fetchWithTimeout.fetch\n    });\n\n    const getQuery = () => {\n      let base = {\n        id_ids: [],\n        creator_ids: [],\n        owner_ids: []\n      };\n      const idsNormalized = ids.map(id => id.toLowerCase());\n\n      switch (type) {\n        case 'id':\n          base.id_ids = idsNormalized;\n          break;\n\n        case 'creator':\n          base.creator_ids = idsNormalized;\n          break;\n\n        case 'owner':\n          base.owner_ids = idsNormalized;\n          break;\n      }\n\n      return base;\n    };\n\n    const response = await client.request(zora_graph_1.GET_MEDIAS_QUERY, getQuery);\n    const medias = [...response.creator, ...response.owner, ...response.id];\n    return medias.map(media => TransformFetchResults_1.transformMediaItem(media, this.networkId));\n  }\n\n  async loadEnsBatch(addresses) {\n    const addressToNames = await EnsReverseFetcher_1.reverseResolveEnsAddresses(addresses, this.networkId, this.timeouts.Rpc);\n    return addresses.map(address => addressToNames[address] || Error('Not found'));\n  } // Alpha: uses zora indexer\n  // format CONTRACT_ID-TOKEN_ID\n\n\n  async fetchZoraNFTIndexerNFTs(keys) {\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.ZoraIndexer);\n    const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {\n      fetch: fetchWithTimeout.fetch\n    });\n    const response = await client.request(zora_indexer_1.BY_IDS, {\n      ids: keys\n    });\n    return keys.map(key => response.Token.find(token => token.id === key) || new ErrorUtils_1.NotFoundError('Did not find token'));\n  }\n\n  async loadZoraNFTIndexerNFTUntransformed(contractAddress, tokenId) {\n    return this.loaders.zoraNFTIndexerLoader.load(`${address_1.getAddress(contractAddress)}-${tokenId}`);\n  }\n\n  async loadZoraNFTIndexerNFTsUntransformed(tokenAndIds) {\n    return this.loaders.zoraNFTIndexerLoader.loadMany(tokenAndIds);\n  }\n  /**\n   * Un-batched fetch function to fetch a group of NFT data from the zora indexer\n   *\n   * @param collectionAddresses list of collections to include\n   * @param curatorAddress curator to query\n   * @param approved boolean if the auction is approved (null for approved and un-approved auctions)\n   */\n\n\n  async fetchZoraIndexerGroupData(_ref) {\n    let {\n      collectionAddresses,\n      curatorAddress,\n      approved = null,\n      onlyAuctions = false,\n      limit = 200,\n      offset = 0\n    } = _ref;\n\n    if (!(collectionAddresses === null || collectionAddresses === void 0 ? void 0 : collectionAddresses.length) && !curatorAddress) {\n      throw new ErrorUtils_1.ArgumentsError('Needs to have at least one curator or collector');\n    }\n\n    if (!onlyAuctions && approved !== null) {\n      throw new ErrorUtils_1.ArgumentsError('approved=true or approved=false and onlyAuctions=false cannot be set at the same time for fetchZoraIndexerGroupData');\n    }\n\n    let queryStatement = [];\n\n    if (collectionAddresses) {\n      const addresses = collectionAddresses.map(address => address_1.getAddress(address));\n      queryStatement.push({\n        address: {\n          _in: addresses\n        }\n      });\n    }\n\n    let approvedStatement = undefined;\n\n    if (approved !== null) {\n      approvedStatement = {\n        approved: {\n          _eq: approved\n        }\n      };\n    }\n\n    if (curatorAddress) {\n      queryStatement.push({\n        auctions: {\n          curator: {\n            _eq: curatorAddress\n          },\n          ...approvedStatement\n        }\n      });\n    } else if (approvedStatement || onlyAuctions) {\n      let auctionsQueryStmt = {};\n\n      if (onlyAuctions) {\n        auctionsQueryStmt = {\n          _not: {}\n        };\n      }\n\n      queryStatement.push({\n        auctions: { ...auctionsQueryStmt,\n          ...approvedStatement\n        }\n      });\n    }\n\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.ZoraIndexer);\n    const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {\n      fetch: fetchWithTimeout.fetch\n    });\n    return (await client.request(zora_indexer_1.ACTIVE_AUCTIONS_QUERY, {\n      andQuery: queryStatement,\n      offset,\n      limit\n    })).Token;\n  }\n  /**\n   * Un-batched fetch function to fetch a group of NFT data from the zora indexer\n   *\n   * @param collectionAddresses list of addresses for collection\n   * @param userAddress address of user\n   * @param type type of ids: creator, id (of media), owner\n   * @returns\n   */\n\n\n  async fetchZoraIndexerUserOwnedNFTs(_ref2) {\n    let {\n      collectionAddresses,\n      userAddress,\n      offset = 0,\n      limit = 250\n    } = _ref2;\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.ZoraIndexer);\n    const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {\n      fetch: fetchWithTimeout.fetch\n    });\n    let addressQueryPart = {};\n\n    if (collectionAddresses === null || collectionAddresses === void 0 ? void 0 : collectionAddresses.length) {\n      addressQueryPart['_in'] = collectionAddresses.map(address_1.getAddress);\n    }\n\n    const response = await client.request(zora_indexer_1.BY_OWNER, {\n      addressQueryPart,\n      owner: address_1.getAddress(userAddress),\n      offset,\n      limit\n    });\n    return response.Token;\n  }\n  /**\n   * Get on-chain ZORA NFT ID associated media information\n   *\n   * @param mediaId ZORA NFT id to retrieve information of\n   * @returns Promise<NFTDataType> On-chain NFT data\n   */\n\n\n  async loadZNFTData(mediaId) {\n    let currencyInfos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const chainInfo = await this.loaders.mediaLoader.load(mediaId);\n\n    if (!chainInfo) {\n      throw new RequestError_1.RequestError('Cannot fetch chain information');\n    }\n\n    return { ...chainInfo,\n      pricing: TransformFetchResults_1.addAuctionInformation(chainInfo.pricing, currencyInfos)\n    };\n  }\n\n  async loadNFTData(contractAddress, tokenId, auctionData, currencyData) {\n    const contractAndToken = `${contractAddress.toLowerCase()}:${tokenId}`;\n    const nftInfo = await this.loaders.genericNFTLoader.load(contractAndToken);\n\n    if (!auctionData) {\n      try {\n        auctionData = await this.loadAuctionInfo(contractAddress, tokenId);\n      } catch (err) {\n        if (!(err instanceof ErrorUtils_1.NotFoundError)) {\n          // Log any not-found error\n          console.error(err);\n        }\n      }\n    }\n\n    if (!nftInfo) {\n      throw new RequestError_1.RequestError('Cannot fetch NFT information');\n    }\n\n    return OpenseaUtils_1.transformOpenseaResponse(nftInfo, auctionData, currencyData);\n  }\n\n  async loadNFTDataUntransformed(contractAddress, tokenId) {\n    const contractAndToken = `${contractAddress.toLowerCase()}:${tokenId}`;\n    const nftInfo = await this.loaders.genericNFTLoader.load(contractAndToken);\n\n    if (!nftInfo) {\n      throw new RequestError_1.RequestError('Cannot fetch NFT information');\n    }\n\n    return nftInfo;\n  }\n\n  async loadZNFTDataUntransformed(mediaId) {\n    return await this.loaders.mediaLoader.load(mediaId);\n  }\n\n  async loadAuctionInfo(tokenContract, tokenId) {\n    return await this.loaders.auctionInfoLoader.load([tokenContract.toLowerCase(), tokenId].join('-'));\n  } // use dash between lowercase contract id and token id\n\n\n  async loadAuctionInfos(tokenContractAndIds) {\n    return await this.loaders.auctionInfoLoader.loadMany(tokenContractAndIds);\n  }\n  /**\n   *\n   * @param address string address of username to load\n   * @returns\n   */\n\n\n  async loadUsername(address) {\n    return this.loaders.usernameLoader.load(address.toLowerCase());\n  }\n\n  async loadEnsName(address) {\n    return this.loaders.ensLoader.load(address.toLowerCase());\n  }\n  /**\n   * Fetch function to retrieve Graph data for matching curated auctions\n   * This function is not cached\n   *\n   * @function fetchReserveAuctions\n   * @private\n   * @param curatorIds list of Zora NFT IDs to fetch from the graph datastore\n   * @returns mapped transformed list of curated auction results\n   */\n\n\n  async fetchReserveAuctions(curatorIds) {\n    let isApproved = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let first = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n    let skip = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n    const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {\n      fetch: fetchWithTimeout.fetch\n    });\n    let query = zora_graph_1.GET_ALL_AUCTIONS;\n\n    if (curatorIds.length) {\n      query = zora_graph_1.GET_AUCTION_BY_CURATOR;\n    }\n\n    const response = await client.request(query, {\n      curators: curatorIds.length ? curatorIds : undefined,\n      first: first,\n      skip: skip,\n      approved: isApproved === null ? [true, false] : [isApproved]\n    });\n    return response.reserveAuctions;\n  }\n\n  async fetchAuctionNFTInfo(tokenAndAddresses) {\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n    const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {\n      fetch: fetchWithTimeout.fetch\n    });\n    const response = await client.request(zora_graph_1.GET_AUCTION_BY_MEDIA, {\n      tokens: tokenAndAddresses.map(tokenAndAddress => tokenAndAddress.toLowerCase())\n    });\n\n    if (!response.reserveAuctions) {\n      throw new RequestError_1.RequestError('Missing auction in reponse');\n    }\n\n    return tokenAndAddresses.map(tokenAndAddress => response.reserveAuctions.find(auction => auction.token === tokenAndAddress) || new ErrorUtils_1.NotFoundError('Missing Auction'));\n  }\n  /**\n   * Internal fetch current auctions by curator\n   *\n   * @function fetchMediaGraph\n   * @private\n   * @param mediaIds list of Zora NFT IDs to fetch from the graph datastore\n   * @returns mapped transformed list of zora NFT ID data\n   */\n\n\n  async fetchMediaGraph(mediaIds) {\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n    const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {\n      fetch: fetchWithTimeout.fetch\n    });\n    const response = await client.request(zora_graph_1.GET_MEDIAS_QUERY, {\n      id_ids: mediaIds,\n      creator_ids: [],\n      owner_ids: []\n    });\n    return mediaIds.map(key => TransformFetchResults_1.transformMediaForKey(response, key, this.networkId));\n  }\n  /**\n   * Fetches generic NFT information\n   *\n   * @param nftAddresses list of addresses in a 0xcontractid:tokenid format\n   * @returns\n   */\n\n\n  async fetchGenericNFT(nftAddresses) {\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.OpenSea);\n    const apiBase = urls_1.OPENSEA_API_URL_BY_NETWORK[this.networkId];\n    const urlParams = [];\n    nftAddresses.map(address => address.split(':')).forEach(_ref3 => {\n      let [address, tokenId] = _ref3;\n      urlParams.push(`token_ids=${tokenId}&asset_contract_addresses=${address}`);\n    });\n    const response = await fetchWithTimeout.fetch(`${apiBase}assets?${urlParams.join('&')}&order_direction=desc&offset=0&limit=50`);\n    const responseJson = await response.json();\n    return nftAddresses.map(nftAddress => OpenseaUtils_1.transformGenericNFTForKey(responseJson.assets, nftAddress));\n  }\n  /**\n   * Fetches zora username information from blockchain addresses for displaying user\n   * information.\n   *\n   * @param addresses string list of addresses to map to Zora usernames\n   * @returns list of UsernameResponseType - all fields are optional except address\n   */\n\n\n  async fetchZoraUsernames(addresses) {\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Zora);\n    const response = await fetchWithTimeout.fetch(urls_1.ZORA_USERNAME_API_URL, {\n      method: 'POST',\n      type: 'cors',\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: JSON.stringify({\n        addresses\n      })\n    });\n    const usernames = await response.json();\n    return addresses.map(address => {\n      const foundUsername = usernames.find(username => username.address.toLowerCase() === address);\n\n      if (foundUsername) {\n        return foundUsername;\n      }\n\n      return {\n        address\n      };\n    });\n  }\n  /**\n   * Internal fetch function to retrieve currency information from TheGraph\n   *\n   * @function fetchCurrenciesGraph\n   * @private\n   * @param currencyContracts list of Ethereum addresses of currency contract data to retrieve\n   * @returns mapped transformed list of ETH currency mapping data\n   */\n\n\n  async fetchCurrenciesGraph(currencyContracts) {\n    const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n    const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_UNISWAP_URL_BY_NETWORK[this.networkId], {\n      fetch: fetchWithTimeout.fetch\n    });\n    const currencies = await client.request(uniswap_1.GET_TOKEN_VALUES_QUERY, {\n      currencyContracts: currencyContracts.filter(contract => contract !== TransformFetchResults_1.NULL_ETH_CURRENCY_ID)\n    });\n    return currencyContracts.map(key => TransformFetchResults_1.transformCurrencyForKey(currencies, key));\n  }\n  /**\n   * Fetch method to query metadata from IPFS. Not cached\n   *\n   * @function fetchIPFSMetadataCached\n   * @public\n   * @param url Metadata Source\n   * @returns IPFS Metadata Fetch\n   * @throws RequestError\n   */\n\n\n  async fetchIPFSMetadata(url) {\n    // TODO(iain): Properly parse metadata from `ourzora/media-metadata-schemas`\n    const request = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS, 'application/json').fetch(UriUtils_1.convertURIToHTTPS(url));\n\n    try {\n      return await request.json();\n    } catch (e) {\n      throw new RequestError_1.RequestError('Cannot read JSON metadata from IPFS', e);\n    }\n  }\n\n}\n\nexports.MediaFetchAgent = MediaFetchAgent;","map":{"version":3,"sources":["/Users/derekbrown/workspace/10kdigits/node_modules/@zoralabs/nft-hooks/dist/fetcher/MediaFetchAgent.js"],"names":["Object","defineProperty","exports","value","MediaFetchAgent","tslib_1","require","dataloader_1","__importDefault","graphql_request_1","address_1","RequestError_1","urls_1","EnsReverseFetcher_1","zora_graph_1","uniswap_1","timeouts_1","TransformFetchResults_1","FetchWithTimeout_1","OpenseaUtils_1","zora_indexer_1","ErrorUtils_1","UriUtils_1","constructor","network","timeouts","DEFAULT_NETWORK_TIMEOUTS_MS","networkId","loaders","mediaLoader","default","keys","fetchMediaGraph","cache","currencyLoader","fetchCurrenciesGraph","zoraNFTIndexerLoader","fetchZoraNFTIndexerNFTs","usernameLoader","fetchZoraUsernames","genericNFTLoader","fetchGenericNFT","maxBatchSize","ensLoader","loadEnsBatch","auctionInfoLoader","fetchAuctionNFTInfo","clearCache","values","forEach","loader","clearAll","loadCurrencies","currencies","results","loadMany","reduce","last","result","Error","token","id","fetchContent","url","contentType","startsWith","response","FetchWithTimeout","IPFS","fetch","convertURIToHTTPS","text","type","mimeType","e","RequestError","uri","fetchContentMimeType","method","header","headers","get","fetchZNFTGroupData","ids","fetchWithTimeout","Graph","client","GraphQLClient","THEGRAPH_API_URL_BY_NETWORK","getQuery","base","id_ids","creator_ids","owner_ids","idsNormalized","map","toLowerCase","request","GET_MEDIAS_QUERY","medias","creator","owner","media","transformMediaItem","addresses","addressToNames","reverseResolveEnsAddresses","Rpc","address","ZoraIndexer","ZORA_INDEXER_URL_BY_NETWORK","BY_IDS","key","Token","find","NotFoundError","loadZoraNFTIndexerNFTUntransformed","contractAddress","tokenId","load","getAddress","loadZoraNFTIndexerNFTsUntransformed","tokenAndIds","fetchZoraIndexerGroupData","collectionAddresses","curatorAddress","approved","onlyAuctions","limit","offset","length","ArgumentsError","queryStatement","push","_in","approvedStatement","undefined","_eq","auctions","curator","auctionsQueryStmt","_not","ACTIVE_AUCTIONS_QUERY","andQuery","fetchZoraIndexerUserOwnedNFTs","userAddress","addressQueryPart","BY_OWNER","loadZNFTData","mediaId","currencyInfos","chainInfo","pricing","addAuctionInformation","loadNFTData","auctionData","currencyData","contractAndToken","nftInfo","loadAuctionInfo","err","console","error","transformOpenseaResponse","loadNFTDataUntransformed","loadZNFTDataUntransformed","tokenContract","join","loadAuctionInfos","tokenContractAndIds","loadUsername","loadEnsName","fetchReserveAuctions","curatorIds","isApproved","first","skip","query","GET_ALL_AUCTIONS","GET_AUCTION_BY_CURATOR","curators","reserveAuctions","tokenAndAddresses","GET_AUCTION_BY_MEDIA","tokens","tokenAndAddress","auction","mediaIds","transformMediaForKey","nftAddresses","OpenSea","apiBase","OPENSEA_API_URL_BY_NETWORK","urlParams","split","responseJson","json","nftAddress","transformGenericNFTForKey","assets","Zora","ZORA_USERNAME_API_URL","body","JSON","stringify","usernames","foundUsername","username","currencyContracts","THEGRAPH_UNISWAP_URL_BY_NETWORK","GET_TOKEN_VALUES_QUERY","filter","contract","NULL_ETH_CURRENCY_ID","transformCurrencyForKey","fetchIPFSMetadata"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MediaFetchAgent = void 0;\nconst tslib_1 = require(\"tslib\");\nconst dataloader_1 = tslib_1.__importDefault(require(\"dataloader\"));\nconst graphql_request_1 = require(\"graphql-request\");\nconst address_1 = require(\"@ethersproject/address\");\nconst RequestError_1 = require(\"./RequestError\");\nconst urls_1 = require(\"../constants/urls\");\nconst EnsReverseFetcher_1 = require(\"./EnsReverseFetcher\");\nconst zora_graph_1 = require(\"../graph-queries/zora-graph\");\nconst uniswap_1 = require(\"../graph-queries/uniswap\");\nconst timeouts_1 = require(\"../constants/timeouts\");\nconst TransformFetchResults_1 = require(\"./TransformFetchResults\");\nconst FetchWithTimeout_1 = require(\"./FetchWithTimeout\");\nconst OpenseaUtils_1 = require(\"./OpenseaUtils\");\nconst zora_indexer_1 = require(\"../graph-queries/zora-indexer\");\nconst ErrorUtils_1 = require(\"./ErrorUtils\");\nconst UriUtils_1 = require(\"./UriUtils\");\n/**\n * Internal agent for NFT Hooks to fetch NFT information.\n * Can be used directly for interaction with non-react web frameworks or server frameworks.\n * Uses a cached promise-based API.\n * Fetches from IPFS providers and thegraph.\n */\nclass MediaFetchAgent {\n    constructor(network) {\n        this.timeouts = timeouts_1.DEFAULT_NETWORK_TIMEOUTS_MS;\n        this.networkId = network;\n        this.loaders = {\n            mediaLoader: new dataloader_1.default((keys) => this.fetchMediaGraph(keys), { cache: false }),\n            currencyLoader: new dataloader_1.default((keys) => this.fetchCurrenciesGraph(keys), {\n                cache: false,\n            }),\n            zoraNFTIndexerLoader: new dataloader_1.default((keys) => this.fetchZoraNFTIndexerNFTs(keys)),\n            usernameLoader: new dataloader_1.default((keys) => this.fetchZoraUsernames(keys)),\n            genericNFTLoader: new dataloader_1.default((keys) => this.fetchGenericNFT(keys), {\n                cache: false,\n                maxBatchSize: 30,\n            }),\n            ensLoader: new dataloader_1.default((keys) => this.loadEnsBatch(keys), { maxBatchSize: 100 }),\n            auctionInfoLoader: new dataloader_1.default((keys) => this.fetchAuctionNFTInfo(keys), {\n                cache: false,\n                maxBatchSize: 300,\n            }),\n        };\n    }\n    /**\n     * Clear all cached responses from metadata, currency, and NFT chain information loaders\n     */\n    clearCache() {\n        Object.values(this.loaders).forEach((loader) => loader.clearAll());\n    }\n    /**\n     * Gets information of currencies and trading prices from uniswap\n     * @param currencies list of currency contract ids on ethereum\n     * @returns Promise<CurrencyLookupType>\n     */\n    async loadCurrencies(currencies) {\n        const results = await this.loaders.currencyLoader.loadMany(currencies);\n        return results.reduce((last, result) => {\n            if (!(result instanceof Error)) {\n                last[result.token.id] = result;\n            }\n            return last;\n        }, {});\n    }\n    /**\n     * Fetch NFT content or retun URI if content shouild not be fetched\n     * @param url NFT Content URL\n     * @param contentType string mime type to fetch\n     * @returns Promise<MediaContentType> Media content information or URL\n     */\n    async fetchContent(url, contentType) {\n        if (contentType.startsWith('text/')) {\n            try {\n                const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS).fetch(UriUtils_1.convertURIToHTTPS(url));\n                return {\n                    text: await response.text(),\n                    type: 'text',\n                    mimeType: contentType,\n                };\n            }\n            catch (e) {\n                throw new RequestError_1.RequestError('Issue fetching IPFS data', e);\n            }\n        }\n        return { uri: url, type: 'uri', mimeType: contentType };\n    }\n    /**\n     * Fetch Content MIME type from content URI\n     *\n     * @param url IPFS Content URI\n     * @returns mime type as a string\n     * @throws RequestError\n     */\n    async fetchContentMimeType(url) {\n        const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS).fetch(UriUtils_1.convertURIToHTTPS(url), {\n            method: 'HEAD',\n        });\n        const header = response.headers.get('content-type');\n        if (!header) {\n            throw new RequestError_1.RequestError('No content type returned for URI');\n        }\n        return header;\n    }\n    /**\n     * Un-batched fetch function to fetch a group of ZNFT data\n     *\n     * @param ids list of ids to query\n     * @param type type of ids: creator, id (of media), owner\n     * @returns\n     */\n    async fetchZNFTGroupData(ids, type) {\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {\n            fetch: fetchWithTimeout.fetch,\n        });\n        const getQuery = () => {\n            let base = {\n                id_ids: [],\n                creator_ids: [],\n                owner_ids: [],\n            };\n            const idsNormalized = ids.map((id) => id.toLowerCase());\n            switch (type) {\n                case 'id':\n                    base.id_ids = idsNormalized;\n                    break;\n                case 'creator':\n                    base.creator_ids = idsNormalized;\n                    break;\n                case 'owner':\n                    base.owner_ids = idsNormalized;\n                    break;\n            }\n            return base;\n        };\n        const response = (await client.request(zora_graph_1.GET_MEDIAS_QUERY, getQuery));\n        const medias = [...response.creator, ...response.owner, ...response.id];\n        return medias.map((media) => TransformFetchResults_1.transformMediaItem(media, this.networkId));\n    }\n    async loadEnsBatch(addresses) {\n        const addressToNames = await EnsReverseFetcher_1.reverseResolveEnsAddresses(addresses, this.networkId, this.timeouts.Rpc);\n        return addresses.map((address) => addressToNames[address] || Error('Not found'));\n    }\n    // Alpha: uses zora indexer\n    // format CONTRACT_ID-TOKEN_ID\n    async fetchZoraNFTIndexerNFTs(keys) {\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.ZoraIndexer);\n        const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {\n            fetch: fetchWithTimeout.fetch,\n        });\n        const response = await client.request(zora_indexer_1.BY_IDS, {\n            ids: keys,\n        });\n        return keys.map((key) => response.Token.find((token) => token.id === key) || new ErrorUtils_1.NotFoundError('Did not find token'));\n    }\n    async loadZoraNFTIndexerNFTUntransformed(contractAddress, tokenId) {\n        return this.loaders.zoraNFTIndexerLoader.load(`${address_1.getAddress(contractAddress)}-${tokenId}`);\n    }\n    async loadZoraNFTIndexerNFTsUntransformed(tokenAndIds) {\n        return this.loaders.zoraNFTIndexerLoader.loadMany(tokenAndIds);\n    }\n    /**\n     * Un-batched fetch function to fetch a group of NFT data from the zora indexer\n     *\n     * @param collectionAddresses list of collections to include\n     * @param curatorAddress curator to query\n     * @param approved boolean if the auction is approved (null for approved and un-approved auctions)\n     */\n    async fetchZoraIndexerGroupData({ collectionAddresses, curatorAddress, approved = null, onlyAuctions = false, limit = 200, offset = 0, }) {\n        if (!(collectionAddresses === null || collectionAddresses === void 0 ? void 0 : collectionAddresses.length) && !curatorAddress) {\n            throw new ErrorUtils_1.ArgumentsError('Needs to have at least one curator or collector');\n        }\n        if (!onlyAuctions && approved !== null) {\n            throw new ErrorUtils_1.ArgumentsError('approved=true or approved=false and onlyAuctions=false cannot be set at the same time for fetchZoraIndexerGroupData');\n        }\n        let queryStatement = [];\n        if (collectionAddresses) {\n            const addresses = collectionAddresses.map((address) => address_1.getAddress(address));\n            queryStatement.push({ address: { _in: addresses } });\n        }\n        let approvedStatement = undefined;\n        if (approved !== null) {\n            approvedStatement = { approved: { _eq: approved } };\n        }\n        if (curatorAddress) {\n            queryStatement.push({\n                auctions: { curator: { _eq: curatorAddress }, ...approvedStatement },\n            });\n        }\n        else if (approvedStatement || onlyAuctions) {\n            let auctionsQueryStmt = {};\n            if (onlyAuctions) {\n                auctionsQueryStmt = { _not: {} };\n            }\n            queryStatement.push({ auctions: { ...auctionsQueryStmt, ...approvedStatement } });\n        }\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.ZoraIndexer);\n        const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {\n            fetch: fetchWithTimeout.fetch,\n        });\n        return (await client.request(zora_indexer_1.ACTIVE_AUCTIONS_QUERY, {\n            andQuery: queryStatement,\n            offset,\n            limit,\n        })).Token;\n    }\n    /**\n     * Un-batched fetch function to fetch a group of NFT data from the zora indexer\n     *\n     * @param collectionAddresses list of addresses for collection\n     * @param userAddress address of user\n     * @param type type of ids: creator, id (of media), owner\n     * @returns\n     */\n    async fetchZoraIndexerUserOwnedNFTs({ collectionAddresses, userAddress, offset = 0, limit = 250, }) {\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.ZoraIndexer);\n        const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {\n            fetch: fetchWithTimeout.fetch,\n        });\n        let addressQueryPart = {};\n        if (collectionAddresses === null || collectionAddresses === void 0 ? void 0 : collectionAddresses.length) {\n            addressQueryPart['_in'] = collectionAddresses.map(address_1.getAddress);\n        }\n        const response = await client.request(zora_indexer_1.BY_OWNER, {\n            addressQueryPart,\n            owner: address_1.getAddress(userAddress),\n            offset,\n            limit,\n        });\n        return response.Token;\n    }\n    /**\n     * Get on-chain ZORA NFT ID associated media information\n     *\n     * @param mediaId ZORA NFT id to retrieve information of\n     * @returns Promise<NFTDataType> On-chain NFT data\n     */\n    async loadZNFTData(mediaId, currencyInfos = {}) {\n        const chainInfo = await this.loaders.mediaLoader.load(mediaId);\n        if (!chainInfo) {\n            throw new RequestError_1.RequestError('Cannot fetch chain information');\n        }\n        return {\n            ...chainInfo,\n            pricing: TransformFetchResults_1.addAuctionInformation(chainInfo.pricing, currencyInfos),\n        };\n    }\n    async loadNFTData(contractAddress, tokenId, auctionData, currencyData) {\n        const contractAndToken = `${contractAddress.toLowerCase()}:${tokenId}`;\n        const nftInfo = await this.loaders.genericNFTLoader.load(contractAndToken);\n        if (!auctionData) {\n            try {\n                auctionData = await this.loadAuctionInfo(contractAddress, tokenId);\n            }\n            catch (err) {\n                if (!(err instanceof ErrorUtils_1.NotFoundError)) {\n                    // Log any not-found error\n                    console.error(err);\n                }\n            }\n        }\n        if (!nftInfo) {\n            throw new RequestError_1.RequestError('Cannot fetch NFT information');\n        }\n        return OpenseaUtils_1.transformOpenseaResponse(nftInfo, auctionData, currencyData);\n    }\n    async loadNFTDataUntransformed(contractAddress, tokenId) {\n        const contractAndToken = `${contractAddress.toLowerCase()}:${tokenId}`;\n        const nftInfo = await this.loaders.genericNFTLoader.load(contractAndToken);\n        if (!nftInfo) {\n            throw new RequestError_1.RequestError('Cannot fetch NFT information');\n        }\n        return nftInfo;\n    }\n    async loadZNFTDataUntransformed(mediaId) {\n        return await this.loaders.mediaLoader.load(mediaId);\n    }\n    async loadAuctionInfo(tokenContract, tokenId) {\n        return await this.loaders.auctionInfoLoader.load([tokenContract.toLowerCase(), tokenId].join('-'));\n    }\n    // use dash between lowercase contract id and token id\n    async loadAuctionInfos(tokenContractAndIds) {\n        return await this.loaders.auctionInfoLoader.loadMany(tokenContractAndIds);\n    }\n    /**\n     *\n     * @param address string address of username to load\n     * @returns\n     */\n    async loadUsername(address) {\n        return this.loaders.usernameLoader.load(address.toLowerCase());\n    }\n    async loadEnsName(address) {\n        return this.loaders.ensLoader.load(address.toLowerCase());\n    }\n    /**\n     * Fetch function to retrieve Graph data for matching curated auctions\n     * This function is not cached\n     *\n     * @function fetchReserveAuctions\n     * @private\n     * @param curatorIds list of Zora NFT IDs to fetch from the graph datastore\n     * @returns mapped transformed list of curated auction results\n     */\n    async fetchReserveAuctions(curatorIds, isApproved = null, first = 1000, skip = 0) {\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {\n            fetch: fetchWithTimeout.fetch,\n        });\n        let query = zora_graph_1.GET_ALL_AUCTIONS;\n        if (curatorIds.length) {\n            query = zora_graph_1.GET_AUCTION_BY_CURATOR;\n        }\n        const response = (await client.request(query, {\n            curators: curatorIds.length ? curatorIds : undefined,\n            first: first,\n            skip: skip,\n            approved: isApproved === null ? [true, false] : [isApproved],\n        }));\n        return response.reserveAuctions;\n    }\n    async fetchAuctionNFTInfo(tokenAndAddresses) {\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {\n            fetch: fetchWithTimeout.fetch,\n        });\n        const response = (await client.request(zora_graph_1.GET_AUCTION_BY_MEDIA, {\n            tokens: tokenAndAddresses.map((tokenAndAddress) => tokenAndAddress.toLowerCase()),\n        }));\n        if (!response.reserveAuctions) {\n            throw new RequestError_1.RequestError('Missing auction in reponse');\n        }\n        return tokenAndAddresses.map((tokenAndAddress) => response.reserveAuctions.find((auction) => auction.token === tokenAndAddress) ||\n            new ErrorUtils_1.NotFoundError('Missing Auction'));\n    }\n    /**\n     * Internal fetch current auctions by curator\n     *\n     * @function fetchMediaGraph\n     * @private\n     * @param mediaIds list of Zora NFT IDs to fetch from the graph datastore\n     * @returns mapped transformed list of zora NFT ID data\n     */\n    async fetchMediaGraph(mediaIds) {\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {\n            fetch: fetchWithTimeout.fetch,\n        });\n        const response = (await client.request(zora_graph_1.GET_MEDIAS_QUERY, {\n            id_ids: mediaIds,\n            creator_ids: [],\n            owner_ids: [],\n        }));\n        return mediaIds.map((key) => TransformFetchResults_1.transformMediaForKey(response, key, this.networkId));\n    }\n    /**\n     * Fetches generic NFT information\n     *\n     * @param nftAddresses list of addresses in a 0xcontractid:tokenid format\n     * @returns\n     */\n    async fetchGenericNFT(nftAddresses) {\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.OpenSea);\n        const apiBase = urls_1.OPENSEA_API_URL_BY_NETWORK[this.networkId];\n        const urlParams = [];\n        nftAddresses\n            .map((address) => address.split(':'))\n            .forEach(([address, tokenId]) => {\n            urlParams.push(`token_ids=${tokenId}&asset_contract_addresses=${address}`);\n        });\n        const response = await fetchWithTimeout.fetch(`${apiBase}assets?${urlParams.join('&')}&order_direction=desc&offset=0&limit=50`);\n        const responseJson = await response.json();\n        return nftAddresses.map((nftAddress) => OpenseaUtils_1.transformGenericNFTForKey(responseJson.assets, nftAddress));\n    }\n    /**\n     * Fetches zora username information from blockchain addresses for displaying user\n     * information.\n     *\n     * @param addresses string list of addresses to map to Zora usernames\n     * @returns list of UsernameResponseType - all fields are optional except address\n     */\n    async fetchZoraUsernames(addresses) {\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Zora);\n        const response = await fetchWithTimeout.fetch(urls_1.ZORA_USERNAME_API_URL, {\n            method: 'POST',\n            type: 'cors',\n            headers: {\n                'content-type': 'application/json',\n            },\n            body: JSON.stringify({ addresses }),\n        });\n        const usernames = (await response.json());\n        return addresses.map((address) => {\n            const foundUsername = usernames.find((username) => username.address.toLowerCase() === address);\n            if (foundUsername) {\n                return foundUsername;\n            }\n            return { address };\n        });\n    }\n    /**\n     * Internal fetch function to retrieve currency information from TheGraph\n     *\n     * @function fetchCurrenciesGraph\n     * @private\n     * @param currencyContracts list of Ethereum addresses of currency contract data to retrieve\n     * @returns mapped transformed list of ETH currency mapping data\n     */\n    async fetchCurrenciesGraph(currencyContracts) {\n        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);\n        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_UNISWAP_URL_BY_NETWORK[this.networkId], {\n            fetch: fetchWithTimeout.fetch,\n        });\n        const currencies = (await client.request(uniswap_1.GET_TOKEN_VALUES_QUERY, {\n            currencyContracts: currencyContracts.filter((contract) => contract !== TransformFetchResults_1.NULL_ETH_CURRENCY_ID),\n        }));\n        return currencyContracts.map((key) => TransformFetchResults_1.transformCurrencyForKey(currencies, key));\n    }\n    /**\n     * Fetch method to query metadata from IPFS. Not cached\n     *\n     * @function fetchIPFSMetadataCached\n     * @public\n     * @param url Metadata Source\n     * @returns IPFS Metadata Fetch\n     * @throws RequestError\n     */\n    async fetchIPFSMetadata(url) {\n        // TODO(iain): Properly parse metadata from `ourzora/media-metadata-schemas`\n        const request = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS, 'application/json').fetch(UriUtils_1.convertURIToHTTPS(url));\n        try {\n            return await request.json();\n        }\n        catch (e) {\n            throw new RequestError_1.RequestError('Cannot read JSON metadata from IPFS', e);\n        }\n    }\n}\nexports.MediaFetchAgent = MediaFetchAgent;\n"]},"metadata":{},"sourceType":"script"}