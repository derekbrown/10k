{"ast":null,"code":"import { __assign } from \"tslib\";\nimport \"../../../utilities/globals/index.js\";\nimport { useContext, useEffect, useReducer, useRef } from 'react';\nimport { QueryData } from \"../../data/index.js\";\nimport { useDeepMemo } from \"./useDeepMemo.js\";\nimport { getApolloContext } from \"../../context/index.js\";\nimport { useAfterFastRefresh } from \"./useAfterFastRefresh.js\";\nexport function useBaseQuery(query, options, lazy) {\n  if (lazy === void 0) {\n    lazy = false;\n  }\n\n  var context = useContext(getApolloContext());\n\n  var _a = useReducer(function (x) {\n    return x + 1;\n  }, 0),\n      tick = _a[0],\n      forceUpdate = _a[1];\n\n  var updatedOptions = options ? __assign(__assign({}, options), {\n    query: query\n  }) : {\n    query: query\n  };\n  var queryDataRef = useRef();\n  var queryData = queryDataRef.current || (queryDataRef.current = new QueryData({\n    options: updatedOptions,\n    context: context,\n    onNewData: function () {\n      if (!queryData.ssrInitiated()) {\n        Promise.resolve().then(function () {\n          return queryDataRef.current && queryDataRef.current.isMounted && forceUpdate();\n        });\n      } else {\n        forceUpdate();\n      }\n    }\n  }));\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n  var memo = {\n    options: __assign(__assign({}, updatedOptions), {\n      onError: void 0,\n      onCompleted: void 0\n    }),\n    context: context,\n    tick: tick\n  };\n  var result = useDeepMemo(function () {\n    return lazy ? queryData.executeLazy() : queryData.execute();\n  }, memo);\n  var queryResult = lazy ? result[1] : result;\n\n  if (__DEV__) {\n    useAfterFastRefresh(forceUpdate);\n  }\n\n  useEffect(function () {\n    return function () {\n      queryData.cleanup();\n      queryDataRef.current = void 0;\n    };\n  }, []);\n  useEffect(function () {\n    return queryData.afterExecute({\n      lazy: lazy\n    });\n  }, [queryResult.loading, queryResult.networkStatus, queryResult.error, queryResult.data, queryData.currentObservable]);\n  return result;\n}","map":{"version":3,"mappings":";AAAA,OAAO,qCAAP;AAEA,SAASA,UAAT,EAAqBC,SAArB,EAAgCC,UAAhC,EAA4CC,MAA5C,QAA0D,OAA1D;AAUA,SAASC,SAAT,QAA0B,qBAA1B;AACA,SAASC,WAAT,QAA4B,kBAA5B;AAEA,SAASC,gBAAT,QAAiC,wBAAjC;AACA,SAASC,mBAAT,QAAoC,0BAApC;AAEA,OAAM,SAAUC,YAAV,CACJC,KADI,EAEJC,OAFI,EAGJC,IAHI,EAGQ;AAAZ;AAAAA;AAAY;;AAEZ,MAAMC,OAAO,GAAGZ,UAAU,CAACM,gBAAgB,EAAjB,CAA1B;;AACM,WAAsBJ,UAAU,CAAC,aAAC;AAAI,YAAC,GAAG,CAAJ;AAAK,GAAX,EAAa,CAAb,CAAhC;AAAA,MAACW,IAAI,QAAL;AAAA,MAAOC,WAAW,QAAlB;;AACN,MAAMC,cAAc,GAAGL,OAAO,GAAEM,sBAAMN,OAAN,GAAa;AAAED,SAAK;AAAP,GAAb,CAAF,GAA2B;AAAEA,SAAK;AAAP,GAAzD;AAEA,MAAMQ,YAAY,GAAGd,MAAM,EAA3B;AACA,MAAMe,SAAS,GAAGD,YAAY,CAACE,OAAb,KAChBF,YAAY,CAACE,OAAb,GAAuB,IAAIf,SAAJ,CAAiC;AACtDM,WAAO,EAAEK,cAD6C;AAEtDH,WAAO,SAF+C;AAGtDQ,aAAS;AACP,UAAI,CAACF,SAAS,CAACG,YAAV,EAAL,EAA+B;AAO7BC,eAAO,CAACC,OAAR,GAAkBC,IAAlB,CAAuB;AAAM,6BAAY,CAACL,OAAb,IAAwBF,YAAY,CAACE,OAAb,CAAqBM,SAA7C,IAA0DX,WAAW,EAArE;AAAuE,SAApG;AACD,OARD,MAQO;AAGLA,mBAAW;AACZ;AACF;AAjBqD,GAAjC,CADP,CAAlB;AAsBAI,WAAS,CAACQ,UAAV,CAAqBX,cAArB;AACAG,WAAS,CAACN,OAAV,GAAoBA,OAApB;AAKA,MAAMe,IAAI,GAAG;AACXjB,WAAO,EAAEM,sBACJD,cADI,GACU;AACjBa,aAAO,EAAE,KAAK,CADG;AAEjBC,iBAAW,EAAE,KAAK;AAFD,KADV,CADE;AAMXjB,WAAO,SANI;AAOXC,QAAI;AAPO,GAAb;AAUA,MAAMiB,MAAM,GAAGzB,WAAW,CACxB;AAAM,WAACM,IAAI,GAAGO,SAAS,CAACa,WAAV,EAAH,GAA6Bb,SAAS,CAACc,OAAV,EAAlC;AAAsD,GADpC,EAExBL,IAFwB,CAA1B;AAKA,MAAMM,WAAW,GAAGtB,IAAI,GACnBmB,MAAwC,CAAC,CAAD,CADrB,GAEnBA,MAFL;;AAIA,MAAII,OAAJ,EAAa;AAEX3B,uBAAmB,CAACO,WAAD,CAAnB;AACD;;AAEDb,WAAS,CAAC;AACR,WAAO;AACLiB,eAAS,CAACiB,OAAV;AAGAlB,kBAAY,CAACE,OAAb,GAAuB,KAAK,CAA5B;AACD,KALD;AAMD,GAPQ,EAON,EAPM,CAAT;AASAlB,WAAS,CAAC;AAAM,oBAAS,CAACmC,YAAV,CAAuB;AAAEzB,UAAI;AAAN,KAAvB;AAAgC,GAAvC,EAAyC,CAChDsB,WAAW,CAACI,OADoC,EAEhDJ,WAAW,CAACK,aAFoC,EAGhDL,WAAW,CAACM,KAHoC,EAIhDN,WAAW,CAACO,IAJoC,EAKhDtB,SAAS,CAACuB,iBALsC,CAAzC,CAAT;AAQA,SAAOX,MAAP;AACD","names":["useContext","useEffect","useReducer","useRef","QueryData","useDeepMemo","getApolloContext","useAfterFastRefresh","useBaseQuery","query","options","lazy","context","tick","forceUpdate","updatedOptions","__assign","queryDataRef","queryData","current","onNewData","ssrInitiated","Promise","resolve","then","isMounted","setOptions","memo","onError","onCompleted","result","executeLazy","execute","queryResult","__DEV__","cleanup","afterExecute","loading","networkStatus","error","data","currentObservable"],"sourceRoot":"","sources":["../../../../src/react/hooks/utils/useBaseQuery.ts"],"sourcesContent":["import '../../../utilities/globals';\n\nimport { useContext, useEffect, useReducer, useRef } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  QueryHookOptions,\n  QueryDataOptions,\n  QueryTuple,\n  QueryResult,\n} from '../../types/types';\nimport { QueryData } from '../../data';\nimport { useDeepMemo } from './useDeepMemo';\nimport { OperationVariables } from '../../../core';\nimport { getApolloContext } from '../../context';\nimport { useAfterFastRefresh } from './useAfterFastRefresh';\n\nexport function useBaseQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: QueryHookOptions<TData, TVariables>,\n  lazy = false\n) {\n  const context = useContext(getApolloContext());\n  const [tick, forceUpdate] = useReducer(x => x + 1, 0);\n  const updatedOptions = options ? { ...options, query } : { query };\n\n  const queryDataRef = useRef<QueryData<TData, TVariables>>();\n  const queryData = queryDataRef.current || (\n    queryDataRef.current = new QueryData<TData, TVariables>({\n      options: updatedOptions as QueryDataOptions<TData, TVariables>,\n      context,\n      onNewData() {\n        if (!queryData.ssrInitiated()) {\n          // When new data is received from the `QueryData` object, we want to\n          // force a re-render to make sure the new data is displayed. We can't\n          // force that re-render if we're already rendering however so to be\n          // safe we'll trigger the re-render in a microtask. In case the\n          // component gets unmounted before this callback fires, we re-check\n          // queryDataRef.current.isMounted before calling forceUpdate().\n          Promise.resolve().then(() => queryDataRef.current && queryDataRef.current.isMounted && forceUpdate());\n        } else {\n          // If we're rendering on the server side we can force an update at\n          // any point.\n          forceUpdate();\n        }\n      }\n    })\n  );\n\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n\n  // `onError` and `onCompleted` callback functions will not always have a\n  // stable identity, so we'll exclude them from the memoization key to\n  // prevent `afterExecute` from being triggered un-necessarily.\n  const memo = {\n    options: {\n      ...updatedOptions,\n      onError: void 0,\n      onCompleted: void 0\n    } as QueryHookOptions<TData, TVariables>,\n    context,\n    tick\n  };\n\n  const result = useDeepMemo(\n    () => (lazy ? queryData.executeLazy() : queryData.execute()),\n    memo\n  );\n\n  const queryResult = lazy\n    ? (result as QueryTuple<TData, TVariables>)[1]\n    : (result as QueryResult<TData, TVariables>);\n\n  if (__DEV__) {\n    // ensure we run an update after refreshing so that we reinitialize\n    useAfterFastRefresh(forceUpdate);\n  }\n\n  useEffect(() => {\n    return () => {\n      queryData.cleanup();\n      // this effect can run multiple times during a fast-refresh\n      // so make sure we clean up the ref\n      queryDataRef.current = void 0;\n    }\n  }, []);\n\n  useEffect(() => queryData.afterExecute({ lazy }), [\n    queryResult.loading,\n    queryResult.networkStatus,\n    queryResult.error,\n    queryResult.data,\n    queryData.currentObservable,\n  ]);\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}