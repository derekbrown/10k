{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\n\nvar DataLoader = /*#__PURE__*/function () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n  } // Private\n\n\n  var _proto = DataLoader.prototype;\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\n    }\n\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n\n    var cacheKey = this._cacheKeyFn(key); // If caching and there is a cache-hit, return cached Promise.\n\n\n    if (cacheMap) {\n      var cachedPromise = cacheMap.get(cacheKey);\n\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  ;\n\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n\n    var loadPromises = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n\n      cacheMap[\"delete\"](cacheKey);\n    }\n\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  ;\n\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n\n    return this;\n  };\n\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n\n  resolvedPromise.then(function () {\n    process.nextTick(fn);\n  });\n} : typeof setImmediate === 'function' ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n}; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\n\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    dispatchBatch(loader, newBatch);\n  });\n\n  return newBatch;\n}\n\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n\n  var batchPromise = loader._batchLoadFn(batch.keys); // Assert the expected response from batchLoadFn\n\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var value = values[i];\n\n      if (value instanceof Error) {\n        batch.callbacks[i].reject(value);\n      } else {\n        batch.callbacks[i].resolve(value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n\n  if (!shouldBatch) {\n    return 1;\n  }\n\n  var maxBatchSize = options && options.maxBatchSize;\n\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n\n  return maxBatchSize;\n} // Private\n\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n\n  if (!shouldCache) {\n    return null;\n  }\n\n  var cacheMap = options && options.cacheMap;\n\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n\n  return cacheMap;\n} // Private\n\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\n\nmodule.exports = DataLoader;","map":{"version":3,"sources":["/Users/derekbrown/workspace/10kdigits/node_modules/dataloader/index.js"],"names":["DataLoader","batchLoadFn","options","TypeError","_batchLoadFn","_maxBatchSize","getValidMaxBatchSize","_batchScheduleFn","getValidBatchScheduleFn","_cacheKeyFn","getValidCacheKeyFn","_cacheMap","getValidCacheMap","_batch","_proto","prototype","load","key","undefined","String","batch","getCurrentBatch","cacheMap","cacheKey","cachedPromise","get","cacheHits","Promise","resolve","push","keys","promise","reject","callbacks","set","loadMany","isArrayLike","loadPromises","i","length","error","all","clear","clearAll","prime","value","Error","enqueuePostPromiseJob","process","nextTick","fn","resolvedPromise","then","setImmediate","setTimeout","loader","existingBatch","hasDispatched","newBatch","dispatchBatch","resolveCacheHits","batchPromise","failedDispatch","values","shouldBatch","maxBatchSize","Infinity","batchScheduleFn","cacheKeyFn","shouldCache","cache","Map","cacheFunctions","missingFunctions","filter","fnName","join","x","Object","hasOwnProperty","call","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nvar DataLoader =\n/*#__PURE__*/\nfunction () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n  } // Private\n\n\n  var _proto = DataLoader.prototype;\n\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\n    }\n\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n\n    var cacheKey = this._cacheKeyFn(key); // If caching and there is a cache-hit, return cached Promise.\n\n\n    if (cacheMap) {\n      var cachedPromise = cacheMap.get(cacheKey);\n\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  ;\n\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n\n    var loadPromises = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n\n      cacheMap[\"delete\"](cacheKey);\n    }\n\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  ;\n\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n\n    return this;\n  };\n\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n\n  resolvedPromise.then(function () {\n    process.nextTick(fn);\n  });\n} : typeof setImmediate === 'function' ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n}; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    dispatchBatch(loader, newBatch);\n  });\n\n  return newBatch;\n}\n\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n\n  var batchPromise = loader._batchLoadFn(batch.keys); // Assert the expected response from batchLoadFn\n\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var value = values[i];\n\n      if (value instanceof Error) {\n        batch.callbacks[i].reject(value);\n      } else {\n        batch.callbacks[i].resolve(value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n\n  if (!shouldBatch) {\n    return 1;\n  }\n\n  var maxBatchSize = options && options.maxBatchSize;\n\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n\n  return maxBatchSize;\n} // Private\n\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n\n  if (!shouldCache) {\n    return null;\n  }\n\n  var cacheMap = options && options.cacheMap;\n\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n\n  return cacheMap;\n} // Private\n\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\n\nmodule.exports = DataLoader;"]},"metadata":{},"sourceType":"script"}