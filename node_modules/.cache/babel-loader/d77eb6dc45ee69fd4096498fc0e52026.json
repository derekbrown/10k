{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useNFTContent = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst react_1 = require(\"react\");\n\nconst swr_1 = tslib_1.__importDefault(require(\"swr\"));\n\nconst NFTFetchContext_1 = require(\"../context/NFTFetchContext\");\n/**\n * Hook to fetch NFT content from uri and mimetype\n * Fetches text mime types and returns uris for non-text media\n * that should be embedded\n *\n * @param uri URI of content to load or return URI for\n * @param mimeType MIME type expected for content\n * @returns useNFTContentType\n */\n\n\nfunction useNFTContent(uri, mimeType, options) {\n  const fetcher = react_1.useContext(NFTFetchContext_1.NFTFetchContext);\n  const mimeTypeFetched = swr_1.default(uri && !mimeType ? ['fetchContentMimeType', uri] : null, (_, uri) => fetcher.fetchContentMimeType(uri));\n  const mimeTypeResult = mimeType || mimeTypeFetched.data;\n  const content = swr_1.default(uri && mimeTypeResult ? ['fetchContent', uri, mimeTypeResult] : null, (_, uri, mimeTypeResult) => fetcher.fetchContent(uri, mimeTypeResult), options);\n  const error = mimeTypeFetched.error || content.error;\n  return {\n    error,\n    content: content.data\n  };\n}\n\nexports.useNFTContent = useNFTContent;","map":{"version":3,"sources":["/Users/derekbrown/workspace/10kdigits/node_modules/@zoralabs/nft-hooks/dist/hooks/useNFTContent.js"],"names":["Object","defineProperty","exports","value","useNFTContent","tslib_1","require","react_1","swr_1","__importDefault","NFTFetchContext_1","uri","mimeType","options","fetcher","useContext","NFTFetchContext","mimeTypeFetched","default","_","fetchContentMimeType","mimeTypeResult","data","content","fetchContent","error"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,aAAR,GAAwB,KAAK,CAA7B;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAME,KAAK,GAAGH,OAAO,CAACI,eAAR,CAAwBH,OAAO,CAAC,KAAD,CAA/B,CAAd;;AACA,MAAMI,iBAAiB,GAAGJ,OAAO,CAAC,4BAAD,CAAjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,aAAT,CAAuBO,GAAvB,EAA4BC,QAA5B,EAAsCC,OAAtC,EAA+C;AAC3C,QAAMC,OAAO,GAAGP,OAAO,CAACQ,UAAR,CAAmBL,iBAAiB,CAACM,eAArC,CAAhB;AACA,QAAMC,eAAe,GAAGT,KAAK,CAACU,OAAN,CAAcP,GAAG,IAAI,CAACC,QAAR,GAAmB,CAAC,sBAAD,EAAyBD,GAAzB,CAAnB,GAAmD,IAAjE,EAAuE,CAACQ,CAAD,EAAIR,GAAJ,KAAYG,OAAO,CAACM,oBAAR,CAA6BT,GAA7B,CAAnF,CAAxB;AACA,QAAMU,cAAc,GAAGT,QAAQ,IAAIK,eAAe,CAACK,IAAnD;AACA,QAAMC,OAAO,GAAGf,KAAK,CAACU,OAAN,CAAcP,GAAG,IAAIU,cAAP,GAAwB,CAAC,cAAD,EAAiBV,GAAjB,EAAsBU,cAAtB,CAAxB,GAAgE,IAA9E,EAAoF,CAACF,CAAD,EAAIR,GAAJ,EAASU,cAAT,KAA4BP,OAAO,CAACU,YAAR,CAAqBb,GAArB,EAA0BU,cAA1B,CAAhH,EAA2JR,OAA3J,CAAhB;AACA,QAAMY,KAAK,GAAGR,eAAe,CAACQ,KAAhB,IAAyBF,OAAO,CAACE,KAA/C;AACA,SAAO;AACHA,IAAAA,KADG;AAEHF,IAAAA,OAAO,EAAEA,OAAO,CAACD;AAFd,GAAP;AAIH;;AACDpB,OAAO,CAACE,aAAR,GAAwBA,aAAxB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useNFTContent = void 0;\nconst tslib_1 = require(\"tslib\");\nconst react_1 = require(\"react\");\nconst swr_1 = tslib_1.__importDefault(require(\"swr\"));\nconst NFTFetchContext_1 = require(\"../context/NFTFetchContext\");\n/**\n * Hook to fetch NFT content from uri and mimetype\n * Fetches text mime types and returns uris for non-text media\n * that should be embedded\n *\n * @param uri URI of content to load or return URI for\n * @param mimeType MIME type expected for content\n * @returns useNFTContentType\n */\nfunction useNFTContent(uri, mimeType, options) {\n    const fetcher = react_1.useContext(NFTFetchContext_1.NFTFetchContext);\n    const mimeTypeFetched = swr_1.default(uri && !mimeType ? ['fetchContentMimeType', uri] : null, (_, uri) => fetcher.fetchContentMimeType(uri));\n    const mimeTypeResult = mimeType || mimeTypeFetched.data;\n    const content = swr_1.default(uri && mimeTypeResult ? ['fetchContent', uri, mimeTypeResult] : null, (_, uri, mimeTypeResult) => fetcher.fetchContent(uri, mimeTypeResult), options);\n    const error = mimeTypeFetched.error || content.error;\n    return {\n        error,\n        content: content.data,\n    };\n}\nexports.useNFTContent = useNFTContent;\n"]},"metadata":{},"sourceType":"script"}