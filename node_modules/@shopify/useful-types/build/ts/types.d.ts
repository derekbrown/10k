export declare type ThenType<T> = T extends Promise<infer U> ? U : T;
export declare type Arguments<T> = T extends (...args: infer U) => any ? U : never;
export declare type ArgumentAtIndex<Func, Index extends keyof Arguments<Func>> = Arguments<Func>[Index];
export declare type FirstArgument<T> = ArgumentAtIndex<T, 0>;
export declare type MaybeFunctionReturnType<T> = T extends (...args: any[]) => infer U ? U : never;
export declare type ArrayElement<T> = T extends (infer U)[] ? U : never;
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export declare type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? DeepPartial<U>[] : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]>;
};
export declare type IfEmptyObject<Obj, If, Else = never> = keyof Obj extends {
    length: 0;
} ? If : Else;
export declare type IfAllOptionalKeys<Obj, If, Else = never> = NonOptionalKeys<Obj> extends {
    length: 0;
} ? If : Else;
export declare type IfAllNullableKeys<Obj, If, Else = never> = NonNullableKeys<Obj> extends {
    length: 0;
} ? If : Else;
export declare type NonOptionalKeys<T> = {
    [K in keyof T]-?: undefined extends T[K] ? never : K;
}[keyof T];
export declare type NonNullableKeys<T> = {
    [K in keyof T]-?: null extends T[K] ? never : K;
}[keyof T];
export declare type NoInfer<T> = {
    [K in keyof T]: T[K];
} & T;
declare type ReactStatics = 'displayName' | 'getDerivedStateFromProps' | 'getDerivedStateFromErrors' | 'childContextTypes' | 'contextType' | 'contextTypes' | 'getDefaultProps' | 'propTypes';
export declare type NonReactStatics<T> = Pick<T, Exclude<keyof T, ReactStatics>>;
export declare type ExtendedWindow<T> = Window & typeof globalThis & T;
export declare type ConstructorArguments<T> = T extends {
    new (...args: infer U): any;
} ? U : never;
export declare type ConstructorArgumentAtIndex<T, I extends keyof ConstructorArguments<T>> = ConstructorArguments<T>[I];
export declare type FirstConstructorArgument<T> = ConstructorArgumentAtIndex<T, 0>;
declare type Primitive = string | Function | number | boolean | Symbol | undefined | null;
declare type DeepOmitHelper<T, K extends keyof T> = {
    [P in K]: T[P] extends infer TP ? TP extends Primitive ? TP : TP extends any[] ? DeepOmitArray<TP, K> : DeepOmit<TP, K> : never;
};
export declare type DeepOmit<T, K> = T extends Primitive ? T : DeepOmitHelper<T, Exclude<keyof T, K>>;
export declare type DeepOmitArray<T extends any[], K> = {
    [P in keyof T]: DeepOmit<T[P], K>;
};
export declare type PartialSome<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export declare type RequireSome<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
export {};
//# sourceMappingURL=types.d.ts.map