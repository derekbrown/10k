import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { ChakraProvider, FormControl, Flex, Text, Box, FormErrorMessage, Alert, AlertIcon, Skeleton, VStack, Image, Heading, Tag, Grid, FormLabel, Input, InputGroup, InputRightAddon, Wrap, Textarea, Spinner, HStack, TagLabel, TagCloseButton } from '@chakra-ui/react';
import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { CheckIcon, CopyIcon } from '@chakra-ui/icons';
import _extends from '@babel/runtime/helpers/esm/extends';
import { ethers } from 'ethers';
import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';

var _excluded$3 = ["children"];
var Provider = function Provider(_ref) {
  var children = _ref.children,
      props = _objectWithoutProperties(_ref, _excluded$3);

  return /*#__PURE__*/React.createElement(ChakraProvider, props, children);
};

/**
 * A component to display an address
 */
var Address = function Address(_ref) {
  var value = _ref.value,
      provider = _ref.provider,
      _ref$copiable = _ref.copiable,
      copiable = _ref$copiable === void 0 ? false : _ref$copiable,
      _ref$shortened = _ref.shortened,
      shortened = _ref$shortened === void 0 ? false : _ref$shortened,
      _ref$ens = _ref.ens,
      ens = _ref$ens === void 0 ? false : _ref$ens;

  var _useState = useState(undefined),
      _useState2 = _slicedToArray(_useState, 2),
      error = _useState2[0],
      setError = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      copied = _useState4[0],
      setCopied = _useState4[1];

  var feedbackTimeOut;
  var displayAddress = value || '';

  var _useState5 = useState(undefined),
      _useState6 = _slicedToArray(_useState5, 2),
      ensName = _useState6[0],
      setEnsName = _useState6[1];

  useEffect(function () {
    if (value) {
      if (value.includes('.eth') || value === '' || value === 'Not connected') return;
    }

    function fetchEns() {
      return _fetchEns.apply(this, arguments);
    }

    function _fetchEns() {
      _fetchEns = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var ensResponse;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(ens && value && provider)) {
                  _context.next = 12;
                  break;
                }

                _context.prev = 1;
                _context.next = 4;
                return provider === null || provider === void 0 ? void 0 : provider.lookupAddress(value);

              case 4:
                ensResponse = _context.sent;
                setEnsName(ensResponse || undefined);
                return _context.abrupt("return");

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](1);
                return _context.abrupt("return");

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 9]]);
      }));
      return _fetchEns.apply(this, arguments);
    }

    fetchEns();
  }, [value, provider]);

  if (shortened && value) {
    if (value.includes('.eth') || value === '' || value === 'Not connected') {
      displayAddress = value;
    } else {
      displayAddress = "".concat(value.substring(0, 4), "...").concat(value.substring(value.length - 4)).toLowerCase();
    }
  }

  var handleClick = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(copiable && value)) {
                _context2.next = 12;
                break;
              }

              _context2.prev = 1;
              _context2.next = 4;
              return navigator.clipboard.writeText(value);

            case 4:
              setError(undefined);
              setCopied(true);
              feedbackTimeOut = setTimeout(function () {
                setCopied(false);
              }, 2000);
              _context2.next = 12;
              break;

            case 9:
              _context2.prev = 9;
              _context2.t0 = _context2["catch"](1);
              setError(_context2.t0);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[1, 9]]);
    }));

    return function handleClick() {
      return _ref2.apply(this, arguments);
    };
  }();

  useEffect(function () {
    return function () {
      return clearTimeout(feedbackTimeOut);
    };
  }, []);
  return /*#__PURE__*/React.createElement(FormControl, {
    isInvalid: !!error
  }, /*#__PURE__*/React.createElement(Flex, {
    "data-testid": "address-container",
    alignItems: "center",
    cursor: copiable ? 'pointer' : 'initial',
    onClick: handleClick
  }, /*#__PURE__*/React.createElement(Text, null, ensName || displayAddress), copiable && /*#__PURE__*/React.createElement(Box, {
    ml: "auto"
  }, copied ? /*#__PURE__*/React.createElement(CheckIcon, {
    color: "green.500"
  }) : /*#__PURE__*/React.createElement(CopyIcon, {
    color: "gray.300"
  }))), /*#__PURE__*/React.createElement(FormErrorMessage, null, error));
};

/**
 * Component to fetch and display NFT data
 */
var NFT = function NFT(_ref) {
  var contractAddress = _ref.contractAddress,
      tokenId = _ref.tokenId,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 'xs' : _ref$size,
      _ref$isTestnet = _ref.isTestnet,
      isTestnet = _ref$isTestnet === void 0 ? false : _ref$isTestnet;

  var _isMounted = useRef(true);

  var _React$useState = React.useState(),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      nftData = _React$useState2[0],
      setNftData = _React$useState2[1];

  var _React$useState3 = React.useState(),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      errorMessage = _React$useState4[0],
      setErrorMessage = _React$useState4[1];

  var fetchNFTData = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var apiSubDomain, res, data;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            apiSubDomain = isTestnet ? "rinkeby-api" : "api";
            _context.prev = 1;
            _context.next = 4;
            return fetch("https://".concat(apiSubDomain, ".opensea.io/api/v1/asset/").concat(contractAddress, "/").concat(tokenId, "/"));

          case 4:
            res = _context.sent;
            if (isTestnet) console.log("\u26A0\uFE0F OpenSea currently only supports Rinkedby with testnets.");

            if (res.ok) {
              _context.next = 8;
              break;
            }

            throw Error("OpenSea request failed with status: ".concat(res.status, ". Make sure you are on mainnet."));

          case 8:
            _context.next = 10;
            return res.json();

          case 10:
            data = _context.sent;

            if (_isMounted.current) {
              setNftData({
                tokenId: data.token_id,
                imageUrl: data.image_url,
                name: data.name,
                assetContractName: data.asset_contract.name,
                assetContractSymbol: data.asset_contract.symbol,
                animationUrl: data.animation_url
              });
            }

            _context.next = 17;
            break;

          case 14:
            _context.prev = 14;
            _context.t0 = _context["catch"](1);

            if (_context.t0 instanceof Error) {
              setErrorMessage(_context.t0.message);
            } else {
              setErrorMessage('An unknown error occurred');
            }

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 14]]);
  })), [contractAddress, tokenId]);
  useEffect(function () {
    _isMounted.current = true;
    fetchNFTData();
    return function () {
      _isMounted.current = false;
    };
  }, [contractAddress, tokenId]);
  return /*#__PURE__*/React.createElement(NFTCard, {
    data: nftData,
    errorMessage: errorMessage,
    size: size
  });
};
/**
 * Private component to display an NFT given the data
 */

var NFTCard = function NFTCard(_ref3) {
  var data = _ref3.data,
      _ref3$errorMessage = _ref3.errorMessage,
      errorMessage = _ref3$errorMessage === void 0 ? '' : _ref3$errorMessage,
      size = _ref3.size,
      _ref3$hideIfError = _ref3.hideIfError,
      hideIfError = _ref3$hideIfError === void 0 ? false : _ref3$hideIfError;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      error = _useState2[0],
      setError = _useState2[1];

  var name = data === null || data === void 0 ? void 0 : data.name;
  var imageUrl = data === null || data === void 0 ? void 0 : data.imageUrl;
  var assetContractName = data === null || data === void 0 ? void 0 : data.assetContractName;
  var assetContractSymbol = data === null || data === void 0 ? void 0 : data.assetContractSymbol;
  var animationUrl = data === null || data === void 0 ? void 0 : data.animationUrl;
  var tokenId = data === null || data === void 0 ? void 0 : data.tokenId;
  var displayName = name || "".concat(assetContractSymbol, " #").concat(tokenId);

  if (errorMessage || error || imageUrl === '(unknown)' || !imageUrl) {
    if (hideIfError) return null;
    return /*#__PURE__*/React.createElement(Alert, {
      status: "error"
    }, /*#__PURE__*/React.createElement(AlertIcon, null), errorMessage);
  }

  return /*#__PURE__*/React.createElement(Skeleton, {
    isLoaded: !!data,
    maxW: size,
    h: "md"
  }, /*#__PURE__*/React.createElement(Box, {
    maxW: size,
    borderRadius: "lg",
    borderWidth: "1px",
    overflow: "hidden"
  }, animationUrl ? animationUrl.endsWith('.mp3') ? /*#__PURE__*/React.createElement(VStack, null, /*#__PURE__*/React.createElement(Image, {
    src: imageUrl,
    alt: displayName,
    borderRadius: "lg",
    w: size,
    onError: function onError() {
      return setError(true);
    }
  }), /*#__PURE__*/React.createElement("audio", {
    src: animationUrl,
    controls: true,
    autoPlay: true,
    muted: true,
    style: {
      borderRadius: '7px'
    }
  })) : /*#__PURE__*/React.createElement(Flex, {
    w: size,
    h: size,
    bg: "black",
    justifyContent: "center"
  }, /*#__PURE__*/React.createElement("video", {
    src: animationUrl,
    controls: true,
    autoPlay: true,
    muted: true
  })) : /*#__PURE__*/React.createElement(Image, {
    src: imageUrl,
    alt: displayName,
    borderRadius: "lg",
    w: size
  }), /*#__PURE__*/React.createElement(Box, {
    p: "6"
  }, /*#__PURE__*/React.createElement(Flex, {
    alignItems: "center",
    justifyContent: "space-between",
    pb: "2"
  }, /*#__PURE__*/React.createElement(Heading, {
    as: "h3",
    size: "sm",
    style: {
      overflowWrap: 'anywhere'
    }
  }, displayName), assetContractSymbol && /*#__PURE__*/React.createElement(Tag, {
    size: "sm"
  }, assetContractSymbol)), /*#__PURE__*/React.createElement(Text, {
    fontSize: "xs"
  }, assetContractName, " #", tokenId))));
};

/**
 * Component to display a grid of NFTs owned by an address. It uses the OpenSea API to fetch
 * the NFTs.
 */
var NFTGallery = function NFTGallery(_ref) {
  var address = _ref.address,
      _ref$gridWidth = _ref.gridWidth,
      gridWidth = _ref$gridWidth === void 0 ? 4 : _ref$gridWidth,
      web3Provider = _ref.web3Provider,
      _ref$isTestnet = _ref.isTestnet,
      isTestnet = _ref$isTestnet === void 0 ? false : _ref$isTestnet;

  var _React$useState = React.useState([]),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      nfts = _React$useState2[0],
      setNfts = _React$useState2[1];

  var _React$useState3 = React.useState(null),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      errorMessage = _React$useState4[0],
      setErrorMessage = _React$useState4[1];

  useEffect(function () {
    function exec() {
      return _exec.apply(this, arguments);
    }

    function _exec() {
      _exec = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var resolvedAddress, apiSubDomain;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                resolvedAddress = address;
                apiSubDomain = isTestnet ? "rinkeby-api" : "api";
                if (isTestnet) console.log("\u26A0\uFE0F OpenSea currently only supports Rinkeby with testnets.");

                if (!address.endsWith('.eth')) {
                  _context.next = 9;
                  break;
                }

                if (web3Provider) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", console.error('Please provide a web3 provider'));

              case 6:
                _context.next = 8;
                return web3Provider.resolveName(address);

              case 8:
                resolvedAddress = _context.sent;

              case 9:
                fetch("https://".concat(apiSubDomain, ".opensea.io/api/v1/assets?owner=").concat(resolvedAddress)).then(function (res) {
                  if (!res.ok) {
                    throw Error("OpenSea request failed with status: ".concat(res.status, ". Make sure you are on mainnet."));
                  }

                  return res.json();
                }).then(function (data) {
                  setNfts(data.assets);
                  setErrorMessage(null);
                })["catch"](function (err) {
                  return setErrorMessage(err.message);
                });

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _exec.apply(this, arguments);
    }

    exec();
  }, [address, web3Provider]);
  return /*#__PURE__*/React.createElement(VStack, null, errorMessage && /*#__PURE__*/React.createElement(Alert, {
    status: "error"
  }, /*#__PURE__*/React.createElement(AlertIcon, null), errorMessage), /*#__PURE__*/React.createElement(Grid, {
    templateColumns: "repeat(".concat(gridWidth, ", 1fr)"),
    gap: 6
  }, nfts.map(function (nft) {
    return /*#__PURE__*/React.createElement(NFTCard, {
      key: "".concat(nft.asset_contract.symbol, "-").concat(nft.token_id),
      data: {
        name: nft.name,
        imageUrl: nft.image_url,
        tokenId: nft.token_id,
        assetContractName: nft.asset_contract.name,
        assetContractSymbol: nft.asset_contract.symbol
      },
      size: "xs",
      hideIfError: true
    });
  })));
};

var useDebounce = function useDebounce(value, delay) {
  // State and setters for debounced value
  var _useState = useState(value),
      _useState2 = _slicedToArray(_useState, 2),
      debouncedValue = _useState2[0],
      setDebouncedValue = _useState2[1];

  useEffect(function () {
    // Update debounced value after delay
    var handler = setTimeout(function () {
      setDebouncedValue(value);
    }, delay); // Cancel the timeout if value changes (also on delay change or unmount)
    // This is how we prevent debounced value from updating if value is changed ...
    // .. within the delay period. Timeout gets cleared and restarted.

    return function () {
      clearTimeout(handler);
    };
  }, [value, delay] // Only re-call effect if value or delay changes
  );
  return debouncedValue;
};

var _excluded$2 = ["provider", "value", "onChange", "label"];

/**
 * A text input component that is used to get ETH addresses. ENS support included. You can also pass all the styling props of the Chakra UI Input component.
 */
var AddressInput = function AddressInput(_ref) {
  var provider = _ref.provider;
      _ref.value;
      var onChange = _ref.onChange,
      label = _ref.label,
      props = _objectWithoutProperties(_ref, _excluded$2);

  var _useState = useState(''),
      _useState2 = _slicedToArray(_useState, 2),
      inputValue = _useState2[0],
      setInputValue = _useState2[1];

  var debouncedValue = useDebounce(inputValue, 700);

  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      error = _useState4[0],
      setError = _useState4[1];

  var regex = /^0x[a-fA-F0-9]{40}$/;

  var getAddressFromEns = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var address;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return provider.resolveName(debouncedValue);

            case 3:
              address = _context.sent;

              if (!address) {
                setError('Invalid Input');
              }

              return _context.abrupt("return", address);

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](0);
              setError(_context.t0);
              return _context.abrupt("return");

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 8]]);
    }));

    return function getAddressFromEns() {
      return _ref2.apply(this, arguments);
    };
  }();

  useEffect(function () {
    if (debouncedValue) {
      onChange('');
      setError(null);

      if (regex.test(debouncedValue)) {
        onChange(debouncedValue);
      } else if (debouncedValue.endsWith('.eth') || debouncedValue.endsWith('.xyz')) {
        getAddressFromEns().then(function (address) {
          return onChange(address ? address : '');
        });
      }
    }
  }, [debouncedValue]);
  useEffect(function () {
    if (inputValue === '') {
      onChange('');
      setError(null);
    }
  }, [inputValue]);
  return /*#__PURE__*/React.createElement(FormControl, {
    isInvalid: !!error
  }, label && /*#__PURE__*/React.createElement(FormLabel, null, "Input address"), /*#__PURE__*/React.createElement(Input, _extends({
    isInvalid: !!error,
    value: inputValue,
    onChange: function onChange(e) {
      return setInputValue(e.target.value);
    }
  }, props)), /*#__PURE__*/React.createElement(FormErrorMessage, null, error ? ' ' + error : ''));
};

var _excluded$1 = ["value", "unit", "label", "onChange", "showUnit", "placeholder", "error"];

/**
 * An input field that accepts ether values. Always returns the value in wei so that you can directly use it in transactions without any conversion.
 */
var EtherInput = function EtherInput(_ref) {
  _ref.value;
      var _ref$unit = _ref.unit,
      unit = _ref$unit === void 0 ? 'ether' : _ref$unit,
      label = _ref.label,
      _onChange = _ref.onChange,
      _ref$showUnit = _ref.showUnit,
      showUnit = _ref$showUnit === void 0 ? true : _ref$showUnit,
      placeholder = _ref.placeholder,
      error = _ref.error,
      props = _objectWithoutProperties(_ref, _excluded$1);

  var _React$useState = React.useState(),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      plainValue = _React$useState2[0],
      setPlainValue = _React$useState2[1];

  var _placeholder = placeholder || "Enter value in ".concat(unit);

  return /*#__PURE__*/React.createElement(FormControl, {
    isInvalid: !!error
  }, label ? /*#__PURE__*/React.createElement(FormLabel, {
    mb: "8px"
  }, label, ": ") : '', /*#__PURE__*/React.createElement(InputGroup, props, /*#__PURE__*/React.createElement(Input, {
    placeholder: _placeholder,
    value: plainValue,
    onChange: function onChange(e) {
      setPlainValue(e.target.value);

      if (unit === 'ether') {
        _onChange(ethers.utils.parseEther(e.target.value).toString());
      } else {
        _onChange(e.target.value);
      }
    }
  }), showUnit && /*#__PURE__*/React.createElement(InputRightAddon, null, unit === 'ether' ? 'Ξ' : 'wei')), error && /*#__PURE__*/React.createElement(FormErrorMessage, null, error));
};

var _excluded = ["name", "symbol", "balance", "usdValue", "imgUrl"];

/**
 * A stateless component that displays the name, symbol, balance, and USD value of an ERC20 token
 */
var TokenBalance = function TokenBalance(_ref) {
  var name = _ref.name,
      symbol = _ref.symbol,
      balance = _ref.balance,
      usdValue = _ref.usdValue,
      imgUrl = _ref.imgUrl,
      props = _objectWithoutProperties(_ref, _excluded);

  var Headline = function Headline(name) {
    return /*#__PURE__*/React.createElement(Heading, {
      as: "h3",
      size: "sm"
    }, name);
  };

  return /*#__PURE__*/React.createElement(Flex, _extends({
    borderRadius: "lg",
    borderWidth: "1px",
    overflow: "hidden",
    px: "4",
    py: "2"
  }, props), /*#__PURE__*/React.createElement(Box, {
    w: "50px",
    pr: "4"
  }, /*#__PURE__*/React.createElement(Image, {
    src: imgUrl
  })), /*#__PURE__*/React.createElement(Box, {
    flex: "2"
  }, Headline(symbol), /*#__PURE__*/React.createElement("p", null, name)), /*#__PURE__*/React.createElement(Box, {
    flex: "1"
  }, Headline('Balance'), /*#__PURE__*/React.createElement("p", null, balance)), /*#__PURE__*/React.createElement(Box, {
    flex: "1"
  }, Headline('Value'), /*#__PURE__*/React.createElement("p", null, "$", usdValue)));
};

/*
 * Original authors: Hans and Bliss from the Moonshot Collective
 * Original source code: https://github.com/moonshotcollective/pay.party/blob/develop/packages/react-app/src/routes/create/components/MultiAddressInput.jsx
 * @dev This component lets you input multiple addresses and ENS names.
 */
var MultiAddressInput = function MultiAddressInput(_ref) {
  var ensProvider = _ref.ensProvider,
      value = _ref.value,
      onChange = _ref.onChange,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? 'Enter ENS names or addresses here' : _ref$placeholder,
      inputProps = _ref.inputProps;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isLoading = _useState2[0],
      setIsLoading = _useState2[1];

  var addressBadge = function addressBadge(entry) {
    return /*#__PURE__*/React.createElement(Box, {
      p: "1",
      key: entry.input
    }, /*#__PURE__*/React.createElement(HStack, {
      spacing: 4
    }, /*#__PURE__*/React.createElement(Tag, {
      size: "md",
      key: "md",
      borderRadius: "full",
      variant: "solid"
    }, /*#__PURE__*/React.createElement(TagLabel, {
      color: entry.isValid ? 'default' : 'red.300'
    }, entry.input), /*#__PURE__*/React.createElement(TagCloseButton, {
      onClick: function onClick() {
        onChange(value.filter(function (obj) {
          return obj.input !== entry.input;
        }));
      }
    }))));
  };

  var handleChange = function handleChange(e) {
    var lastInput = e.target.value[e.target.value.length - 1];

    if (lastInput === ',' || lastInput === '\n') {
      var splitInput = e.currentTarget.value.split(/[ ,\n]+/).filter(function (c) {
        return c !== '';
      }).map( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(uin) {
          var val;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  val = {
                    input: uin,
                    isValid: false,
                    address: null,
                    ens: null
                  };
                  _context.prev = 1;

                  if (!(uin.endsWith('.eth') || uin.endsWith('.xyz'))) {
                    _context.next = 9;
                    break;
                  }

                  _context.next = 5;
                  return ensProvider.resolveName(uin);

                case 5:
                  val.address = _context.sent;
                  val.ens = uin;
                  _context.next = 13;
                  break;

                case 9:
                  _context.next = 11;
                  return ensProvider.lookupAddress(uin);

                case 11:
                  val.ens = _context.sent;
                  val.address = uin;

                case 13:
                  val.isValid = true;
                  _context.next = 20;
                  break;

                case 16:
                  _context.prev = 16;
                  _context.t0 = _context["catch"](1);
                  val.isValid = false;
                  console.error('Bad Address: ' + uin);

                case 20:
                  return _context.abrupt("return", val);

                case 21:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[1, 16]]);
        }));

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }());
      setIsLoading(true);
      Promise.all(splitInput).then(function (d) {
        onChange([].concat(_toConsumableArray(value), _toConsumableArray(d)));
      })["finally"](function () {
        return setIsLoading(false);
      });
      e.target.value = '';
    }
  };

  return /*#__PURE__*/React.createElement(VStack, null, /*#__PURE__*/React.createElement(Wrap, null, value && value.map(addressBadge)), /*#__PURE__*/React.createElement(Textarea, _extends({
    rows: 1,
    placeholder: placeholder,
    onChange: handleChange,
    disabled: isLoading
  }, inputProps)), isLoading && /*#__PURE__*/React.createElement(Spinner, {
    size: "sm"
  }));
};

export { Address, AddressInput, EtherInput, MultiAddressInput, NFT, NFTCard, NFTGallery, Provider, TokenBalance };
