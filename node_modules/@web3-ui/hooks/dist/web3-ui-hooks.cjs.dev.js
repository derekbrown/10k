'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var React = require('react');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var WalletConnectProvider = require('@walletconnect/web3-provider');
var ethers = require('ethers');
var Web3Modal = require('web3modal');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _regeneratorRuntime__default = /*#__PURE__*/_interopDefault(_regeneratorRuntime);
var React__default = /*#__PURE__*/_interopDefault(React);
var WalletConnectProvider__default = /*#__PURE__*/_interopDefault(WalletConnectProvider);
var Web3Modal__default = /*#__PURE__*/_interopDefault(Web3Modal);

var Web3Context = /*#__PURE__*/React.createContext(undefined);

/**
 * @dev The global provider that handles and stores all the web3 connections. Wrap your entire App with this component.
 * @param children Your app.
 * @param network The network you want to connect to.
 * @param infuraId Your Infura project ID. This is required if you want to support WalletConnect.
 * @param extraWalletProviders An array of extra Wallet Providers you want to support.
 */
var Provider = function Provider(_ref) {
  var children = _ref.children,
      network = _ref.network,
      infuraId = _ref.infuraId,
      _ref$extraWalletProvi = _ref.extraWalletProviders,
      extraWalletProviders = _ref$extraWalletProvi === void 0 ? [] : _ref$extraWalletProvi,
      _ref$rpcUrl = _ref.rpcUrl,
      rpcUrl = _ref$rpcUrl === void 0 ? '' : _ref$rpcUrl;

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      web3Modal = _useState2[0],
      setWeb3Modal = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      signer = _useState4[0],
      setSigner = _useState4[1];

  var _useState5 = React.useState(),
      _useState6 = _slicedToArray(_useState5, 2),
      error = _useState6[0],
      setError = _useState6[1];

  var _useState7 = React.useState(),
      _useState8 = _slicedToArray(_useState7, 2),
      provider = _useState8[0],
      setProvider = _useState8[1];

  var _useState9 = React.useState(),
      _useState10 = _slicedToArray(_useState9, 2),
      userAddress = _useState10[0],
      setUserAddress = _useState10[1];

  var _useState11 = React.useState(),
      _useState12 = _slicedToArray(_useState11, 2),
      chainId = _useState12[0],
      setChainId = _useState12[1];

  var _useState13 = React.useState(false),
      _useState14 = _slicedToArray(_useState13, 2),
      connected = _useState14[0],
      setConnected = _useState14[1];

  var _useState15 = React.useState(true),
      _useState16 = _slicedToArray(_useState15, 2),
      correctNetwork = _useState16[0],
      setCorrectNetwork = _useState16[1];

  var readOnlyProvider = useReadOnlyProvider(rpcUrl);
  var defaulProviderOptions = {
    walletconnect: {
      "package": WalletConnectProvider__default["default"],
      options: {
        bridge: 'https://polygon.bridge.walletconnect.org',
        infuraId: infuraId,
        rpc: {
          1: "https://mainnet.infura.io/v3/".concat(infuraId),
          // mainnet // For more WalletConnect providers: https://docs.walletconnect.org/quick-start/dapps/web3-provider#required
          4: "https://rinkeby.infura.io/v3/".concat(infuraId),
          42: "https://kovan.infura.io/v3/".concat(infuraId),
          100: 'https://dai.poa.network' // xDai

        }
      }
    }
  };
  var connectWallet = React.useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4() {
    var _web3Modal, connection, _provider, _chainId, _signer;

    return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _web3Modal = new Web3Modal__default["default"]({
              providerOptions: Object.assign.apply(Object, [defaulProviderOptions].concat(_toConsumableArray(extraWalletProviders)))
            });
            setWeb3Modal(_web3Modal);
            _context4.next = 5;
            return _web3Modal.connect();

          case 5:
            connection = _context4.sent;
            _provider = new ethers.ethers.providers.Web3Provider(connection);
            setProvider(_provider);
            _context4.next = 10;
            return _provider.getNetwork().then(function (network) {
              return network.chainId;
            });

          case 10:
            _chainId = _context4.sent;
            setChainId(_chainId);
            setCorrectNetwork(_chainId === network);
            _signer = _provider.getSigner();
            setSigner(_signer);
            _context4.t0 = setUserAddress;
            _context4.next = 18;
            return _signer.getAddress();

          case 18:
            _context4.t1 = _context4.sent;
            (0, _context4.t0)(_context4.t1);
            setConnected(true);
            connection.on('chainChanged', /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(newChainId) {
                var formattedChainId, provider, signer;
                return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        formattedChainId = +newChainId;
                        setChainId(formattedChainId);
                        setCorrectNetwork(formattedChainId === network);
                        provider = new ethers.ethers.providers.Web3Provider(connection);
                        setProvider(provider);
                        signer = provider.getSigner();
                        setSigner(signer);
                        _context.t0 = setUserAddress;
                        _context.next = 10;
                        return signer.getAddress();

                      case 10:
                        _context.t1 = _context.sent;
                        (0, _context.t0)(_context.t1);
                        setConnected(true);

                      case 13:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x) {
                return _ref3.apply(this, arguments);
              };
            }());
            connection.on('accountsChanged', /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(accounts) {
                var provider, chainId, signer;
                return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        if (!(accounts.length === 0)) {
                          _context2.next = 4;
                          break;
                        }

                        // The user has disconnected their account from Metamask
                        _web3Modal === null || _web3Modal === void 0 ? void 0 : _web3Modal.clearCachedProvider();
                        disconnectWallet();
                        return _context2.abrupt("return");

                      case 4:
                        provider = new ethers.ethers.providers.Web3Provider(connection);
                        setProvider(provider);
                        _context2.next = 8;
                        return provider.getNetwork().then(function (network) {
                          return network.chainId;
                        });

                      case 8:
                        chainId = _context2.sent;
                        setChainId(chainId);
                        setCorrectNetwork(chainId === network);
                        signer = provider.getSigner();
                        setSigner(signer);
                        _context2.t0 = setUserAddress;
                        _context2.next = 16;
                        return signer.getAddress();

                      case 16:
                        _context2.t1 = _context2.sent;
                        (0, _context2.t0)(_context2.t1);
                        setConnected(true);

                      case 19:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function (_x2) {
                return _ref4.apply(this, arguments);
              };
            }());
            connection.on('disconnect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3() {
              return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _web3Modal === null || _web3Modal === void 0 ? void 0 : _web3Modal.clearCachedProvider();
                      disconnectWallet();

                    case 2:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            })));
            _context4.next = 29;
            break;

          case 26:
            _context4.prev = 26;
            _context4.t2 = _context4["catch"](0);
            setError((_context4.t2 === null || _context4.t2 === void 0 ? void 0 : _context4.t2.message) || _context4.t2.toString());

          case 29:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 26]]);
  })), [network, correctNetwork, infuraId, extraWalletProviders]);
  var disconnectWallet = React.useCallback(function () {
    web3Modal === null || web3Modal === void 0 ? void 0 : web3Modal.clearCachedProvider();
    setSigner(null);
    setUserAddress(null);
    setConnected(false);
  }, [web3Modal]);
  var value = React.useMemo(function () {
    return {
      connectWallet: connectWallet,
      signer: signer,
      userAddress: userAddress,
      disconnectWallet: disconnectWallet,
      connected: connected,
      error: error,
      provider: provider,
      network: network,
      chainId: chainId,
      correctNetwork: correctNetwork,
      readOnlyProvider: readOnlyProvider
    };
  }, [connectWallet, signer, userAddress, error, web3Modal, connected, provider, network, chainId, correctNetwork, readOnlyProvider]);
  return /*#__PURE__*/React__default["default"].createElement(Web3Context.Provider, {
    value: _objectSpread({}, value)
  }, children);
};

var convertToHexStr = function convertToHexStr(num) {
  return num.toString(16);
};
var switchNetwork = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(networkId) {
    var networkHex;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            networkHex = "0x".concat(convertToHexStr(networkId));

            if (!window.ethereum) {
              _context.next = 12;
              break;
            }

            _context.prev = 2;
            _context.next = 5;
            return window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{
                chainId: networkHex
              }]
            });

          case 5:
            _context.next = 10;
            break;

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](2);
            console.log(_context.t0);

          case 10:
            _context.next = 13;
            break;

          case 12:
            alert('Switching networks automatically is only supported in MetaMask. Please consider installing it: https://metamask.io/download.html');

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 7]]);
  }));

  return function switchNetwork(_x) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * @dev Hook to get the current web3 context including information about the connection and other helper methods.
 */

function useWallet() {
  var context = React.useContext(Web3Context);

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      ens = _useState2[0],
      setEns = _useState2[1];

  if (!context) {
    throw new Error('No Web3Context found');
  }

  var connectWallet = context.connectWallet,
      disconnectWallet = context.disconnectWallet,
      userAddress = context.userAddress,
      chainId = context.chainId,
      error = context.error,
      signer = context.signer,
      connected = context.connected,
      provider = context.provider,
      correctNetwork = context.correctNetwork,
      network = context.network,
      readOnlyProvider = context.readOnlyProvider;
  React.useEffect(function () {
    if (userAddress && provider && chainId === NETWORKS.mainnet) {
      provider.lookupAddress(userAddress).then(function (address) {
        setEns(address);
      });
    }
  }, [userAddress, provider]);

  var switchToCorrectNetwork = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (network) switchNetwork(network);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function switchToCorrectNetwork() {
      return _ref.apply(this, arguments);
    };
  }();

  return {
    connectWallet: connectWallet,
    disconnectWallet: disconnectWallet,
    error: error,
    connection: {
      userAddress: userAddress,
      network: CHAIN_ID_TO_NETWORK[chainId],
      signer: signer,
      ens: ens
    },
    connected: connected,
    provider: provider,
    correctNetwork: correctNetwork,
    switchToCorrectNetwork: switchToCorrectNetwork,
    readOnlyProvider: readOnlyProvider
  };
}

/**
 * @description
 * Defines the contract instance on `useState` hook
 */

/**
 * Gets an instance of a contract from its ABI and address.
 * @param address contract address
 * @param abi contract ABI
 * @returns {
 *   contract: An instance of the current contract
 *   isReady: True when the contract is ready to use, false otherwise.
 * }
 */
function useWriteContract(address, abi) {
  var context = React__default["default"].useContext(Web3Context);

  var _React$useState = React__default["default"].useState(null),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      contract = _React$useState2[0],
      setContract = _React$useState2[1];

  var _React$useState3 = React__default["default"].useState(false),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      isReady = _React$useState4[0],
      setIsReady = _React$useState4[1];

  React__default["default"].useEffect(function () {
    if (context !== null && context !== void 0 && context.connected) {
      var newContract = new ethers.Contract(address, abi, context.signer || undefined);
      setContract(newContract);
      setIsReady(true);
    }
  }, [context]);
  return [contract, isReady];
}

/**
 * @dev Hook to get the loading status, error, and data of a function call.
 * @param method The contract function you want to call
 * @returns {
 *  execute: (args: any) => Promise<any>,
 *  loading: boolean,
 *  error: null | Error,
 * } {
 *  execute: Executes the transaction.
 *  loading: True until the the transaction is confirmed, false otherwise.
 *  error: Contains the error object if the transaction failed, null otherwise.
 * }
 */

function useTransaction(method) {
  var _React$useState = React__default["default"].useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      loading = _React$useState2[0],
      setLoading = _React$useState2[1];

  var _React$useState3 = React__default["default"].useState(null),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      error = _React$useState4[0],
      setError = _React$useState4[1];

  var execute = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
      var response,
          _args = arguments;
      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              setLoading(true);
              setError(null);
              _context.prev = 2;
              _context.next = 5;
              return method.apply(void 0, _args);

            case 5:
              response = _context.sent;
              _context.next = 8;
              return response.wait();

            case 8:
              setError(null);
              setLoading(false);
              return _context.abrupt("return", response);

            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](2);
              setError(_context.t0);
              setLoading(false);
              return _context.abrupt("return", _context.t0);

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[2, 13]]);
    }));

    return function execute() {
      return _ref.apply(this, arguments);
    };
  }();

  return [execute, loading, error];
}

var NETWORKS = {
  mainnet: 1,
  ropsten: 3,
  rinkeby: 4,
  goerli: 5,
  optimism: 10,
  kovan: 42,
  BSC: 56,
  optimismKovan: 69,
  BSCTestnet: 97,
  xdai: 100,
  polygon: 137,
  theta: 361,
  thetaTestnet: 365,
  metisStardust: 588,
  metisAndromeda: 1088,
  moonriver: 1285,
  arbitrumOne: 42161,
  arbitrumRinkeby: 421611,
  mumbai: 80001,
  harmony: 1666600000,
  palm: 11297108109,
  localhost: 1337,
  hardhat: 31337,
  fantom: 250,
  avalanche: 43114,
  songbird: 19,
  moonbaseAlpha: 1287
};
var CHAIN_ID_TO_NETWORK = {
  1: 'mainnet',
  3: 'ropsten',
  4: 'rinkeby',
  5: 'goerli',
  10: 'optimism',
  42: 'kovan',
  56: 'BSC',
  69: 'optimismKovan',
  97: 'BSCTestnet',
  100: 'xdai',
  137: 'polygon',
  361: 'theta',
  365: 'thetaTestnet',
  588: 'metisStardust',
  1088: 'metisAndromeda',
  1285: 'moonriver',
  42161: 'arbitrumOne',
  421611: 'arbitrumRinkeby',
  80001: 'mumbai',
  1666600000: 'harmony',
  11297108109: 'palm',
  1337: 'localhost',
  31337: 'hardhat',
  250: 'fantom',
  43114: 'avalanche',
  19: 'songbird',
  1287: 'moonbaseAlpha'
};
var ERC20ABI = [{
  constant: true,
  inputs: [],
  name: 'name',
  outputs: [{
    name: '',
    type: 'string'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: '_spender',
    type: 'address'
  }, {
    name: '_value',
    type: 'uint256'
  }],
  name: 'approve',
  outputs: [{
    name: '',
    type: 'bool'
  }],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [],
  name: 'totalSupply',
  outputs: [{
    name: '',
    type: 'uint256'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: '_from',
    type: 'address'
  }, {
    name: '_to',
    type: 'address'
  }, {
    name: '_value',
    type: 'uint256'
  }],
  name: 'transferFrom',
  outputs: [{
    name: '',
    type: 'bool'
  }],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [],
  name: 'decimals',
  outputs: [{
    name: '',
    type: 'uint8'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: '_owner',
    type: 'address'
  }],
  name: 'balanceOf',
  outputs: [{
    name: 'balance',
    type: 'uint256'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: true,
  inputs: [],
  name: 'symbol',
  outputs: [{
    name: '',
    type: 'string'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: '_to',
    type: 'address'
  }, {
    name: '_value',
    type: 'uint256'
  }],
  name: 'transfer',
  outputs: [{
    name: '',
    type: 'bool'
  }],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: '_owner',
    type: 'address'
  }, {
    name: '_spender',
    type: 'address'
  }],
  name: 'allowance',
  outputs: [{
    name: '',
    type: 'uint256'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  payable: true,
  stateMutability: 'payable',
  type: 'fallback'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'owner',
    type: 'address'
  }, {
    indexed: true,
    name: 'spender',
    type: 'address'
  }, {
    indexed: false,
    name: 'value',
    type: 'uint256'
  }],
  name: 'Approval',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'from',
    type: 'address'
  }, {
    indexed: true,
    name: 'to',
    type: 'address'
  }, {
    indexed: false,
    name: 'value',
    type: 'uint256'
  }],
  name: 'Transfer',
  type: 'event'
}];
var ERC721ABI = [{
  constant: true,
  inputs: [{
    name: 'interfaceId',
    type: 'bytes4'
  }],
  name: 'supportsInterface',
  outputs: [{
    name: '',
    type: 'bool'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  inputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'constructor'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'from',
    type: 'address'
  }, {
    indexed: true,
    name: 'to',
    type: 'address'
  }, {
    indexed: true,
    name: 'tokenId',
    type: 'uint256'
  }],
  name: 'Transfer',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'owner',
    type: 'address'
  }, {
    indexed: true,
    name: 'approved',
    type: 'address'
  }, {
    indexed: true,
    name: 'tokenId',
    type: 'uint256'
  }],
  name: 'Approval',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'owner',
    type: 'address'
  }, {
    indexed: true,
    name: 'operator',
    type: 'address'
  }, {
    indexed: false,
    name: 'approved',
    type: 'bool'
  }],
  name: 'ApprovalForAll',
  type: 'event'
}, {
  constant: true,
  inputs: [{
    name: 'owner',
    type: 'address'
  }],
  name: 'balanceOf',
  outputs: [{
    name: '',
    type: 'uint256'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'tokenId',
    type: 'uint256'
  }],
  name: 'ownerOf',
  outputs: [{
    name: '',
    type: 'address'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'to',
    type: 'address'
  }, {
    name: 'tokenId',
    type: 'uint256'
  }],
  name: 'approve',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'tokenId',
    type: 'uint256'
  }],
  name: 'getApproved',
  outputs: [{
    name: '',
    type: 'address'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'to',
    type: 'address'
  }, {
    name: 'approved',
    type: 'bool'
  }],
  name: 'setApprovalForAll',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'owner',
    type: 'address'
  }, {
    name: 'operator',
    type: 'address'
  }],
  name: 'isApprovedForAll',
  outputs: [{
    name: '',
    type: 'bool'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'to',
    type: 'address'
  }, {
    name: 'tokenId',
    type: 'uint256'
  }],
  name: 'transfer',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'from',
    type: 'address'
  }, {
    name: 'to',
    type: 'address'
  }, {
    name: 'tokenId',
    type: 'uint256'
  }],
  name: 'transferFrom',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'from',
    type: 'address'
  }, {
    name: 'to',
    type: 'address'
  }, {
    name: 'tokenId',
    type: 'uint256'
  }],
  name: 'safeTransferFrom',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'from',
    type: 'address'
  }, {
    name: 'to',
    type: 'address'
  }, {
    name: 'tokenId',
    type: 'uint256'
  }, {
    name: '_data',
    type: 'bytes'
  }],
  name: 'safeTransferFrom',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}];

/**
 * Gets the token balance of the provided account.
 * @param tokenAddress Address of the token
 * @param accountAddress Address of the account
 * @returns {
 * balance: gives account balance for the token in Wei as a string
 * loading: True until the transaction is executing, false otherwise
 * error: Contains the error object if the transaction failed, null otherwise.
 * decimals: number of decimals the token contract is using
 * formattedBalance: Balance in ethers eg. 0.01 ETH, 20 GTC, etc.
 * balanceInBigNumber: Balance in BigNumber
 * }
 */
function useTokenBalance(_ref) {
  var tokenAddress = _ref.tokenAddress,
      accountAddress = _ref.accountAddress;
  var context = React.useContext(Web3Context);
  var provider = context === null || context === void 0 ? void 0 : context.provider;

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      balance = _useState2[0],
      setBalance = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      decimals = _useState4[0],
      setDecimals = _useState4[1];

  var _useState5 = React.useState(true),
      _useState6 = _slicedToArray(_useState5, 2),
      loading = _useState6[0],
      setLoading = _useState6[1];

  var _useState7 = React.useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      error = _useState8[0],
      setError = _useState8[1];

  var getBalance = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
      var contract, _balance, _decimals;

      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              contract = new ethers.ethers.Contract(tokenAddress, ERC20ABI, provider);
              _context.next = 4;
              return contract.balanceOf(accountAddress);

            case 4:
              _balance = _context.sent;
              _context.next = 7;
              return contract.decimals();

            case 7:
              _decimals = _context.sent;
              setBalance(_balance);
              setDecimals(_decimals);
              _context.next = 17;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](0);
              setError(true);
              setLoading(false);
              console.error(error);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 12]]);
    }));

    return function getBalance() {
      return _ref2.apply(this, arguments);
    };
  }();

  React.useEffect(function () {
    if (!(tokenAddress && accountAddress && provider)) {
      setLoading(false);
      setError(true);
      return;
    }

    setError(false);
    setLoading(true);
    getBalance();
    setLoading(false);
  }, [tokenAddress, accountAddress]);
  return {
    balance: balance === null || balance === void 0 ? void 0 : balance.toString(),
    // The balance in wei
    loading: loading,
    error: error,
    decimals: decimals,
    formattedBalance: balance && ethers.ethers.utils.formatUnits(balance, decimals),
    // The balance in ethers eg. 0.01 ETH, 20 GTC, etc.
    balanceInBigNumber: balance
  };
}

var createProvider = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(url) {
    var p;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            p = new ethers.ethers.providers.StaticJsonRpcProvider(url);
            _context.next = 3;
            return p.ready;

          case 3:
            return _context.abrupt("return", p);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function createProvider(_x) {
    return _ref.apply(this, arguments);
  };
}();
/*
 * @dev returns a static JSON RPC provider
 * @param url - The url of the JSON RPC provider
 * @credits scaffold-eth (https://github.com/scaffold-eth/scaffold-eth/blob/master/packages/react-app/src/hooks/useStaticJsonRPC.js)
 */


function useReadOnlyProvider(url) {
  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      provider = _useState2[0],
      setProvider = _useState2[1];

  React.useEffect(function () {
    function createAndSetProvider() {
      return _createAndSetProvider.apply(this, arguments);
    }

    function _createAndSetProvider() {
      _createAndSetProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
        var p;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(url === '')) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                if (url) {
                  _context2.next = 5;
                  break;
                }

                console.error('Please pass in a valid RPC url');
                return _context2.abrupt("return");

              case 5:
                _context2.prev = 5;
                _context2.next = 8;
                return createProvider(url);

              case 8:
                p = _context2.sent;
                setProvider(p);
                _context2.next = 15;
                break;

              case 12:
                _context2.prev = 12;
                _context2.t0 = _context2["catch"](5);
                console.error(_context2.t0);

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[5, 12]]);
      }));
      return _createAndSetProvider.apply(this, arguments);
    }

    createAndSetProvider();
  }, [url]);
  return provider;
}

/*
 * @dev returns a read-only contract instance. You need to pass in a readOnlyProviderUrl to the Provider in order for this to work.
        Does not need a wallet connection / signer to function.
 * @param address - The contract address
 * @param abi - The contract ABI
 */

function useReadOnlyContract(address, abi) {
  var context = React.useContext(Web3Context);
  var readOnlyProvider = context === null || context === void 0 ? void 0 : context.readOnlyProvider;

  var _React$useState = React__default["default"].useState(),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      contract = _React$useState2[0],
      setContract = _React$useState2[1];

  var _React$useState3 = React__default["default"].useState(false),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      isReady = _React$useState4[0],
      setIsReady = _React$useState4[1];

  React.useEffect(function () {
    if (readOnlyProvider) {
      var _contract = new ethers.Contract(address, abi, readOnlyProvider);

      var contractInterface = Object.values(_contract["interface"].functions).reduce(function (accumulator, funcFragment) {
        return _objectSpread(_objectSpread({}, accumulator), {}, _defineProperty({}, funcFragment.name, _contract[funcFragment.name]));
      }, {});
      setContract(contractInterface);
      setIsReady(true);
    }
  }, [address, abi, readOnlyProvider]);
  return [contract, isReady];
}

var usePoller = function usePoller(func, delay) {
  /**
   * Calls a function at a set interval. The function will also be called
   * immediately.
   *
   * @param func The function to call at an interval
   * @param delay The delay between each interval call
   * @example
   * const callback = () => console.log('test')
   * usePoller(callback, 1000) // logs 'test' every second
   */
  var savedCbFunc = React.useRef(func); // Remember the latest fn.

  React.useEffect(function () {
    savedCbFunc.current = func;
  }, [func]);
  React.useEffect(function () {
    if (!delay) {
      return;
    }

    var id = setInterval(savedCbFunc.current, delay);
    return function () {
      return clearInterval(id);
    };
  }, [delay, func]);
  React.useEffect(function () {
    func();
  }, []);
};

exports.CHAIN_ID_TO_NETWORK = CHAIN_ID_TO_NETWORK;
exports.ERC20ABI = ERC20ABI;
exports.ERC721ABI = ERC721ABI;
exports.NETWORKS = NETWORKS;
exports.Provider = Provider;
exports.Web3Context = Web3Context;
exports.usePoller = usePoller;
exports.useReadOnlyContract = useReadOnlyContract;
exports.useReadOnlyProvider = useReadOnlyProvider;
exports.useTokenBalance = useTokenBalance;
exports.useTransaction = useTransaction;
exports.useWallet = useWallet;
exports.useWriteContract = useWriteContract;
