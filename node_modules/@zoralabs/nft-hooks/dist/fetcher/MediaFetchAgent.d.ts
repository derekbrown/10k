import type { NetworkIDs } from '../constants/networks';
import type { ReserveAuctionPartialFragment } from '../graph-queries/zora-graph-types';
import { IndexerTokenWithAuctionFragment } from '../graph-queries/zora-indexer-types';
import { FetchGroupTypes, MediaContentType, UsernameResponseType } from './FetchResultTypes';
import { CurrencyLookupType, NFTDataType, ZNFTMediaDataType } from './AuctionInfoTypes';
import { OpenseaResponse } from './OpenseaUtils';
import { FetchZoraIndexerListCollectionType } from './ZoraIndexerTypes';
/**
 * Internal agent for NFT Hooks to fetch NFT information.
 * Can be used directly for interaction with non-react web frameworks or server frameworks.
 * Uses a cached promise-based API.
 * Fetches from IPFS providers and thegraph.
 */
export declare class MediaFetchAgent {
    readonly networkId: NetworkIDs;
    private timeouts;
    private loaders;
    constructor(network: NetworkIDs);
    /**
     * Clear all cached responses from metadata, currency, and NFT chain information loaders
     */
    clearCache(): void;
    /**
     * Gets information of currencies and trading prices from uniswap
     * @param currencies list of currency contract ids on ethereum
     * @returns Promise<CurrencyLookupType>
     */
    loadCurrencies(currencies: string[]): Promise<CurrencyLookupType>;
    /**
     * Fetch NFT content or retun URI if content shouild not be fetched
     * @param url NFT Content URL
     * @param contentType string mime type to fetch
     * @returns Promise<MediaContentType> Media content information or URL
     */
    fetchContent(url: string, contentType: string): Promise<MediaContentType>;
    /**
     * Fetch Content MIME type from content URI
     *
     * @param url IPFS Content URI
     * @returns mime type as a string
     * @throws RequestError
     */
    fetchContentMimeType(url: string): Promise<string>;
    /**
     * Un-batched fetch function to fetch a group of ZNFT data
     *
     * @param ids list of ids to query
     * @param type type of ids: creator, id (of media), owner
     * @returns
     */
    fetchZNFTGroupData(ids: string[], type: FetchGroupTypes): Promise<ZNFTMediaDataType[]>;
    loadEnsBatch(addresses: readonly string[]): Promise<(string | Error)[]>;
    fetchZoraNFTIndexerNFTs(keys: readonly string[]): Promise<any[]>;
    loadZoraNFTIndexerNFTUntransformed(contractAddress: string, tokenId: string): Promise<IndexerTokenWithAuctionFragment>;
    loadZoraNFTIndexerNFTsUntransformed(tokenAndIds: readonly string[]): Promise<(Error | IndexerTokenWithAuctionFragment)[]>;
    /**
     * Un-batched fetch function to fetch a group of NFT data from the zora indexer
     *
     * @param collectionAddresses list of collections to include
     * @param curatorAddress curator to query
     * @param approved boolean if the auction is approved (null for approved and un-approved auctions)
     */
    fetchZoraIndexerGroupData({ collectionAddresses, curatorAddress, approved, onlyAuctions, limit, offset, }: FetchZoraIndexerListCollectionType): Promise<IndexerTokenWithAuctionFragment[]>;
    /**
     * Un-batched fetch function to fetch a group of NFT data from the zora indexer
     *
     * @param collectionAddresses list of addresses for collection
     * @param userAddress address of user
     * @param type type of ids: creator, id (of media), owner
     * @returns
     */
    fetchZoraIndexerUserOwnedNFTs({ collectionAddresses, userAddress, offset, limit, }: {
        collectionAddresses?: string[];
        userAddress: string;
        offset?: number;
        limit?: number;
    }): Promise<IndexerTokenWithAuctionFragment[]>;
    /**
     * Get on-chain ZORA NFT ID associated media information
     *
     * @param mediaId ZORA NFT id to retrieve information of
     * @returns Promise<NFTDataType> On-chain NFT data
     */
    loadZNFTData(mediaId: string, currencyInfos?: CurrencyLookupType): Promise<NFTDataType>;
    loadNFTData(contractAddress: string, tokenId: string, auctionData?: ReserveAuctionPartialFragment, currencyData?: CurrencyLookupType): Promise<import("./AuctionInfoTypes").OpenseaNFTDataType>;
    loadNFTDataUntransformed(contractAddress: string, tokenId: string): Promise<OpenseaResponse>;
    loadZNFTDataUntransformed(mediaId: string): Promise<ZNFTMediaDataType>;
    loadAuctionInfo(tokenContract: string, tokenId: string): Promise<ReserveAuctionPartialFragment>;
    loadAuctionInfos(tokenContractAndIds: readonly string[]): Promise<(Error | ReserveAuctionPartialFragment)[]>;
    /**
     *
     * @param address string address of username to load
     * @returns
     */
    loadUsername(address: string): Promise<UsernameResponseType>;
    loadEnsName(address: string): Promise<string>;
    /**
     * Fetch function to retrieve Graph data for matching curated auctions
     * This function is not cached
     *
     * @function fetchReserveAuctions
     * @private
     * @param curatorIds list of Zora NFT IDs to fetch from the graph datastore
     * @returns mapped transformed list of curated auction results
     */
    fetchReserveAuctions(curatorIds: readonly string[], isApproved?: boolean | null, first?: number, skip?: number): Promise<({
        __typename?: "ReserveAuction" | undefined;
    } & {
        __typename?: "ReserveAuction" | undefined;
    } & Pick<import("../graph-queries/zora-graph-types").ReserveAuction, "id" | "createdAtTimestamp" | "transactionHash" | "approved" | "tokenId" | "tokenContract" | "status" | "reservePrice" | "firstBidTime" | "token" | "approvedTimestamp" | "curatorFeePercentage" | "duration" | "expectedEndTimestamp" | "finalizedAtTimestamp"> & {
        curator: {
            __typename?: "User" | undefined;
        } & Pick<import("../graph-queries/zora-graph-types").User, "id">;
        tokenOwner: {
            __typename?: "User" | undefined;
        } & Pick<import("../graph-queries/zora-graph-types").User, "id">;
        auctionCurrency: {
            __typename?: "Currency" | undefined;
        } & {
            __typename?: "Currency" | undefined;
        } & Pick<import("../graph-queries/zora-graph-types").Currency, "symbol" | "id" | "name" | "decimals">;
        currentBid?: import("../graph-queries/zora-graph-types").Maybe<{
            __typename?: "ReserveAuctionBid" | undefined;
        } & {
            __typename?: "ReserveAuctionBid" | undefined;
        } & Pick<import("../graph-queries/zora-graph-types").ReserveAuctionBid, "amount" | "createdAtTimestamp" | "transactionHash" | "bidType"> & {
            bidder: {
                __typename?: "User" | undefined;
            } & Pick<import("../graph-queries/zora-graph-types").User, "id">;
        }> | undefined;
        previousBids?: import("../graph-queries/zora-graph-types").Maybe<({
            __typename?: "InactiveReserveAuctionBid" | undefined;
        } & {
            __typename?: "InactiveReserveAuctionBid" | undefined;
        } & Pick<import("../graph-queries/zora-graph-types").InactiveReserveAuctionBid, "id" | "amount" | "createdAtTimestamp" | "transactionHash" | "bidType" | "bidInactivatedAtTimestamp" | "bidInactivatedAtBlockNumber"> & {
            bidder: {
                __typename?: "User" | undefined;
            } & Pick<import("../graph-queries/zora-graph-types").User, "id">;
        })[]> | undefined;
    })[]>;
    private fetchAuctionNFTInfo;
    /**
     * Internal fetch current auctions by curator
     *
     * @function fetchMediaGraph
     * @private
     * @param mediaIds list of Zora NFT IDs to fetch from the graph datastore
     * @returns mapped transformed list of zora NFT ID data
     */
    private fetchMediaGraph;
    /**
     * Fetches generic NFT information
     *
     * @param nftAddresses list of addresses in a 0xcontractid:tokenid format
     * @returns
     */
    private fetchGenericNFT;
    /**
     * Fetches zora username information from blockchain addresses for displaying user
     * information.
     *
     * @param addresses string list of addresses to map to Zora usernames
     * @returns list of UsernameResponseType - all fields are optional except address
     */
    private fetchZoraUsernames;
    /**
     * Internal fetch function to retrieve currency information from TheGraph
     *
     * @function fetchCurrenciesGraph
     * @private
     * @param currencyContracts list of Ethereum addresses of currency contract data to retrieve
     * @returns mapped transformed list of ETH currency mapping data
     */
    private fetchCurrenciesGraph;
    /**
     * Fetch method to query metadata from IPFS. Not cached
     *
     * @function fetchIPFSMetadataCached
     * @public
     * @param url Metadata Source
     * @returns IPFS Metadata Fetch
     * @throws RequestError
     */
    fetchIPFSMetadata(url: string): Promise<any>;
}
