"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaFetchAgent = void 0;
const tslib_1 = require("tslib");
const dataloader_1 = tslib_1.__importDefault(require("dataloader"));
const graphql_request_1 = require("graphql-request");
const address_1 = require("@ethersproject/address");
const RequestError_1 = require("./RequestError");
const urls_1 = require("../constants/urls");
const EnsReverseFetcher_1 = require("./EnsReverseFetcher");
const zora_graph_1 = require("../graph-queries/zora-graph");
const uniswap_1 = require("../graph-queries/uniswap");
const timeouts_1 = require("../constants/timeouts");
const TransformFetchResults_1 = require("./TransformFetchResults");
const FetchWithTimeout_1 = require("./FetchWithTimeout");
const OpenseaUtils_1 = require("./OpenseaUtils");
const zora_indexer_1 = require("../graph-queries/zora-indexer");
const ErrorUtils_1 = require("./ErrorUtils");
const UriUtils_1 = require("./UriUtils");
/**
 * Internal agent for NFT Hooks to fetch NFT information.
 * Can be used directly for interaction with non-react web frameworks or server frameworks.
 * Uses a cached promise-based API.
 * Fetches from IPFS providers and thegraph.
 */
class MediaFetchAgent {
    constructor(network) {
        this.timeouts = timeouts_1.DEFAULT_NETWORK_TIMEOUTS_MS;
        this.networkId = network;
        this.loaders = {
            mediaLoader: new dataloader_1.default((keys) => this.fetchMediaGraph(keys), { cache: false }),
            currencyLoader: new dataloader_1.default((keys) => this.fetchCurrenciesGraph(keys), {
                cache: false,
            }),
            zoraNFTIndexerLoader: new dataloader_1.default((keys) => this.fetchZoraNFTIndexerNFTs(keys)),
            usernameLoader: new dataloader_1.default((keys) => this.fetchZoraUsernames(keys)),
            genericNFTLoader: new dataloader_1.default((keys) => this.fetchGenericNFT(keys), {
                cache: false,
                maxBatchSize: 30,
            }),
            ensLoader: new dataloader_1.default((keys) => this.loadEnsBatch(keys), { maxBatchSize: 100 }),
            auctionInfoLoader: new dataloader_1.default((keys) => this.fetchAuctionNFTInfo(keys), {
                cache: false,
                maxBatchSize: 300,
            }),
        };
    }
    /**
     * Clear all cached responses from metadata, currency, and NFT chain information loaders
     */
    clearCache() {
        Object.values(this.loaders).forEach((loader) => loader.clearAll());
    }
    /**
     * Gets information of currencies and trading prices from uniswap
     * @param currencies list of currency contract ids on ethereum
     * @returns Promise<CurrencyLookupType>
     */
    async loadCurrencies(currencies) {
        const results = await this.loaders.currencyLoader.loadMany(currencies);
        return results.reduce((last, result) => {
            if (!(result instanceof Error)) {
                last[result.token.id] = result;
            }
            return last;
        }, {});
    }
    /**
     * Fetch NFT content or retun URI if content shouild not be fetched
     * @param url NFT Content URL
     * @param contentType string mime type to fetch
     * @returns Promise<MediaContentType> Media content information or URL
     */
    async fetchContent(url, contentType) {
        if (contentType.startsWith('text/')) {
            try {
                const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS).fetch(UriUtils_1.convertURIToHTTPS(url));
                return {
                    text: await response.text(),
                    type: 'text',
                    mimeType: contentType,
                };
            }
            catch (e) {
                throw new RequestError_1.RequestError('Issue fetching IPFS data', e);
            }
        }
        return { uri: url, type: 'uri', mimeType: contentType };
    }
    /**
     * Fetch Content MIME type from content URI
     *
     * @param url IPFS Content URI
     * @returns mime type as a string
     * @throws RequestError
     */
    async fetchContentMimeType(url) {
        const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS).fetch(UriUtils_1.convertURIToHTTPS(url), {
            method: 'HEAD',
        });
        const header = response.headers.get('content-type');
        if (!header) {
            throw new RequestError_1.RequestError('No content type returned for URI');
        }
        return header;
    }
    /**
     * Un-batched fetch function to fetch a group of ZNFT data
     *
     * @param ids list of ids to query
     * @param type type of ids: creator, id (of media), owner
     * @returns
     */
    async fetchZNFTGroupData(ids, type) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);
        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        const getQuery = () => {
            let base = {
                id_ids: [],
                creator_ids: [],
                owner_ids: [],
            };
            const idsNormalized = ids.map((id) => id.toLowerCase());
            switch (type) {
                case 'id':
                    base.id_ids = idsNormalized;
                    break;
                case 'creator':
                    base.creator_ids = idsNormalized;
                    break;
                case 'owner':
                    base.owner_ids = idsNormalized;
                    break;
            }
            return base;
        };
        const response = (await client.request(zora_graph_1.GET_MEDIAS_QUERY, getQuery));
        const medias = [...response.creator, ...response.owner, ...response.id];
        return medias.map((media) => TransformFetchResults_1.transformMediaItem(media, this.networkId));
    }
    async loadEnsBatch(addresses) {
        const addressToNames = await EnsReverseFetcher_1.reverseResolveEnsAddresses(addresses, this.networkId, this.timeouts.Rpc);
        return addresses.map((address) => addressToNames[address] || Error('Not found'));
    }
    // Alpha: uses zora indexer
    // format CONTRACT_ID-TOKEN_ID
    async fetchZoraNFTIndexerNFTs(keys) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.ZoraIndexer);
        const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        const response = await client.request(zora_indexer_1.BY_IDS, {
            ids: keys,
        });
        return keys.map((key) => response.Token.find((token) => token.id === key) || new ErrorUtils_1.NotFoundError('Did not find token'));
    }
    async loadZoraNFTIndexerNFTUntransformed(contractAddress, tokenId) {
        return this.loaders.zoraNFTIndexerLoader.load(`${address_1.getAddress(contractAddress)}-${tokenId}`);
    }
    async loadZoraNFTIndexerNFTsUntransformed(tokenAndIds) {
        return this.loaders.zoraNFTIndexerLoader.loadMany(tokenAndIds);
    }
    /**
     * Un-batched fetch function to fetch a group of NFT data from the zora indexer
     *
     * @param collectionAddresses list of collections to include
     * @param curatorAddress curator to query
     * @param approved boolean if the auction is approved (null for approved and un-approved auctions)
     */
    async fetchZoraIndexerGroupData({ collectionAddresses, curatorAddress, approved = null, onlyAuctions = false, limit = 200, offset = 0, }) {
        if (!(collectionAddresses === null || collectionAddresses === void 0 ? void 0 : collectionAddresses.length) && !curatorAddress) {
            throw new ErrorUtils_1.ArgumentsError('Needs to have at least one curator or collector');
        }
        if (!onlyAuctions && approved !== null) {
            throw new ErrorUtils_1.ArgumentsError('approved=true or approved=false and onlyAuctions=false cannot be set at the same time for fetchZoraIndexerGroupData');
        }
        let queryStatement = [];
        if (collectionAddresses) {
            const addresses = collectionAddresses.map((address) => address_1.getAddress(address));
            queryStatement.push({ address: { _in: addresses } });
        }
        let approvedStatement = undefined;
        if (approved !== null) {
            approvedStatement = { approved: { _eq: approved } };
        }
        if (curatorAddress) {
            queryStatement.push({
                auctions: { curator: { _eq: curatorAddress }, ...approvedStatement },
            });
        }
        else if (approvedStatement || onlyAuctions) {
            let auctionsQueryStmt = {};
            if (onlyAuctions) {
                auctionsQueryStmt = { _not: {} };
            }
            queryStatement.push({ auctions: { ...auctionsQueryStmt, ...approvedStatement } });
        }
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.ZoraIndexer);
        const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        return (await client.request(zora_indexer_1.ACTIVE_AUCTIONS_QUERY, {
            andQuery: queryStatement,
            offset,
            limit,
        })).Token;
    }
    /**
     * Un-batched fetch function to fetch a group of NFT data from the zora indexer
     *
     * @param collectionAddresses list of addresses for collection
     * @param userAddress address of user
     * @param type type of ids: creator, id (of media), owner
     * @returns
     */
    async fetchZoraIndexerUserOwnedNFTs({ collectionAddresses, userAddress, offset = 0, limit = 250, }) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.ZoraIndexer);
        const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        let addressQueryPart = {};
        if (collectionAddresses === null || collectionAddresses === void 0 ? void 0 : collectionAddresses.length) {
            addressQueryPart['_in'] = collectionAddresses.map(address_1.getAddress);
        }
        const response = await client.request(zora_indexer_1.BY_OWNER, {
            addressQueryPart,
            owner: address_1.getAddress(userAddress),
            offset,
            limit,
        });
        return response.Token;
    }
    /**
     * Get on-chain ZORA NFT ID associated media information
     *
     * @param mediaId ZORA NFT id to retrieve information of
     * @returns Promise<NFTDataType> On-chain NFT data
     */
    async loadZNFTData(mediaId, currencyInfos = {}) {
        const chainInfo = await this.loaders.mediaLoader.load(mediaId);
        if (!chainInfo) {
            throw new RequestError_1.RequestError('Cannot fetch chain information');
        }
        return {
            ...chainInfo,
            pricing: TransformFetchResults_1.addAuctionInformation(chainInfo.pricing, currencyInfos),
        };
    }
    async loadNFTData(contractAddress, tokenId, auctionData, currencyData) {
        const contractAndToken = `${contractAddress.toLowerCase()}:${tokenId}`;
        const nftInfo = await this.loaders.genericNFTLoader.load(contractAndToken);
        if (!auctionData) {
            try {
                auctionData = await this.loadAuctionInfo(contractAddress, tokenId);
            }
            catch (err) {
                if (!(err instanceof ErrorUtils_1.NotFoundError)) {
                    // Log any not-found error
                    console.error(err);
                }
            }
        }
        if (!nftInfo) {
            throw new RequestError_1.RequestError('Cannot fetch NFT information');
        }
        return OpenseaUtils_1.transformOpenseaResponse(nftInfo, auctionData, currencyData);
    }
    async loadNFTDataUntransformed(contractAddress, tokenId) {
        const contractAndToken = `${contractAddress.toLowerCase()}:${tokenId}`;
        const nftInfo = await this.loaders.genericNFTLoader.load(contractAndToken);
        if (!nftInfo) {
            throw new RequestError_1.RequestError('Cannot fetch NFT information');
        }
        return nftInfo;
    }
    async loadZNFTDataUntransformed(mediaId) {
        return await this.loaders.mediaLoader.load(mediaId);
    }
    async loadAuctionInfo(tokenContract, tokenId) {
        return await this.loaders.auctionInfoLoader.load([tokenContract.toLowerCase(), tokenId].join('-'));
    }
    // use dash between lowercase contract id and token id
    async loadAuctionInfos(tokenContractAndIds) {
        return await this.loaders.auctionInfoLoader.loadMany(tokenContractAndIds);
    }
    /**
     *
     * @param address string address of username to load
     * @returns
     */
    async loadUsername(address) {
        return this.loaders.usernameLoader.load(address.toLowerCase());
    }
    async loadEnsName(address) {
        return this.loaders.ensLoader.load(address.toLowerCase());
    }
    /**
     * Fetch function to retrieve Graph data for matching curated auctions
     * This function is not cached
     *
     * @function fetchReserveAuctions
     * @private
     * @param curatorIds list of Zora NFT IDs to fetch from the graph datastore
     * @returns mapped transformed list of curated auction results
     */
    async fetchReserveAuctions(curatorIds, isApproved = null, first = 1000, skip = 0) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);
        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        let query = zora_graph_1.GET_ALL_AUCTIONS;
        if (curatorIds.length) {
            query = zora_graph_1.GET_AUCTION_BY_CURATOR;
        }
        const response = (await client.request(query, {
            curators: curatorIds.length ? curatorIds : undefined,
            first: first,
            skip: skip,
            approved: isApproved === null ? [true, false] : [isApproved],
        }));
        return response.reserveAuctions;
    }
    async fetchAuctionNFTInfo(tokenAndAddresses) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);
        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        const response = (await client.request(zora_graph_1.GET_AUCTION_BY_MEDIA, {
            tokens: tokenAndAddresses.map((tokenAndAddress) => tokenAndAddress.toLowerCase()),
        }));
        if (!response.reserveAuctions) {
            throw new RequestError_1.RequestError('Missing auction in reponse');
        }
        return tokenAndAddresses.map((tokenAndAddress) => response.reserveAuctions.find((auction) => auction.token === tokenAndAddress) ||
            new ErrorUtils_1.NotFoundError('Missing Auction'));
    }
    /**
     * Internal fetch current auctions by curator
     *
     * @function fetchMediaGraph
     * @private
     * @param mediaIds list of Zora NFT IDs to fetch from the graph datastore
     * @returns mapped transformed list of zora NFT ID data
     */
    async fetchMediaGraph(mediaIds) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);
        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        const response = (await client.request(zora_graph_1.GET_MEDIAS_QUERY, {
            id_ids: mediaIds,
            creator_ids: [],
            owner_ids: [],
        }));
        return mediaIds.map((key) => TransformFetchResults_1.transformMediaForKey(response, key, this.networkId));
    }
    /**
     * Fetches generic NFT information
     *
     * @param nftAddresses list of addresses in a 0xcontractid:tokenid format
     * @returns
     */
    async fetchGenericNFT(nftAddresses) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.OpenSea);
        const apiBase = urls_1.OPENSEA_API_URL_BY_NETWORK[this.networkId];
        const urlParams = [];
        nftAddresses
            .map((address) => address.split(':'))
            .forEach(([address, tokenId]) => {
            urlParams.push(`token_ids=${tokenId}&asset_contract_addresses=${address}`);
        });
        const response = await fetchWithTimeout.fetch(`${apiBase}assets?${urlParams.join('&')}&order_direction=desc&offset=0&limit=50`);
        const responseJson = await response.json();
        return nftAddresses.map((nftAddress) => OpenseaUtils_1.transformGenericNFTForKey(responseJson.assets, nftAddress));
    }
    /**
     * Fetches zora username information from blockchain addresses for displaying user
     * information.
     *
     * @param addresses string list of addresses to map to Zora usernames
     * @returns list of UsernameResponseType - all fields are optional except address
     */
    async fetchZoraUsernames(addresses) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Zora);
        const response = await fetchWithTimeout.fetch(urls_1.ZORA_USERNAME_API_URL, {
            method: 'POST',
            type: 'cors',
            headers: {
                'content-type': 'application/json',
            },
            body: JSON.stringify({ addresses }),
        });
        const usernames = (await response.json());
        return addresses.map((address) => {
            const foundUsername = usernames.find((username) => username.address.toLowerCase() === address);
            if (foundUsername) {
                return foundUsername;
            }
            return { address };
        });
    }
    /**
     * Internal fetch function to retrieve currency information from TheGraph
     *
     * @function fetchCurrenciesGraph
     * @private
     * @param currencyContracts list of Ethereum addresses of currency contract data to retrieve
     * @returns mapped transformed list of ETH currency mapping data
     */
    async fetchCurrenciesGraph(currencyContracts) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);
        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_UNISWAP_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        const currencies = (await client.request(uniswap_1.GET_TOKEN_VALUES_QUERY, {
            currencyContracts: currencyContracts.filter((contract) => contract !== TransformFetchResults_1.NULL_ETH_CURRENCY_ID),
        }));
        return currencyContracts.map((key) => TransformFetchResults_1.transformCurrencyForKey(currencies, key));
    }
    /**
     * Fetch method to query metadata from IPFS. Not cached
     *
     * @function fetchIPFSMetadataCached
     * @public
     * @param url Metadata Source
     * @returns IPFS Metadata Fetch
     * @throws RequestError
     */
    async fetchIPFSMetadata(url) {
        // TODO(iain): Properly parse metadata from `ourzora/media-metadata-schemas`
        const request = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS, 'application/json').fetch(UriUtils_1.convertURIToHTTPS(url));
        try {
            return await request.json();
        }
        catch (e) {
            throw new RequestError_1.RequestError('Cannot read JSON metadata from IPFS', e);
        }
    }
}
exports.MediaFetchAgent = MediaFetchAgent;
