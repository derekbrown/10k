export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    BigDecimal: any;
    BigInt: any;
    Bytes: any;
};
export declare type AbiChanged = ResolverEvent & {
    __typename?: 'AbiChanged';
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    contentType: Scalars['BigInt'];
};
export declare type AbiChanged_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    contentType?: Maybe<Scalars['BigInt']>;
    contentType_not?: Maybe<Scalars['BigInt']>;
    contentType_gt?: Maybe<Scalars['BigInt']>;
    contentType_lt?: Maybe<Scalars['BigInt']>;
    contentType_gte?: Maybe<Scalars['BigInt']>;
    contentType_lte?: Maybe<Scalars['BigInt']>;
    contentType_in?: Maybe<Array<Scalars['BigInt']>>;
    contentType_not_in?: Maybe<Array<Scalars['BigInt']>>;
};
export declare enum AbiChanged_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    ContentType = "contentType"
}
export declare type Account = {
    __typename?: 'Account';
    id: Scalars['ID'];
    domains: Array<Domain>;
    registrations?: Maybe<Array<Registration>>;
};
export declare type AccountDomainsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Domain_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Domain_Filter>;
};
export declare type AccountRegistrationsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Registration_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Registration_Filter>;
};
export declare type Account_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
};
export declare enum Account_OrderBy {
    Id = "id",
    Domains = "domains",
    Registrations = "registrations"
}
export declare type AddrChanged = ResolverEvent & {
    __typename?: 'AddrChanged';
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    addr: Account;
};
export declare type AddrChanged_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    addr?: Maybe<Scalars['String']>;
    addr_not?: Maybe<Scalars['String']>;
    addr_gt?: Maybe<Scalars['String']>;
    addr_lt?: Maybe<Scalars['String']>;
    addr_gte?: Maybe<Scalars['String']>;
    addr_lte?: Maybe<Scalars['String']>;
    addr_in?: Maybe<Array<Scalars['String']>>;
    addr_not_in?: Maybe<Array<Scalars['String']>>;
    addr_contains?: Maybe<Scalars['String']>;
    addr_not_contains?: Maybe<Scalars['String']>;
    addr_starts_with?: Maybe<Scalars['String']>;
    addr_not_starts_with?: Maybe<Scalars['String']>;
    addr_ends_with?: Maybe<Scalars['String']>;
    addr_not_ends_with?: Maybe<Scalars['String']>;
};
export declare enum AddrChanged_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Addr = "addr"
}
export declare type AuthorisationChanged = ResolverEvent & {
    __typename?: 'AuthorisationChanged';
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    owner: Scalars['Bytes'];
    target: Scalars['Bytes'];
    isAuthorized: Scalars['Boolean'];
};
export declare type AuthorisationChanged_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    owner?: Maybe<Scalars['Bytes']>;
    owner_not?: Maybe<Scalars['Bytes']>;
    owner_in?: Maybe<Array<Scalars['Bytes']>>;
    owner_not_in?: Maybe<Array<Scalars['Bytes']>>;
    owner_contains?: Maybe<Scalars['Bytes']>;
    owner_not_contains?: Maybe<Scalars['Bytes']>;
    target?: Maybe<Scalars['Bytes']>;
    target_not?: Maybe<Scalars['Bytes']>;
    target_in?: Maybe<Array<Scalars['Bytes']>>;
    target_not_in?: Maybe<Array<Scalars['Bytes']>>;
    target_contains?: Maybe<Scalars['Bytes']>;
    target_not_contains?: Maybe<Scalars['Bytes']>;
    isAuthorized?: Maybe<Scalars['Boolean']>;
    isAuthorized_not?: Maybe<Scalars['Boolean']>;
    isAuthorized_in?: Maybe<Array<Scalars['Boolean']>>;
    isAuthorized_not_in?: Maybe<Array<Scalars['Boolean']>>;
};
export declare enum AuthorisationChanged_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Owner = "owner",
    Target = "target",
    IsAuthorized = "isAuthorized"
}
export declare type Block_Height = {
    hash?: Maybe<Scalars['Bytes']>;
    number?: Maybe<Scalars['Int']>;
};
export declare type ContenthashChanged = ResolverEvent & {
    __typename?: 'ContenthashChanged';
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    hash: Scalars['Bytes'];
};
export declare type ContenthashChanged_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    hash?: Maybe<Scalars['Bytes']>;
    hash_not?: Maybe<Scalars['Bytes']>;
    hash_in?: Maybe<Array<Scalars['Bytes']>>;
    hash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    hash_contains?: Maybe<Scalars['Bytes']>;
    hash_not_contains?: Maybe<Scalars['Bytes']>;
};
export declare enum ContenthashChanged_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Hash = "hash"
}
export declare type Domain = {
    __typename?: 'Domain';
    id: Scalars['ID'];
    name?: Maybe<Scalars['String']>;
    labelName?: Maybe<Scalars['String']>;
    labelhash?: Maybe<Scalars['Bytes']>;
    parent?: Maybe<Domain>;
    subdomains: Array<Domain>;
    resolvedAddress?: Maybe<Account>;
    owner: Account;
    resolver?: Maybe<Resolver>;
    ttl?: Maybe<Scalars['BigInt']>;
    isMigrated: Scalars['Boolean'];
    events: Array<DomainEvent>;
};
export declare type DomainSubdomainsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Domain_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Domain_Filter>;
};
export declare type DomainEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<DomainEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<DomainEvent_Filter>;
};
export declare type DomainEvent = {
    id: Scalars['ID'];
    domain: Domain;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
};
export declare type DomainEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    domain?: Maybe<Scalars['String']>;
    domain_not?: Maybe<Scalars['String']>;
    domain_gt?: Maybe<Scalars['String']>;
    domain_lt?: Maybe<Scalars['String']>;
    domain_gte?: Maybe<Scalars['String']>;
    domain_lte?: Maybe<Scalars['String']>;
    domain_in?: Maybe<Array<Scalars['String']>>;
    domain_not_in?: Maybe<Array<Scalars['String']>>;
    domain_contains?: Maybe<Scalars['String']>;
    domain_not_contains?: Maybe<Scalars['String']>;
    domain_starts_with?: Maybe<Scalars['String']>;
    domain_not_starts_with?: Maybe<Scalars['String']>;
    domain_ends_with?: Maybe<Scalars['String']>;
    domain_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
};
export declare enum DomainEvent_OrderBy {
    Id = "id",
    Domain = "domain",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID"
}
export declare type Domain_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
    labelName?: Maybe<Scalars['String']>;
    labelName_not?: Maybe<Scalars['String']>;
    labelName_gt?: Maybe<Scalars['String']>;
    labelName_lt?: Maybe<Scalars['String']>;
    labelName_gte?: Maybe<Scalars['String']>;
    labelName_lte?: Maybe<Scalars['String']>;
    labelName_in?: Maybe<Array<Scalars['String']>>;
    labelName_not_in?: Maybe<Array<Scalars['String']>>;
    labelName_contains?: Maybe<Scalars['String']>;
    labelName_not_contains?: Maybe<Scalars['String']>;
    labelName_starts_with?: Maybe<Scalars['String']>;
    labelName_not_starts_with?: Maybe<Scalars['String']>;
    labelName_ends_with?: Maybe<Scalars['String']>;
    labelName_not_ends_with?: Maybe<Scalars['String']>;
    labelhash?: Maybe<Scalars['Bytes']>;
    labelhash_not?: Maybe<Scalars['Bytes']>;
    labelhash_in?: Maybe<Array<Scalars['Bytes']>>;
    labelhash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    labelhash_contains?: Maybe<Scalars['Bytes']>;
    labelhash_not_contains?: Maybe<Scalars['Bytes']>;
    parent?: Maybe<Scalars['String']>;
    parent_not?: Maybe<Scalars['String']>;
    parent_gt?: Maybe<Scalars['String']>;
    parent_lt?: Maybe<Scalars['String']>;
    parent_gte?: Maybe<Scalars['String']>;
    parent_lte?: Maybe<Scalars['String']>;
    parent_in?: Maybe<Array<Scalars['String']>>;
    parent_not_in?: Maybe<Array<Scalars['String']>>;
    parent_contains?: Maybe<Scalars['String']>;
    parent_not_contains?: Maybe<Scalars['String']>;
    parent_starts_with?: Maybe<Scalars['String']>;
    parent_not_starts_with?: Maybe<Scalars['String']>;
    parent_ends_with?: Maybe<Scalars['String']>;
    parent_not_ends_with?: Maybe<Scalars['String']>;
    resolvedAddress?: Maybe<Scalars['String']>;
    resolvedAddress_not?: Maybe<Scalars['String']>;
    resolvedAddress_gt?: Maybe<Scalars['String']>;
    resolvedAddress_lt?: Maybe<Scalars['String']>;
    resolvedAddress_gte?: Maybe<Scalars['String']>;
    resolvedAddress_lte?: Maybe<Scalars['String']>;
    resolvedAddress_in?: Maybe<Array<Scalars['String']>>;
    resolvedAddress_not_in?: Maybe<Array<Scalars['String']>>;
    resolvedAddress_contains?: Maybe<Scalars['String']>;
    resolvedAddress_not_contains?: Maybe<Scalars['String']>;
    resolvedAddress_starts_with?: Maybe<Scalars['String']>;
    resolvedAddress_not_starts_with?: Maybe<Scalars['String']>;
    resolvedAddress_ends_with?: Maybe<Scalars['String']>;
    resolvedAddress_not_ends_with?: Maybe<Scalars['String']>;
    owner?: Maybe<Scalars['String']>;
    owner_not?: Maybe<Scalars['String']>;
    owner_gt?: Maybe<Scalars['String']>;
    owner_lt?: Maybe<Scalars['String']>;
    owner_gte?: Maybe<Scalars['String']>;
    owner_lte?: Maybe<Scalars['String']>;
    owner_in?: Maybe<Array<Scalars['String']>>;
    owner_not_in?: Maybe<Array<Scalars['String']>>;
    owner_contains?: Maybe<Scalars['String']>;
    owner_not_contains?: Maybe<Scalars['String']>;
    owner_starts_with?: Maybe<Scalars['String']>;
    owner_not_starts_with?: Maybe<Scalars['String']>;
    owner_ends_with?: Maybe<Scalars['String']>;
    owner_not_ends_with?: Maybe<Scalars['String']>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    ttl?: Maybe<Scalars['BigInt']>;
    ttl_not?: Maybe<Scalars['BigInt']>;
    ttl_gt?: Maybe<Scalars['BigInt']>;
    ttl_lt?: Maybe<Scalars['BigInt']>;
    ttl_gte?: Maybe<Scalars['BigInt']>;
    ttl_lte?: Maybe<Scalars['BigInt']>;
    ttl_in?: Maybe<Array<Scalars['BigInt']>>;
    ttl_not_in?: Maybe<Array<Scalars['BigInt']>>;
    isMigrated?: Maybe<Scalars['Boolean']>;
    isMigrated_not?: Maybe<Scalars['Boolean']>;
    isMigrated_in?: Maybe<Array<Scalars['Boolean']>>;
    isMigrated_not_in?: Maybe<Array<Scalars['Boolean']>>;
};
export declare enum Domain_OrderBy {
    Id = "id",
    Name = "name",
    LabelName = "labelName",
    Labelhash = "labelhash",
    Parent = "parent",
    Subdomains = "subdomains",
    ResolvedAddress = "resolvedAddress",
    Owner = "owner",
    Resolver = "resolver",
    Ttl = "ttl",
    IsMigrated = "isMigrated",
    Events = "events"
}
export declare type InterfaceChanged = ResolverEvent & {
    __typename?: 'InterfaceChanged';
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    interfaceID: Scalars['Bytes'];
    implementer: Scalars['Bytes'];
};
export declare type InterfaceChanged_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    interfaceID?: Maybe<Scalars['Bytes']>;
    interfaceID_not?: Maybe<Scalars['Bytes']>;
    interfaceID_in?: Maybe<Array<Scalars['Bytes']>>;
    interfaceID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    interfaceID_contains?: Maybe<Scalars['Bytes']>;
    interfaceID_not_contains?: Maybe<Scalars['Bytes']>;
    implementer?: Maybe<Scalars['Bytes']>;
    implementer_not?: Maybe<Scalars['Bytes']>;
    implementer_in?: Maybe<Array<Scalars['Bytes']>>;
    implementer_not_in?: Maybe<Array<Scalars['Bytes']>>;
    implementer_contains?: Maybe<Scalars['Bytes']>;
    implementer_not_contains?: Maybe<Scalars['Bytes']>;
};
export declare enum InterfaceChanged_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    InterfaceId = "interfaceID",
    Implementer = "implementer"
}
export declare type MulticoinAddrChanged = ResolverEvent & {
    __typename?: 'MulticoinAddrChanged';
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    coinType: Scalars['Int'];
    addr: Scalars['Bytes'];
};
export declare type MulticoinAddrChanged_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    coinType?: Maybe<Scalars['Int']>;
    coinType_not?: Maybe<Scalars['Int']>;
    coinType_gt?: Maybe<Scalars['Int']>;
    coinType_lt?: Maybe<Scalars['Int']>;
    coinType_gte?: Maybe<Scalars['Int']>;
    coinType_lte?: Maybe<Scalars['Int']>;
    coinType_in?: Maybe<Array<Scalars['Int']>>;
    coinType_not_in?: Maybe<Array<Scalars['Int']>>;
    addr?: Maybe<Scalars['Bytes']>;
    addr_not?: Maybe<Scalars['Bytes']>;
    addr_in?: Maybe<Array<Scalars['Bytes']>>;
    addr_not_in?: Maybe<Array<Scalars['Bytes']>>;
    addr_contains?: Maybe<Scalars['Bytes']>;
    addr_not_contains?: Maybe<Scalars['Bytes']>;
};
export declare enum MulticoinAddrChanged_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    CoinType = "coinType",
    Addr = "addr"
}
export declare type NameChanged = ResolverEvent & {
    __typename?: 'NameChanged';
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    name: Scalars['String'];
};
export declare type NameChanged_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    name?: Maybe<Scalars['String']>;
    name_not?: Maybe<Scalars['String']>;
    name_gt?: Maybe<Scalars['String']>;
    name_lt?: Maybe<Scalars['String']>;
    name_gte?: Maybe<Scalars['String']>;
    name_lte?: Maybe<Scalars['String']>;
    name_in?: Maybe<Array<Scalars['String']>>;
    name_not_in?: Maybe<Array<Scalars['String']>>;
    name_contains?: Maybe<Scalars['String']>;
    name_not_contains?: Maybe<Scalars['String']>;
    name_starts_with?: Maybe<Scalars['String']>;
    name_not_starts_with?: Maybe<Scalars['String']>;
    name_ends_with?: Maybe<Scalars['String']>;
    name_not_ends_with?: Maybe<Scalars['String']>;
};
export declare enum NameChanged_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Name = "name"
}
export declare type NameRegistered = RegistrationEvent & {
    __typename?: 'NameRegistered';
    id: Scalars['ID'];
    registration: Registration;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    registrant: Account;
    expiryDate: Scalars['BigInt'];
};
export declare type NameRegistered_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    registration?: Maybe<Scalars['String']>;
    registration_not?: Maybe<Scalars['String']>;
    registration_gt?: Maybe<Scalars['String']>;
    registration_lt?: Maybe<Scalars['String']>;
    registration_gte?: Maybe<Scalars['String']>;
    registration_lte?: Maybe<Scalars['String']>;
    registration_in?: Maybe<Array<Scalars['String']>>;
    registration_not_in?: Maybe<Array<Scalars['String']>>;
    registration_contains?: Maybe<Scalars['String']>;
    registration_not_contains?: Maybe<Scalars['String']>;
    registration_starts_with?: Maybe<Scalars['String']>;
    registration_not_starts_with?: Maybe<Scalars['String']>;
    registration_ends_with?: Maybe<Scalars['String']>;
    registration_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    registrant?: Maybe<Scalars['String']>;
    registrant_not?: Maybe<Scalars['String']>;
    registrant_gt?: Maybe<Scalars['String']>;
    registrant_lt?: Maybe<Scalars['String']>;
    registrant_gte?: Maybe<Scalars['String']>;
    registrant_lte?: Maybe<Scalars['String']>;
    registrant_in?: Maybe<Array<Scalars['String']>>;
    registrant_not_in?: Maybe<Array<Scalars['String']>>;
    registrant_contains?: Maybe<Scalars['String']>;
    registrant_not_contains?: Maybe<Scalars['String']>;
    registrant_starts_with?: Maybe<Scalars['String']>;
    registrant_not_starts_with?: Maybe<Scalars['String']>;
    registrant_ends_with?: Maybe<Scalars['String']>;
    registrant_not_ends_with?: Maybe<Scalars['String']>;
    expiryDate?: Maybe<Scalars['BigInt']>;
    expiryDate_not?: Maybe<Scalars['BigInt']>;
    expiryDate_gt?: Maybe<Scalars['BigInt']>;
    expiryDate_lt?: Maybe<Scalars['BigInt']>;
    expiryDate_gte?: Maybe<Scalars['BigInt']>;
    expiryDate_lte?: Maybe<Scalars['BigInt']>;
    expiryDate_in?: Maybe<Array<Scalars['BigInt']>>;
    expiryDate_not_in?: Maybe<Array<Scalars['BigInt']>>;
};
export declare enum NameRegistered_OrderBy {
    Id = "id",
    Registration = "registration",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Registrant = "registrant",
    ExpiryDate = "expiryDate"
}
export declare type NameRenewed = RegistrationEvent & {
    __typename?: 'NameRenewed';
    id: Scalars['ID'];
    registration: Registration;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    expiryDate: Scalars['BigInt'];
};
export declare type NameRenewed_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    registration?: Maybe<Scalars['String']>;
    registration_not?: Maybe<Scalars['String']>;
    registration_gt?: Maybe<Scalars['String']>;
    registration_lt?: Maybe<Scalars['String']>;
    registration_gte?: Maybe<Scalars['String']>;
    registration_lte?: Maybe<Scalars['String']>;
    registration_in?: Maybe<Array<Scalars['String']>>;
    registration_not_in?: Maybe<Array<Scalars['String']>>;
    registration_contains?: Maybe<Scalars['String']>;
    registration_not_contains?: Maybe<Scalars['String']>;
    registration_starts_with?: Maybe<Scalars['String']>;
    registration_not_starts_with?: Maybe<Scalars['String']>;
    registration_ends_with?: Maybe<Scalars['String']>;
    registration_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    expiryDate?: Maybe<Scalars['BigInt']>;
    expiryDate_not?: Maybe<Scalars['BigInt']>;
    expiryDate_gt?: Maybe<Scalars['BigInt']>;
    expiryDate_lt?: Maybe<Scalars['BigInt']>;
    expiryDate_gte?: Maybe<Scalars['BigInt']>;
    expiryDate_lte?: Maybe<Scalars['BigInt']>;
    expiryDate_in?: Maybe<Array<Scalars['BigInt']>>;
    expiryDate_not_in?: Maybe<Array<Scalars['BigInt']>>;
};
export declare enum NameRenewed_OrderBy {
    Id = "id",
    Registration = "registration",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    ExpiryDate = "expiryDate"
}
export declare type NameTransferred = RegistrationEvent & {
    __typename?: 'NameTransferred';
    id: Scalars['ID'];
    registration: Registration;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    newOwner: Account;
};
export declare type NameTransferred_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    registration?: Maybe<Scalars['String']>;
    registration_not?: Maybe<Scalars['String']>;
    registration_gt?: Maybe<Scalars['String']>;
    registration_lt?: Maybe<Scalars['String']>;
    registration_gte?: Maybe<Scalars['String']>;
    registration_lte?: Maybe<Scalars['String']>;
    registration_in?: Maybe<Array<Scalars['String']>>;
    registration_not_in?: Maybe<Array<Scalars['String']>>;
    registration_contains?: Maybe<Scalars['String']>;
    registration_not_contains?: Maybe<Scalars['String']>;
    registration_starts_with?: Maybe<Scalars['String']>;
    registration_not_starts_with?: Maybe<Scalars['String']>;
    registration_ends_with?: Maybe<Scalars['String']>;
    registration_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    newOwner?: Maybe<Scalars['String']>;
    newOwner_not?: Maybe<Scalars['String']>;
    newOwner_gt?: Maybe<Scalars['String']>;
    newOwner_lt?: Maybe<Scalars['String']>;
    newOwner_gte?: Maybe<Scalars['String']>;
    newOwner_lte?: Maybe<Scalars['String']>;
    newOwner_in?: Maybe<Array<Scalars['String']>>;
    newOwner_not_in?: Maybe<Array<Scalars['String']>>;
    newOwner_contains?: Maybe<Scalars['String']>;
    newOwner_not_contains?: Maybe<Scalars['String']>;
    newOwner_starts_with?: Maybe<Scalars['String']>;
    newOwner_not_starts_with?: Maybe<Scalars['String']>;
    newOwner_ends_with?: Maybe<Scalars['String']>;
    newOwner_not_ends_with?: Maybe<Scalars['String']>;
};
export declare enum NameTransferred_OrderBy {
    Id = "id",
    Registration = "registration",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    NewOwner = "newOwner"
}
export declare type NewOwner = DomainEvent & {
    __typename?: 'NewOwner';
    id: Scalars['ID'];
    domain: Domain;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    owner: Account;
};
export declare type NewOwner_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    domain?: Maybe<Scalars['String']>;
    domain_not?: Maybe<Scalars['String']>;
    domain_gt?: Maybe<Scalars['String']>;
    domain_lt?: Maybe<Scalars['String']>;
    domain_gte?: Maybe<Scalars['String']>;
    domain_lte?: Maybe<Scalars['String']>;
    domain_in?: Maybe<Array<Scalars['String']>>;
    domain_not_in?: Maybe<Array<Scalars['String']>>;
    domain_contains?: Maybe<Scalars['String']>;
    domain_not_contains?: Maybe<Scalars['String']>;
    domain_starts_with?: Maybe<Scalars['String']>;
    domain_not_starts_with?: Maybe<Scalars['String']>;
    domain_ends_with?: Maybe<Scalars['String']>;
    domain_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    owner?: Maybe<Scalars['String']>;
    owner_not?: Maybe<Scalars['String']>;
    owner_gt?: Maybe<Scalars['String']>;
    owner_lt?: Maybe<Scalars['String']>;
    owner_gte?: Maybe<Scalars['String']>;
    owner_lte?: Maybe<Scalars['String']>;
    owner_in?: Maybe<Array<Scalars['String']>>;
    owner_not_in?: Maybe<Array<Scalars['String']>>;
    owner_contains?: Maybe<Scalars['String']>;
    owner_not_contains?: Maybe<Scalars['String']>;
    owner_starts_with?: Maybe<Scalars['String']>;
    owner_not_starts_with?: Maybe<Scalars['String']>;
    owner_ends_with?: Maybe<Scalars['String']>;
    owner_not_ends_with?: Maybe<Scalars['String']>;
};
export declare enum NewOwner_OrderBy {
    Id = "id",
    Domain = "domain",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Owner = "owner"
}
export declare type NewResolver = DomainEvent & {
    __typename?: 'NewResolver';
    id: Scalars['ID'];
    domain: Domain;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    resolver: Resolver;
};
export declare type NewResolver_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    domain?: Maybe<Scalars['String']>;
    domain_not?: Maybe<Scalars['String']>;
    domain_gt?: Maybe<Scalars['String']>;
    domain_lt?: Maybe<Scalars['String']>;
    domain_gte?: Maybe<Scalars['String']>;
    domain_lte?: Maybe<Scalars['String']>;
    domain_in?: Maybe<Array<Scalars['String']>>;
    domain_not_in?: Maybe<Array<Scalars['String']>>;
    domain_contains?: Maybe<Scalars['String']>;
    domain_not_contains?: Maybe<Scalars['String']>;
    domain_starts_with?: Maybe<Scalars['String']>;
    domain_not_starts_with?: Maybe<Scalars['String']>;
    domain_ends_with?: Maybe<Scalars['String']>;
    domain_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
};
export declare enum NewResolver_OrderBy {
    Id = "id",
    Domain = "domain",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Resolver = "resolver"
}
export declare type NewTtl = DomainEvent & {
    __typename?: 'NewTTL';
    id: Scalars['ID'];
    domain: Domain;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    ttl: Scalars['BigInt'];
};
export declare type NewTtl_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    domain?: Maybe<Scalars['String']>;
    domain_not?: Maybe<Scalars['String']>;
    domain_gt?: Maybe<Scalars['String']>;
    domain_lt?: Maybe<Scalars['String']>;
    domain_gte?: Maybe<Scalars['String']>;
    domain_lte?: Maybe<Scalars['String']>;
    domain_in?: Maybe<Array<Scalars['String']>>;
    domain_not_in?: Maybe<Array<Scalars['String']>>;
    domain_contains?: Maybe<Scalars['String']>;
    domain_not_contains?: Maybe<Scalars['String']>;
    domain_starts_with?: Maybe<Scalars['String']>;
    domain_not_starts_with?: Maybe<Scalars['String']>;
    domain_ends_with?: Maybe<Scalars['String']>;
    domain_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    ttl?: Maybe<Scalars['BigInt']>;
    ttl_not?: Maybe<Scalars['BigInt']>;
    ttl_gt?: Maybe<Scalars['BigInt']>;
    ttl_lt?: Maybe<Scalars['BigInt']>;
    ttl_gte?: Maybe<Scalars['BigInt']>;
    ttl_lte?: Maybe<Scalars['BigInt']>;
    ttl_in?: Maybe<Array<Scalars['BigInt']>>;
    ttl_not_in?: Maybe<Array<Scalars['BigInt']>>;
};
export declare enum NewTtl_OrderBy {
    Id = "id",
    Domain = "domain",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Ttl = "ttl"
}
export declare enum OrderDirection {
    Asc = "asc",
    Desc = "desc"
}
export declare type PubkeyChanged = ResolverEvent & {
    __typename?: 'PubkeyChanged';
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    x: Scalars['Bytes'];
    y: Scalars['Bytes'];
};
export declare type PubkeyChanged_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    x?: Maybe<Scalars['Bytes']>;
    x_not?: Maybe<Scalars['Bytes']>;
    x_in?: Maybe<Array<Scalars['Bytes']>>;
    x_not_in?: Maybe<Array<Scalars['Bytes']>>;
    x_contains?: Maybe<Scalars['Bytes']>;
    x_not_contains?: Maybe<Scalars['Bytes']>;
    y?: Maybe<Scalars['Bytes']>;
    y_not?: Maybe<Scalars['Bytes']>;
    y_in?: Maybe<Array<Scalars['Bytes']>>;
    y_not_in?: Maybe<Array<Scalars['Bytes']>>;
    y_contains?: Maybe<Scalars['Bytes']>;
    y_not_contains?: Maybe<Scalars['Bytes']>;
};
export declare enum PubkeyChanged_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    X = "x",
    Y = "y"
}
export declare type Query = {
    __typename?: 'Query';
    domain?: Maybe<Domain>;
    domains: Array<Domain>;
    transfer?: Maybe<Transfer>;
    transfers: Array<Transfer>;
    newOwner?: Maybe<NewOwner>;
    newOwners: Array<NewOwner>;
    newResolver?: Maybe<NewResolver>;
    newResolvers: Array<NewResolver>;
    newTTL?: Maybe<NewTtl>;
    newTTLs: Array<NewTtl>;
    account?: Maybe<Account>;
    accounts: Array<Account>;
    registration?: Maybe<Registration>;
    registrations: Array<Registration>;
    nameRegistered?: Maybe<NameRegistered>;
    nameRegistereds: Array<NameRegistered>;
    nameRenewed?: Maybe<NameRenewed>;
    nameReneweds: Array<NameRenewed>;
    nameTransferred?: Maybe<NameTransferred>;
    nameTransferreds: Array<NameTransferred>;
    resolver?: Maybe<Resolver>;
    resolvers: Array<Resolver>;
    addrChanged?: Maybe<AddrChanged>;
    addrChangeds: Array<AddrChanged>;
    multicoinAddrChanged?: Maybe<MulticoinAddrChanged>;
    multicoinAddrChangeds: Array<MulticoinAddrChanged>;
    nameChanged?: Maybe<NameChanged>;
    nameChangeds: Array<NameChanged>;
    abiChanged?: Maybe<AbiChanged>;
    abiChangeds: Array<AbiChanged>;
    pubkeyChanged?: Maybe<PubkeyChanged>;
    pubkeyChangeds: Array<PubkeyChanged>;
    textChanged?: Maybe<TextChanged>;
    textChangeds: Array<TextChanged>;
    contenthashChanged?: Maybe<ContenthashChanged>;
    contenthashChangeds: Array<ContenthashChanged>;
    interfaceChanged?: Maybe<InterfaceChanged>;
    interfaceChangeds: Array<InterfaceChanged>;
    authorisationChanged?: Maybe<AuthorisationChanged>;
    authorisationChangeds: Array<AuthorisationChanged>;
    domainEvent?: Maybe<DomainEvent>;
    domainEvents: Array<DomainEvent>;
    registrationEvent?: Maybe<RegistrationEvent>;
    registrationEvents: Array<RegistrationEvent>;
    resolverEvent?: Maybe<ResolverEvent>;
    resolverEvents: Array<ResolverEvent>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export declare type QueryDomainArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryDomainsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Domain_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Domain_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTransferArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTransfersArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Transfer_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Transfer_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNewOwnerArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNewOwnersArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NewOwner_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NewOwner_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNewResolverArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNewResolversArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NewResolver_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NewResolver_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNewTtlArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNewTtLsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NewTtl_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NewTtl_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAccountArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAccountsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Account_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Account_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRegistrationArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRegistrationsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Registration_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Registration_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNameRegisteredArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNameRegisteredsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NameRegistered_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NameRegistered_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNameRenewedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNameRenewedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NameRenewed_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NameRenewed_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNameTransferredArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNameTransferredsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NameTransferred_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NameTransferred_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryResolverArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryResolversArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Resolver_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Resolver_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAddrChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAddrChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AddrChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AddrChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryMulticoinAddrChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryMulticoinAddrChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<MulticoinAddrChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<MulticoinAddrChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNameChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryNameChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NameChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NameChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAbiChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAbiChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AbiChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AbiChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryPubkeyChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryPubkeyChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<PubkeyChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<PubkeyChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTextChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryTextChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TextChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TextChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryContenthashChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryContenthashChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ContenthashChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ContenthashChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryInterfaceChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryInterfaceChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<InterfaceChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<InterfaceChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAuthorisationChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryAuthorisationChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AuthorisationChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AuthorisationChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryDomainEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryDomainEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<DomainEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<DomainEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRegistrationEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryRegistrationEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RegistrationEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RegistrationEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryResolverEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type QueryResolverEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ResolverEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ResolverEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type Query_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export declare type Registration = {
    __typename?: 'Registration';
    id: Scalars['ID'];
    domain?: Maybe<Domain>;
    registrationDate: Scalars['BigInt'];
    expiryDate: Scalars['BigInt'];
    registrant: Account;
    labelName?: Maybe<Scalars['String']>;
    events: Array<RegistrationEvent>;
};
export declare type RegistrationEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RegistrationEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RegistrationEvent_Filter>;
};
export declare type RegistrationEvent = {
    id: Scalars['ID'];
    registration: Registration;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
};
export declare type RegistrationEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    registration?: Maybe<Scalars['String']>;
    registration_not?: Maybe<Scalars['String']>;
    registration_gt?: Maybe<Scalars['String']>;
    registration_lt?: Maybe<Scalars['String']>;
    registration_gte?: Maybe<Scalars['String']>;
    registration_lte?: Maybe<Scalars['String']>;
    registration_in?: Maybe<Array<Scalars['String']>>;
    registration_not_in?: Maybe<Array<Scalars['String']>>;
    registration_contains?: Maybe<Scalars['String']>;
    registration_not_contains?: Maybe<Scalars['String']>;
    registration_starts_with?: Maybe<Scalars['String']>;
    registration_not_starts_with?: Maybe<Scalars['String']>;
    registration_ends_with?: Maybe<Scalars['String']>;
    registration_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
};
export declare enum RegistrationEvent_OrderBy {
    Id = "id",
    Registration = "registration",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID"
}
export declare type Registration_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    domain?: Maybe<Scalars['String']>;
    domain_not?: Maybe<Scalars['String']>;
    domain_gt?: Maybe<Scalars['String']>;
    domain_lt?: Maybe<Scalars['String']>;
    domain_gte?: Maybe<Scalars['String']>;
    domain_lte?: Maybe<Scalars['String']>;
    domain_in?: Maybe<Array<Scalars['String']>>;
    domain_not_in?: Maybe<Array<Scalars['String']>>;
    domain_contains?: Maybe<Scalars['String']>;
    domain_not_contains?: Maybe<Scalars['String']>;
    domain_starts_with?: Maybe<Scalars['String']>;
    domain_not_starts_with?: Maybe<Scalars['String']>;
    domain_ends_with?: Maybe<Scalars['String']>;
    domain_not_ends_with?: Maybe<Scalars['String']>;
    registrationDate?: Maybe<Scalars['BigInt']>;
    registrationDate_not?: Maybe<Scalars['BigInt']>;
    registrationDate_gt?: Maybe<Scalars['BigInt']>;
    registrationDate_lt?: Maybe<Scalars['BigInt']>;
    registrationDate_gte?: Maybe<Scalars['BigInt']>;
    registrationDate_lte?: Maybe<Scalars['BigInt']>;
    registrationDate_in?: Maybe<Array<Scalars['BigInt']>>;
    registrationDate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    expiryDate?: Maybe<Scalars['BigInt']>;
    expiryDate_not?: Maybe<Scalars['BigInt']>;
    expiryDate_gt?: Maybe<Scalars['BigInt']>;
    expiryDate_lt?: Maybe<Scalars['BigInt']>;
    expiryDate_gte?: Maybe<Scalars['BigInt']>;
    expiryDate_lte?: Maybe<Scalars['BigInt']>;
    expiryDate_in?: Maybe<Array<Scalars['BigInt']>>;
    expiryDate_not_in?: Maybe<Array<Scalars['BigInt']>>;
    registrant?: Maybe<Scalars['String']>;
    registrant_not?: Maybe<Scalars['String']>;
    registrant_gt?: Maybe<Scalars['String']>;
    registrant_lt?: Maybe<Scalars['String']>;
    registrant_gte?: Maybe<Scalars['String']>;
    registrant_lte?: Maybe<Scalars['String']>;
    registrant_in?: Maybe<Array<Scalars['String']>>;
    registrant_not_in?: Maybe<Array<Scalars['String']>>;
    registrant_contains?: Maybe<Scalars['String']>;
    registrant_not_contains?: Maybe<Scalars['String']>;
    registrant_starts_with?: Maybe<Scalars['String']>;
    registrant_not_starts_with?: Maybe<Scalars['String']>;
    registrant_ends_with?: Maybe<Scalars['String']>;
    registrant_not_ends_with?: Maybe<Scalars['String']>;
    labelName?: Maybe<Scalars['String']>;
    labelName_not?: Maybe<Scalars['String']>;
    labelName_gt?: Maybe<Scalars['String']>;
    labelName_lt?: Maybe<Scalars['String']>;
    labelName_gte?: Maybe<Scalars['String']>;
    labelName_lte?: Maybe<Scalars['String']>;
    labelName_in?: Maybe<Array<Scalars['String']>>;
    labelName_not_in?: Maybe<Array<Scalars['String']>>;
    labelName_contains?: Maybe<Scalars['String']>;
    labelName_not_contains?: Maybe<Scalars['String']>;
    labelName_starts_with?: Maybe<Scalars['String']>;
    labelName_not_starts_with?: Maybe<Scalars['String']>;
    labelName_ends_with?: Maybe<Scalars['String']>;
    labelName_not_ends_with?: Maybe<Scalars['String']>;
};
export declare enum Registration_OrderBy {
    Id = "id",
    Domain = "domain",
    RegistrationDate = "registrationDate",
    ExpiryDate = "expiryDate",
    Registrant = "registrant",
    LabelName = "labelName",
    Events = "events"
}
export declare type Resolver = {
    __typename?: 'Resolver';
    id: Scalars['ID'];
    domain?: Maybe<Domain>;
    address: Scalars['Bytes'];
    addr?: Maybe<Account>;
    contentHash?: Maybe<Scalars['Bytes']>;
    texts?: Maybe<Array<Scalars['String']>>;
    coinTypes?: Maybe<Array<Scalars['Int']>>;
    events: Array<ResolverEvent>;
};
export declare type ResolverEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ResolverEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ResolverEvent_Filter>;
};
export declare type ResolverEvent = {
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
};
export declare type ResolverEvent_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
};
export declare enum ResolverEvent_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID"
}
export declare type Resolver_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    domain?: Maybe<Scalars['String']>;
    domain_not?: Maybe<Scalars['String']>;
    domain_gt?: Maybe<Scalars['String']>;
    domain_lt?: Maybe<Scalars['String']>;
    domain_gte?: Maybe<Scalars['String']>;
    domain_lte?: Maybe<Scalars['String']>;
    domain_in?: Maybe<Array<Scalars['String']>>;
    domain_not_in?: Maybe<Array<Scalars['String']>>;
    domain_contains?: Maybe<Scalars['String']>;
    domain_not_contains?: Maybe<Scalars['String']>;
    domain_starts_with?: Maybe<Scalars['String']>;
    domain_not_starts_with?: Maybe<Scalars['String']>;
    domain_ends_with?: Maybe<Scalars['String']>;
    domain_not_ends_with?: Maybe<Scalars['String']>;
    address?: Maybe<Scalars['Bytes']>;
    address_not?: Maybe<Scalars['Bytes']>;
    address_in?: Maybe<Array<Scalars['Bytes']>>;
    address_not_in?: Maybe<Array<Scalars['Bytes']>>;
    address_contains?: Maybe<Scalars['Bytes']>;
    address_not_contains?: Maybe<Scalars['Bytes']>;
    addr?: Maybe<Scalars['String']>;
    addr_not?: Maybe<Scalars['String']>;
    addr_gt?: Maybe<Scalars['String']>;
    addr_lt?: Maybe<Scalars['String']>;
    addr_gte?: Maybe<Scalars['String']>;
    addr_lte?: Maybe<Scalars['String']>;
    addr_in?: Maybe<Array<Scalars['String']>>;
    addr_not_in?: Maybe<Array<Scalars['String']>>;
    addr_contains?: Maybe<Scalars['String']>;
    addr_not_contains?: Maybe<Scalars['String']>;
    addr_starts_with?: Maybe<Scalars['String']>;
    addr_not_starts_with?: Maybe<Scalars['String']>;
    addr_ends_with?: Maybe<Scalars['String']>;
    addr_not_ends_with?: Maybe<Scalars['String']>;
    contentHash?: Maybe<Scalars['Bytes']>;
    contentHash_not?: Maybe<Scalars['Bytes']>;
    contentHash_in?: Maybe<Array<Scalars['Bytes']>>;
    contentHash_not_in?: Maybe<Array<Scalars['Bytes']>>;
    contentHash_contains?: Maybe<Scalars['Bytes']>;
    contentHash_not_contains?: Maybe<Scalars['Bytes']>;
    texts?: Maybe<Array<Scalars['String']>>;
    texts_not?: Maybe<Array<Scalars['String']>>;
    texts_contains?: Maybe<Array<Scalars['String']>>;
    texts_not_contains?: Maybe<Array<Scalars['String']>>;
    coinTypes?: Maybe<Array<Scalars['Int']>>;
    coinTypes_not?: Maybe<Array<Scalars['Int']>>;
    coinTypes_contains?: Maybe<Array<Scalars['Int']>>;
    coinTypes_not_contains?: Maybe<Array<Scalars['Int']>>;
};
export declare enum Resolver_OrderBy {
    Id = "id",
    Domain = "domain",
    Address = "address",
    Addr = "addr",
    ContentHash = "contentHash",
    Texts = "texts",
    CoinTypes = "coinTypes",
    Events = "events"
}
export declare type Subscription = {
    __typename?: 'Subscription';
    domain?: Maybe<Domain>;
    domains: Array<Domain>;
    transfer?: Maybe<Transfer>;
    transfers: Array<Transfer>;
    newOwner?: Maybe<NewOwner>;
    newOwners: Array<NewOwner>;
    newResolver?: Maybe<NewResolver>;
    newResolvers: Array<NewResolver>;
    newTTL?: Maybe<NewTtl>;
    newTTLs: Array<NewTtl>;
    account?: Maybe<Account>;
    accounts: Array<Account>;
    registration?: Maybe<Registration>;
    registrations: Array<Registration>;
    nameRegistered?: Maybe<NameRegistered>;
    nameRegistereds: Array<NameRegistered>;
    nameRenewed?: Maybe<NameRenewed>;
    nameReneweds: Array<NameRenewed>;
    nameTransferred?: Maybe<NameTransferred>;
    nameTransferreds: Array<NameTransferred>;
    resolver?: Maybe<Resolver>;
    resolvers: Array<Resolver>;
    addrChanged?: Maybe<AddrChanged>;
    addrChangeds: Array<AddrChanged>;
    multicoinAddrChanged?: Maybe<MulticoinAddrChanged>;
    multicoinAddrChangeds: Array<MulticoinAddrChanged>;
    nameChanged?: Maybe<NameChanged>;
    nameChangeds: Array<NameChanged>;
    abiChanged?: Maybe<AbiChanged>;
    abiChangeds: Array<AbiChanged>;
    pubkeyChanged?: Maybe<PubkeyChanged>;
    pubkeyChangeds: Array<PubkeyChanged>;
    textChanged?: Maybe<TextChanged>;
    textChangeds: Array<TextChanged>;
    contenthashChanged?: Maybe<ContenthashChanged>;
    contenthashChangeds: Array<ContenthashChanged>;
    interfaceChanged?: Maybe<InterfaceChanged>;
    interfaceChangeds: Array<InterfaceChanged>;
    authorisationChanged?: Maybe<AuthorisationChanged>;
    authorisationChangeds: Array<AuthorisationChanged>;
    domainEvent?: Maybe<DomainEvent>;
    domainEvents: Array<DomainEvent>;
    registrationEvent?: Maybe<RegistrationEvent>;
    registrationEvents: Array<RegistrationEvent>;
    resolverEvent?: Maybe<ResolverEvent>;
    resolverEvents: Array<ResolverEvent>;
    /** Access to subgraph metadata */
    _meta?: Maybe<_Meta_>;
};
export declare type SubscriptionDomainArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionDomainsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Domain_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Domain_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTransferArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTransfersArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Transfer_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Transfer_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNewOwnerArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNewOwnersArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NewOwner_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NewOwner_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNewResolverArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNewResolversArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NewResolver_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NewResolver_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNewTtlArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNewTtLsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NewTtl_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NewTtl_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAccountArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAccountsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Account_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Account_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRegistrationArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRegistrationsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Registration_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Registration_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNameRegisteredArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNameRegisteredsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NameRegistered_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NameRegistered_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNameRenewedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNameRenewedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NameRenewed_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NameRenewed_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNameTransferredArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNameTransferredsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NameTransferred_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NameTransferred_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionResolverArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionResolversArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<Resolver_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<Resolver_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAddrChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAddrChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AddrChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AddrChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionMulticoinAddrChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionMulticoinAddrChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<MulticoinAddrChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<MulticoinAddrChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNameChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionNameChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<NameChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<NameChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAbiChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAbiChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AbiChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AbiChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionPubkeyChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionPubkeyChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<PubkeyChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<PubkeyChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTextChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionTextChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<TextChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<TextChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionContenthashChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionContenthashChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ContenthashChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ContenthashChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionInterfaceChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionInterfaceChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<InterfaceChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<InterfaceChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAuthorisationChangedArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionAuthorisationChangedsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<AuthorisationChanged_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<AuthorisationChanged_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionDomainEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionDomainEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<DomainEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<DomainEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRegistrationEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionRegistrationEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<RegistrationEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<RegistrationEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionResolverEventArgs = {
    id: Scalars['ID'];
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type SubscriptionResolverEventsArgs = {
    skip?: Maybe<Scalars['Int']>;
    first?: Maybe<Scalars['Int']>;
    orderBy?: Maybe<ResolverEvent_OrderBy>;
    orderDirection?: Maybe<OrderDirection>;
    where?: Maybe<ResolverEvent_Filter>;
    block?: Maybe<Block_Height>;
    subgraphError?: _SubgraphErrorPolicy_;
};
export declare type Subscription_MetaArgs = {
    block?: Maybe<Block_Height>;
};
export declare type TextChanged = ResolverEvent & {
    __typename?: 'TextChanged';
    id: Scalars['ID'];
    resolver: Resolver;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    key: Scalars['String'];
};
export declare type TextChanged_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    resolver?: Maybe<Scalars['String']>;
    resolver_not?: Maybe<Scalars['String']>;
    resolver_gt?: Maybe<Scalars['String']>;
    resolver_lt?: Maybe<Scalars['String']>;
    resolver_gte?: Maybe<Scalars['String']>;
    resolver_lte?: Maybe<Scalars['String']>;
    resolver_in?: Maybe<Array<Scalars['String']>>;
    resolver_not_in?: Maybe<Array<Scalars['String']>>;
    resolver_contains?: Maybe<Scalars['String']>;
    resolver_not_contains?: Maybe<Scalars['String']>;
    resolver_starts_with?: Maybe<Scalars['String']>;
    resolver_not_starts_with?: Maybe<Scalars['String']>;
    resolver_ends_with?: Maybe<Scalars['String']>;
    resolver_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    key?: Maybe<Scalars['String']>;
    key_not?: Maybe<Scalars['String']>;
    key_gt?: Maybe<Scalars['String']>;
    key_lt?: Maybe<Scalars['String']>;
    key_gte?: Maybe<Scalars['String']>;
    key_lte?: Maybe<Scalars['String']>;
    key_in?: Maybe<Array<Scalars['String']>>;
    key_not_in?: Maybe<Array<Scalars['String']>>;
    key_contains?: Maybe<Scalars['String']>;
    key_not_contains?: Maybe<Scalars['String']>;
    key_starts_with?: Maybe<Scalars['String']>;
    key_not_starts_with?: Maybe<Scalars['String']>;
    key_ends_with?: Maybe<Scalars['String']>;
    key_not_ends_with?: Maybe<Scalars['String']>;
};
export declare enum TextChanged_OrderBy {
    Id = "id",
    Resolver = "resolver",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Key = "key"
}
export declare type Transfer = DomainEvent & {
    __typename?: 'Transfer';
    id: Scalars['ID'];
    domain: Domain;
    blockNumber: Scalars['Int'];
    transactionID: Scalars['Bytes'];
    owner: Account;
};
export declare type Transfer_Filter = {
    id?: Maybe<Scalars['ID']>;
    id_not?: Maybe<Scalars['ID']>;
    id_gt?: Maybe<Scalars['ID']>;
    id_lt?: Maybe<Scalars['ID']>;
    id_gte?: Maybe<Scalars['ID']>;
    id_lte?: Maybe<Scalars['ID']>;
    id_in?: Maybe<Array<Scalars['ID']>>;
    id_not_in?: Maybe<Array<Scalars['ID']>>;
    domain?: Maybe<Scalars['String']>;
    domain_not?: Maybe<Scalars['String']>;
    domain_gt?: Maybe<Scalars['String']>;
    domain_lt?: Maybe<Scalars['String']>;
    domain_gte?: Maybe<Scalars['String']>;
    domain_lte?: Maybe<Scalars['String']>;
    domain_in?: Maybe<Array<Scalars['String']>>;
    domain_not_in?: Maybe<Array<Scalars['String']>>;
    domain_contains?: Maybe<Scalars['String']>;
    domain_not_contains?: Maybe<Scalars['String']>;
    domain_starts_with?: Maybe<Scalars['String']>;
    domain_not_starts_with?: Maybe<Scalars['String']>;
    domain_ends_with?: Maybe<Scalars['String']>;
    domain_not_ends_with?: Maybe<Scalars['String']>;
    blockNumber?: Maybe<Scalars['Int']>;
    blockNumber_not?: Maybe<Scalars['Int']>;
    blockNumber_gt?: Maybe<Scalars['Int']>;
    blockNumber_lt?: Maybe<Scalars['Int']>;
    blockNumber_gte?: Maybe<Scalars['Int']>;
    blockNumber_lte?: Maybe<Scalars['Int']>;
    blockNumber_in?: Maybe<Array<Scalars['Int']>>;
    blockNumber_not_in?: Maybe<Array<Scalars['Int']>>;
    transactionID?: Maybe<Scalars['Bytes']>;
    transactionID_not?: Maybe<Scalars['Bytes']>;
    transactionID_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_not_in?: Maybe<Array<Scalars['Bytes']>>;
    transactionID_contains?: Maybe<Scalars['Bytes']>;
    transactionID_not_contains?: Maybe<Scalars['Bytes']>;
    owner?: Maybe<Scalars['String']>;
    owner_not?: Maybe<Scalars['String']>;
    owner_gt?: Maybe<Scalars['String']>;
    owner_lt?: Maybe<Scalars['String']>;
    owner_gte?: Maybe<Scalars['String']>;
    owner_lte?: Maybe<Scalars['String']>;
    owner_in?: Maybe<Array<Scalars['String']>>;
    owner_not_in?: Maybe<Array<Scalars['String']>>;
    owner_contains?: Maybe<Scalars['String']>;
    owner_not_contains?: Maybe<Scalars['String']>;
    owner_starts_with?: Maybe<Scalars['String']>;
    owner_not_starts_with?: Maybe<Scalars['String']>;
    owner_ends_with?: Maybe<Scalars['String']>;
    owner_not_ends_with?: Maybe<Scalars['String']>;
};
export declare enum Transfer_OrderBy {
    Id = "id",
    Domain = "domain",
    BlockNumber = "blockNumber",
    TransactionId = "transactionID",
    Owner = "owner"
}
export declare type _Block_ = {
    __typename?: '_Block_';
    /** The hash of the block */
    hash?: Maybe<Scalars['Bytes']>;
    /** The block number */
    number: Scalars['Int'];
};
/** The type for the top-level _meta field */
export declare type _Meta_ = {
    __typename?: '_Meta_';
    /**
     * Information about a specific subgraph block. The hash of the block
     * will be null if the _meta field has a block constraint that asks for
     * a block number. It will be filled if the _meta field has no block constraint
     * and therefore asks for the latest  block
     */
    block: _Block_;
    /** The deployment ID */
    deployment: Scalars['String'];
    /** If `true`, the subgraph encountered indexing errors at some past block */
    hasIndexingErrors: Scalars['Boolean'];
};
export declare enum _SubgraphErrorPolicy_ {
    /** Data will be returned even if the subgraph has indexing errors */
    Allow = "allow",
    /** If the subgraph has indexing errors, data will be omitted. The default. */
    Deny = "deny"
}
export declare type DomainResolvedPartFragment = ({
    __typename?: 'Domain';
} & Pick<Domain, 'name' | 'labelName' | 'labelhash'> & {
    resolvedAddress?: Maybe<({
        __typename?: 'Account';
    } & Pick<Account, 'id'>)>;
    resolver?: Maybe<({
        __typename?: 'Resolver';
    } & Pick<Resolver, 'id'>)>;
});
export declare type ResolveNamesQueryVariables = Exact<{
    addresses?: Maybe<Array<Scalars['String']> | Scalars['String']>;
}>;
export declare type ResolveNamesQuery = ({
    __typename?: 'Query';
} & {
    domains: Array<({
        __typename?: 'Domain';
    } & DomainResolvedPartFragment)>;
});
