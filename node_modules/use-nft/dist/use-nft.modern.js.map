{"version":3,"file":"use-nft.modern.js","sources":["../src/utils.tsx","../src/fetchers/shared/cryptopunks.ts","../src/known-contracts.tsx","../src/fetchers/shared/cryptokitties.ts","../src/fetchers/shared/decentraland-estate.tsx","../src/fetchers/shared/decentraland-parcel.tsx","../src/fetchers/shared/mooncats.ts","../src/fetchers/shared/fetch-metadata.tsx","../src/fetchers/ethers/standard-nft.tsx","../src/fetchers/ethers/index.tsx","../src/fetchers/ethers/cryptopunks.ts","../src/fetchers/ethers/mooncats.ts","../src/fetchers/ethereum/utils.ts","../src/fetchers/ethereum/standard-nft.tsx","../src/fetchers/ethereum/index.tsx","../src/fetchers/ethereum/cryptopunks.ts","../src/fetchers/ethereum/mooncats.ts","../src/core.tsx","../src/fetchWrapper.ts"],"sourcesContent":["import type {\n  Address,\n  FetchContext,\n  IpfsUrlFn,\n  NftJsonMetadata,\n  NftMetadata,\n} from \"./types\"\n\n// Some NFT minting services misinterpreted the JSON schema from the EIP as\n// literal JSON, e.g. portion.io:\n// https://ipfs.io/ipfs/QmNt5T9HSXKLXZ3kmciU4Tm6q9R8JEm5ifJkPoxapjyRUR\ntype NftMetadataMixedInJsonSchema = {\n  title: string\n  type: \"object\"\n  properties: {\n    name: { type: \"string\"; description: string }\n    image: { type: \"string\"; description: string }\n    description: { type: \"string\"; description: string }\n  }\n}\n\nconst RARIBLE_MATCH_RE =\n  /^https:\\/\\/rarible\\.com\\/token\\/(0x[a-fA-F0-9]{40}):([0-9]+)/\n\nexport function isAddress(value: string): value is Address {\n  return /^0x[a-fA-F0-9]{40}$/.test(value)\n}\n\nexport function identity<T = unknown>(arg: T): T {\n  return arg\n}\n\nexport function parseNftUrl(url: string): [string, string] | null {\n  const raribleMatch = RARIBLE_MATCH_RE.exec(url)\n  if (raribleMatch) {\n    return [raribleMatch[1], raribleMatch[2]]\n  }\n  return null\n}\n\nexport function fetchImage(src: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const image = new Image()\n    image.src = src\n    image.crossOrigin = \"\"\n    image.onload = () => resolve(image)\n    image.onerror = (error) => reject(error)\n  })\n}\n\n// Scale the image and add some extra padding. Returns the image as base64.\n// The padding and scale are expressed as proportions of the image size.\nexport function frameImage(\n  image: HTMLImageElement,\n  { scale = 1, padding = 0 } = {}\n): string | null {\n  const width = image.naturalWidth * scale\n  const height = image.naturalHeight * scale\n  const _padding = Math.max(width * padding, height * padding)\n\n  const canvas = document.createElement(\"canvas\")\n  canvas.width = width + _padding * 2\n  canvas.height = height + _padding * 2\n\n  const ctx = canvas.getContext(\"2d\")\n  if (ctx === null) {\n    return null\n  }\n\n  ctx.imageSmoothingEnabled = false\n  ctx.drawImage(image, _padding, _padding, width, height)\n\n  return canvas.toDataURL()\n}\n\nexport function ipfsUrlDefault(cid: string, path = \"\"): string {\n  return `https://ipfs.io/ipfs/${cid}${path}`\n}\n\nconst IPFS_PROTOCOL_RE = /^ipfs:\\/\\/(?:ipfs\\/)?([^/]+)(\\/.+)?$/\nconst IPFS_HASH_RE = /^Qm[1-9A-HJ-NP-Za-km-z]{44}$/\n\nexport function ipfsUrlFromString(\n  ipfsString: string,\n  ipfsUrl: IpfsUrlFn\n): string {\n  // ipfs:// URI\n  const ipfsProtocolMatch = IPFS_PROTOCOL_RE.exec(ipfsString)\n  if (ipfsProtocolMatch) {\n    const [, cid, path = \"\"] = ipfsProtocolMatch\n    return ipfsUrl(cid, path)\n  }\n\n  // standalone cid, probably\n  if (IPFS_HASH_RE.test(ipfsString)) {\n    return ipfsUrl(ipfsString)\n  }\n\n  // maybe URL\n  return ipfsString\n}\n\nexport function normalizeOpenSeaUrl(url: string, tokenId: string): string {\n  // url can be anything so we need to try / catch to pass it to new URL()\n  try {\n    const _url = new URL(url)\n\n    // 0x%7Bid%7D\" = 0x{id} (url encoded)\n    if (\n      (_url.host !== \"api.opensea.io\" &&\n        _url.host !== \"testnets-api.opensea.io\") ||\n      !_url.pathname.includes(\"0x%7Bid%7D\")\n    ) {\n      return url\n    }\n\n    _url.pathname = _url.pathname.replace(/0x%7Bid%7D/g, tokenId)\n    _url.searchParams.set(\"format\", \"json\")\n\n    return String(_url)\n  } catch (err) {\n    return url\n  }\n}\n\nexport function normalizeNiftyGatewayUrl(url: string): string {\n  try {\n    const _url = new URL(url)\n\n    if (_url.host !== \"api.niftygateway.com\") {\n      return url\n    }\n\n    // Without final slash, the Nifty Gateway API server\n    // doesn’t set the CORS headers properly.\n    _url.pathname = _url.pathname + \"/\"\n    return String(_url)\n  } catch (err) {\n    return url\n  }\n}\n\nexport function normalizeTokenUrl(\n  url: string,\n  tokenId: string,\n  fetchContext: FetchContext\n): string {\n  url = normalizeOpenSeaUrl(url, tokenId)\n  url = normalizeNiftyGatewayUrl(url)\n  url = ipfsUrlFromString(url, fetchContext.ipfsUrl)\n\n  if (url.startsWith(\"http\")) {\n    url = fetchContext.jsonProxy(url)\n  }\n\n  return url\n}\n\nexport function normalizeImageUrl(\n  url: string,\n  fetchContext: FetchContext\n): string {\n  return ipfsUrlFromString(url, fetchContext.ipfsUrl)\n}\n\nexport function normalizeNftMetadata(\n  data: NftJsonMetadata,\n  fetchContext: FetchContext\n): NftJsonMetadata {\n  return {\n    ...data,\n    image: normalizeImageUrl(data.image, fetchContext),\n  }\n}\n\nexport function fixIncorrectImageField(\n  data: Record<string, unknown>\n): Record<string, unknown> {\n  if (!data || typeof data !== \"object\") {\n    return data\n  }\n\n  const _data = data as {\n    image: string\n    imageUrl: string\n  }\n\n  // makersplace.com is using `imageUrl` rather than `image`\n  if (\n    typeof _data?.image === \"undefined\" &&\n    typeof _data?.imageUrl === \"string\"\n  ) {\n    return { ..._data, image: _data?.imageUrl }\n  }\n\n  return data\n}\n\n// See NftMetadataMixedInJsonSchema for why this is needed.\nexport function isNftMetadataMixedInJsonSchema(\n  data: unknown\n): data is NftMetadataMixedInJsonSchema {\n  if (!data || typeof data !== \"object\") {\n    return false\n  }\n  const _data = data as NftMetadataMixedInJsonSchema\n  return (\n    _data.title === \"Asset Metadata\" &&\n    _data.type === \"object\" &&\n    typeof _data.properties?.name?.description === \"string\" &&\n    typeof _data.properties?.image?.description === \"string\" &&\n    typeof _data.properties?.description?.description === \"string\" &&\n    _data.properties?.name?.type === \"string\" &&\n    _data.properties?.image?.type === \"string\" &&\n    _data.properties?.description?.type === \"string\"\n  )\n}\n\nexport function fixNftMetadataMixedInJsonSchema(\n  data: NftMetadataMixedInJsonSchema\n): NftJsonMetadata {\n  return {\n    name: data.properties?.name?.description || \"\",\n    description: data.properties?.description?.description || \"\",\n    image: data.properties?.image?.description || \"\",\n    rawData: { ...data },\n  }\n}\n\nexport function isNftMetadata(data: unknown): data is NftMetadata {\n  if (!data || typeof data !== \"object\") {\n    return false\n  }\n  const _data = data as NftMetadata\n\n  // We don’t test for the exact type here, because some NFT minting services\n  // set some of the fields as null.\n  // We also only test for the presence of either `name` or `image`, as some\n  // NFT formats don’t declare them all (e.g. BAYC only declares `image`).\n  return \"name\" in _data || \"image\" in _data\n}\n\nexport function addressesEqual(addr1: Address, addr2: Address): boolean {\n  return addr1?.toLowerCase() === addr2?.toLowerCase()\n}\n\n// Promise.any() implementation from https://github.com/m0ppers/promise-any\nexport function promiseAny<T>(promises: Promise<T>[]): Promise<T> {\n  return reversePromise(\n    Promise.all([...promises].map(reversePromise))\n  ) as Promise<T>\n}\nexport function reversePromise(promise: Promise<unknown>): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    Promise.resolve(promise).then(reject, resolve)\n  })\n}\n\n// To replace with AggregateError when useNft() will target ES2021 environments\nexport class MultipleErrors extends Error {\n  errors: Error[]\n  constructor(message: string, errors: Error[]) {\n    super(message)\n    this.name = \"MultipleErrors\"\n    this.errors = errors\n  }\n}\n\nconst IMAGE_EXT_RE = /\\.(?:png|svg|jpg|jepg|gif|webp|jxl|avif)$/\nconst VIDEO_EXT_RE = /\\.(?:mp4|mov|webm|ogv)$/\n\n// Guess a file type from the extension used in a URL\nexport function urlExtensionType(url: string): NftMetadata[\"imageType\"] {\n  if (IMAGE_EXT_RE.test(url)) return \"image\"\n  if (VIDEO_EXT_RE.test(url)) return \"video\"\n  return \"unknown\"\n}\n","import type { Address, ContractMethod, NftMetadata } from \"../../types\"\n\nimport { CRYPTOPUNKS, CRYPTOPUNKS_IMAGES } from \"../../known-contracts\"\nimport { addressesEqual } from \"../../utils\"\n\nconst CRYPTOPUNKS_DESCRIPTION = `\n  10,000 unique collectible characters with proof of ownership stored on the\n  Ethereum blockchain. The project that inspired the modern CryptoArt movement.\n  The first \"Non-Fungible Token,\" and inspiration for the Ethereum ERC-721\n  standard that powers most digital art and collectibles.\n`\n\nconst CRYPTOPUNKS_IMAGE_SVG: ContractMethod = {\n  address: CRYPTOPUNKS_IMAGES,\n  methodName: \"punkImageSvg\",\n  methodHash: \"0x74beb047\",\n  humanReadableAbi: [\n    \"function punkImageSvg(uint16 index) view returns (string svg)\",\n  ],\n}\n\nfunction encodeUriData(dataUri: string): string {\n  const dataStart = dataUri.indexOf(\",\") + 1\n  return (\n    dataUri.slice(0, dataStart) +\n      encodeURIComponent(dataUri.slice(dataStart)) ?? \"\"\n  )\n}\n\nexport async function cryptoPunksMetadata(\n  index: string,\n  cryptoPunksImage: (tokenId: string, method: ContractMethod) => Promise<string>\n): Promise<NftMetadata> {\n  const image = await cryptoPunksImage(index, CRYPTOPUNKS_IMAGE_SVG)\n\n  return {\n    description: CRYPTOPUNKS_DESCRIPTION,\n    image: encodeUriData(image),\n    imageType: \"image\",\n    metadataUrl: \"\",\n    name: `CryptoPunk ${index}`,\n    owner: \"\",\n    rawData: null,\n  }\n}\n\nexport function isCryptoPunks(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, CRYPTOPUNKS)\n}\n","export const CRYPTOKITTIES = \"0x06012c8cf97BEaD5deAe237070F9587f8E7A266d\"\nexport const CRYPTOPUNKS = \"0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb\"\nexport const CRYPTOPUNKS_IMAGES = \"0x16F5A35647D6F03D5D3da7b35409D65ba03aF3B2\"\nexport const CRYPTOVOXELS = \"0x79986aF15539de2db9A5086382daEdA917A9CF0C\"\nexport const DECENTRALAND_ESTATE = \"0x959e104E1a4dB6317fA58F8295F586e1A978c297\"\nexport const DECENTRALAND_PARCEL = \"0xf87e31492faf9a91b02ee0deaad50d51d56d5d4d\"\n","import type { Address, FetchContext, NftMetadata } from \"../../types\"\n\nimport { CRYPTOKITTIES } from \"../../known-contracts\"\nimport { addressesEqual } from \"../../utils\"\n\nexport async function cryptoKittiesMetadata(\n  id: string,\n  { jsonProxy }: FetchContext\n): Promise<NftMetadata> {\n  const metadataUrl = jsonProxy(`https://api.cryptokitties.co/v3/kitties/${id}`)\n  const res = await fetch(metadataUrl)\n  const data = (await res.json()) as {\n    name: string\n    bio: string\n    image_url: string\n  }\n  const image = data?.image_url ?? \"\"\n  return {\n    description: data?.bio ?? \"−\",\n    image,\n    imageType: image ? \"image\" : \"unknown\",\n    metadataUrl,\n    name: data?.name ?? \"Unknown\",\n    owner: \"\",\n    rawData: data,\n  }\n}\n\nexport function isCryptoKitties(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, CRYPTOKITTIES)\n}\n","import type { Address, NftMetadata } from \"../../types\"\n\nimport { DECENTRALAND_ESTATE } from \"../../known-contracts\"\nimport { addressesEqual } from \"../../utils\"\n\nconst ENDPOINT =\n  \"https://api.thegraph.com/subgraphs/name/decentraland/marketplace\"\n\nconst QUERY = `\n  query NFTByTokenId($contractAddress: String, $tokenId: String) {\n    nfts(\n      where: { contractAddress: $contractAddress, tokenId: $tokenId }\n      first: 1\n    ) {\n      name\n      image\n      owner {\n        address\n      }\n      estate {\n        size\n        data {\n          description\n        }\n      }\n    }\n  }\n`\n\nfunction body(contractAddress: string, tokenId: string) {\n  return JSON.stringify({\n    operationName: \"NFTByTokenId\",\n    variables: { contractAddress, tokenId },\n    query: QUERY,\n  })\n}\n\nexport async function decentralandEstateMetadata(\n  tokenId: string\n): Promise<NftMetadata> {\n  const response = await fetch(ENDPOINT, {\n    body: body(DECENTRALAND_ESTATE, tokenId),\n    method: \"POST\",\n  })\n\n  const { data } = (await response.json()) as {\n    data: {\n      nfts: [\n        {\n          name: string\n          image: string\n          owner: { address: Address }\n          estate: {\n            size: number\n            data: { description: string }\n          }\n        }\n      ]\n    }\n  }\n\n  const nft = data?.nfts?.[0]\n  const image = nft?.image ?? \"\"\n\n  return {\n    description: nft?.estate?.data?.description ?? \"−\",\n    image,\n    imageType: image ? \"image\" : \"unknown\",\n    metadataUrl: \"\",\n    name: nft?.name ?? \"Unknown\",\n    owner: nft?.owner?.address ?? \"\",\n    rawData: data,\n  }\n}\n\nexport function isDecentralandEstate(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, DECENTRALAND_ESTATE)\n}\n","import type { Address, NftMetadata } from \"../../types\"\n\nimport { DECENTRALAND_PARCEL } from \"../../known-contracts\"\nimport { addressesEqual } from \"../../utils\"\n\nconst ENDPOINT =\n  \"https://api.thegraph.com/subgraphs/name/decentraland/marketplace\"\n\nconst QUERY = `\n  query NFTByTokenId($contractAddress: String, $tokenId: String) {\n    nfts(\n      where: { contractAddress: $contractAddress, tokenId: $tokenId }\n      first: 1\n    ) {\n      name\n      image\n      owner {\n        address\n      }\n      parcel {\n        x\n        y\n        data {\n          description\n        }\n      }\n    }\n  }\n`\n\nfunction body(contractAddress: string, tokenId: string) {\n  return JSON.stringify({\n    operationName: \"NFTByTokenId\",\n    variables: { contractAddress, tokenId },\n    query: QUERY,\n  })\n}\n\nexport async function decentralandParcelMetadata(\n  tokenId: string\n): Promise<NftMetadata> {\n  const response = await fetch(ENDPOINT, {\n    body: body(DECENTRALAND_PARCEL, tokenId),\n    method: \"POST\",\n  })\n\n  const { data } = (await response.json()) as {\n    data: {\n      nfts: [\n        {\n          name: string\n          image: string\n          owner: { address: Address }\n          parcel: {\n            x: number\n            y: number\n            data: {\n              description: string\n            }\n          }\n        }\n      ]\n    }\n  }\n\n  const nft = data?.nfts?.[0]\n  const parcel = nft?.parcel\n  const image = nft?.image ?? \"\"\n\n  return {\n    description: parcel?.data?.description ?? \"-\",\n    image,\n    imageType: image ? \"image\" : \"unknown\",\n    metadataUrl: \"\",\n    name: nft?.name ?? `Parcel ${parcel?.x},${parcel?.y}`,\n    owner: nft?.owner?.address ?? \"\",\n    rawData: data,\n  }\n}\n\nexport function isDecentralandParcel(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, DECENTRALAND_PARCEL)\n}\n","import type {\n  Address,\n  ContractMethod,\n  FetchContext,\n  IpfsUrlFn,\n  NftMetadata,\n} from \"../../types\"\n\nimport {\n  addressesEqual,\n  fetchImage,\n  frameImage,\n  ipfsUrlFromString,\n} from \"../../utils\"\n\nconst MOONCATS_WRAPPED: ContractMethod = {\n  address: \"0x7c40c393dc0f283f318791d746d894ddd3693572\",\n  methodName: \"_tokenIDToCatID\",\n  methodHash: \"0xfe294644\",\n  humanReadableAbi: [\n    \"function _tokenIDToCatID(uint256 tokenId) view returns (bytes5 catId)\",\n  ],\n}\n\n// See https://www.reddit.com/r/MoonCatRescue/comments/m5d7mx/svg_imagery_of_all_rescued_mooncats/\nconst MOONCATS_IPFS_CID =\n  \"bafybeidk4zunuq56w2pf2sncexohlyqae62dzplljkbwswa7jwywh2dava\"\n\nexport async function imageUrl(\n  catId: string,\n  ipfsUrl: IpfsUrlFn\n): Promise<string | null> {\n  const dir = catId.slice(4, 6)\n  const url = ipfsUrlFromString(\n    `ipfs://ipfs/${MOONCATS_IPFS_CID}/${dir}/${catId}.png`,\n    ipfsUrl\n  )\n  const image = await fetchImage(url)\n\n  // Here we increase the resolution of the MoonCats PNG files (4x without\n  // antialias) and add a some padding around it. Doing this image manipulation\n  // rather than using CSS is needed because useNft() only deals with data and\n  // doesn’t have any control over how the images get displayed.\n  return frameImage(image, { scale: 4, padding: 0.125 })\n}\n\nexport async function moonCatsMetadata(\n  tokenId: string,\n  getCatId: (tokenId: string, method: ContractMethod) => Promise<string>,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  const catId = await getCatId(tokenId, MOONCATS_WRAPPED)\n\n  const image = (await imageUrl(catId, fetchContext.ipfsUrl)) ?? \"\"\n  return {\n    description:\n      `The (unofficial) wrapped version of MoonCats Rescue. ` +\n      `Original cat ID: ${catId}.`,\n    image,\n    imageType: image ? \"image\" : \"unknown\",\n    metadataUrl: \"\",\n    name: `Wrapped MoonCat #${tokenId}`,\n    owner: \"\",\n    rawData: null,\n  }\n}\n\nexport function isMoonCats(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, MOONCATS_WRAPPED.address)\n}\n","import type { FetchContext, NftJsonMetadata } from \"../../types\"\n\nimport {\n  fixIncorrectImageField,\n  fixNftMetadataMixedInJsonSchema,\n  isNftMetadata,\n  isNftMetadataMixedInJsonSchema,\n  normalizeNftMetadata,\n} from \"../../utils\"\n\nexport async function fetchMetadata(\n  url: string,\n  fetchContext: FetchContext\n): Promise<NftJsonMetadata> {\n  const res = await fetch(url)\n\n  if (!res.ok) {\n    throw new Error(\"Error when trying to request \" + url)\n  }\n\n  let rawData\n\n  try {\n    rawData = (await res.json()) as Record<string, unknown>\n  } catch (err) {\n    // If it can’t be parsed as JSON, it must be an image URL\n    rawData = { name: \"\", description: \"\", image: url }\n  }\n\n  let data = { ...rawData }\n\n  if (isNftMetadataMixedInJsonSchema(data)) {\n    data = fixNftMetadataMixedInJsonSchema(data)\n  }\n\n  data = fixIncorrectImageField(data)\n\n  if (!isNftMetadata(data)) {\n    throw new Error(\"Invalid data received\")\n  }\n\n  return normalizeNftMetadata(\n    {\n      description: data.description || \"\",\n      image: data.image || \"\",\n      name: data.name || \"\",\n      rawData,\n    },\n    fetchContext\n  )\n}\n","import type { Contract, ContractFunction } from \"@ethersproject/contracts\"\nimport type { Address, FetchContext, NftMetadata } from \"../../types\"\nimport type { EthersFetcherConfigEthersLoaded } from \"./types\"\n\nimport { fetchMetadata } from \"../shared/fetch-metadata\"\nimport {\n  MultipleErrors,\n  normalizeTokenUrl,\n  promiseAny,\n  urlExtensionType,\n} from \"../../utils\"\n\nconst ABI = [\n  // ERC-721\n  \"function tokenURI(uint256 _tokenId) external view returns (string)\",\n  \"function ownerOf(uint256 _tokenId) external view returns (address)\",\n  // ERC-1155\n  \"function uri(uint256 _id) external view returns (string)\",\n]\n\ntype NftContract = InstanceType<typeof Contract> & {\n  ownerOf: ContractFunction<string>\n  tokenURI: ContractFunction<string>\n  uri: ContractFunction<string>\n}\n\nasync function url(\n  contract: NftContract,\n  tokenId: string,\n  fetchContext: FetchContext\n): Promise<string> {\n  const uri = await promiseAny([\n    contract.tokenURI(tokenId),\n    contract.uri(tokenId),\n  ]).catch((errors) => {\n    throw new MultipleErrors(\n      \"An error occurred while trying to fetch the token URI from the NFT\" +\n        \" contract. See the “errors” property on this error for details.\",\n      errors\n    )\n  })\n  return normalizeTokenUrl(uri, tokenId, fetchContext)\n}\n\nexport async function fetchStandardNftContractData(\n  contractAddress: Address,\n  tokenId: string,\n  config: EthersFetcherConfigEthersLoaded,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  const contract = new config.ethers.Contract(\n    contractAddress,\n    ABI,\n    config.provider\n  ) as NftContract\n\n  const [metadataUrl, owner] = await Promise.all([\n    url(contract, tokenId, fetchContext),\n    contract.ownerOf(tokenId).catch(() => \"\"),\n  ])\n\n  const metadata = await fetchMetadata(metadataUrl, fetchContext)\n  const imageType = urlExtensionType(metadata.image)\n\n  return {\n    ...metadata,\n    imageType,\n    metadataUrl,\n    owner,\n  }\n}\n","import type {\n  Address,\n  FetchContext,\n  ImageProxyFn,\n  NftMetadata,\n} from \"../../types\"\nimport type {\n  EthersFetcher,\n  EthersFetcherConfig,\n  EthersFetcherConfigEthersLoaded,\n} from \"./types\"\n\nimport { isAddress } from \"../../utils\"\nimport { cryptoPunksMetadata, isCryptoPunks } from \"../shared/cryptopunks\"\nimport { cryptoKittiesMetadata, isCryptoKitties } from \"../shared/cryptokitties\"\nimport {\n  decentralandEstateMetadata,\n  isDecentralandEstate,\n} from \"../shared/decentraland-estate\"\nimport {\n  decentralandParcelMetadata,\n  isDecentralandParcel,\n} from \"../shared/decentraland-parcel\"\nimport { isMoonCats, moonCatsMetadata } from \"../shared/mooncats\"\nimport { cryptoPunksImage } from \"./cryptopunks\"\nimport { moonCatsCatId } from \"./mooncats\"\nimport { fetchStandardNftContractData } from \"./standard-nft\"\n\nconst ETHERS_NOT_FOUND =\n  \"Ethers couldn’t be imported. \" +\n  \"Please add the ethers module to your project dependencies, \" +\n  \"or inject it in the Ethers fetcher options.\"\n\nasync function loadEthers(\n  config: EthersFetcherConfig\n): Promise<EthersFetcherConfigEthersLoaded> {\n  if (config.ethers?.Contract) {\n    return config as EthersFetcherConfigEthersLoaded\n  }\n\n  try {\n    const ethers = await import(\"@ethersproject/contracts\")\n    if (!ethers?.Contract) {\n      throw new Error()\n    }\n    return { ...config, ethers }\n  } catch (err) {\n    throw new Error(ETHERS_NOT_FOUND)\n  }\n}\n\nasync function fetchNftMetadata(\n  contractAddress: Address,\n  tokenId: string,\n  config: EthersFetcherConfig,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  if (isDecentralandParcel(contractAddress)) {\n    return decentralandParcelMetadata(tokenId)\n  }\n\n  if (isDecentralandEstate(contractAddress)) {\n    return decentralandEstateMetadata(tokenId)\n  }\n\n  if (isCryptoKitties(contractAddress)) {\n    return cryptoKittiesMetadata(tokenId, fetchContext)\n  }\n\n  const configWithEthersLoaded = await loadEthers(config)\n\n  if (isCryptoPunks(contractAddress)) {\n    return cryptoPunksMetadata(\n      tokenId,\n      cryptoPunksImage(configWithEthersLoaded)\n    )\n  }\n\n  if (isMoonCats(contractAddress)) {\n    return moonCatsMetadata(\n      tokenId,\n      moonCatsCatId(configWithEthersLoaded),\n      fetchContext\n    )\n  }\n\n  return fetchStandardNftContractData(\n    contractAddress,\n    tokenId,\n    configWithEthersLoaded,\n    fetchContext\n  )\n}\n\nfunction addProxyImage(\n  metadata: NftMetadata,\n  imageProxy: ImageProxyFn\n): NftMetadata {\n  return metadata.image.startsWith(\"http\")\n    ? { ...metadata, image: imageProxy(metadata.image, metadata) }\n    : metadata\n}\n\nexport default function ethersFetcher(\n  config: EthersFetcherConfig\n): EthersFetcher {\n  return {\n    config,\n    async fetchNft(\n      contractAddress: Address,\n      tokenId: string,\n      fetchContext: FetchContext\n    ): Promise<NftMetadata> {\n      if (!isAddress(contractAddress)) {\n        throw new Error(`Invalid contract address: ${contractAddress}`)\n      }\n      const metadata = await fetchNftMetadata(\n        contractAddress,\n        tokenId,\n        config,\n        fetchContext\n      )\n      return addProxyImage(metadata, fetchContext.imageProxy)\n    },\n  }\n}\n","import type { Contract, ContractFunction } from \"@ethersproject/contracts\"\nimport type { ContractMethod } from \"../../types\"\nimport type { EthersFetcherConfigEthersLoaded } from \"./types\"\n\nexport function cryptoPunksImage(config: EthersFetcherConfigEthersLoaded) {\n  return async function cryptoPunksImage(\n    index: string,\n    method: ContractMethod\n  ): Promise<string> {\n    const contract = new config.ethers.Contract(\n      method.address,\n      method.humanReadableAbi,\n      config.provider\n    ) as InstanceType<typeof Contract> & {\n      punkImageSvg: ContractFunction<string>\n    }\n    return contract.punkImageSvg(index)\n  }\n}\n","import type { Contract, ContractFunction } from \"@ethersproject/contracts\"\nimport type { ContractMethod } from \"../../types\"\nimport type { EthersFetcherConfigEthersLoaded } from \"./types\"\n\nexport function moonCatsCatId(config: EthersFetcherConfigEthersLoaded) {\n  return async function moonCatsCatId(\n    tokenId: string,\n    method: ContractMethod\n  ): Promise<string> {\n    const wrappedContract = new config.ethers.Contract(\n      method.address,\n      method.humanReadableAbi,\n      config.provider\n    ) as InstanceType<typeof Contract> & {\n      _tokenIDToCatID: ContractFunction<string>\n    }\n    const result = await wrappedContract._tokenIDToCatID(tokenId)\n    return result ?? \"\"\n  }\n}\n","import type { Address } from \"../../types\"\nimport type { EthereumProviderEip1193 } from \"./types\"\n\n// Pre encoded method names to avoid embedding a keccak256 library.\n// See https://docs.soliditylang.org/en/v0.5.3/abi-spec.html#function-selector-and-argument-encoding\nconst URI_METHOD_ERC721 = \"0xc87b56dd\" // tokenURI(uint256)\nconst URI_METHOD_ERC1155 = \"0x0e89341c\" // uri(uint256)\nconst OWNER_OF_METHOD_ERC721 = \"0x6352211e\" // ownerOf(uint256)\n\n// Utilities adapted from https://github.com/Zoltu/ethereum-abi-encoder/\nexport function uint256Hex(value: bigint): string {\n  let result = \"\"\n  for (let i = 0; i < 32; ++i) {\n    result += (\n      \"0\" + ((value >> BigInt(8 * 32 - i * 8 - 8)) & BigInt(255)).toString(16)\n    ).slice(-2)\n  }\n  return result\n}\n\nexport function bytesToBigInt(bytes: Uint8Array): bigint {\n  let value = BigInt(0)\n  for (const byte of bytes) {\n    value = (value << BigInt(8)) + BigInt(byte)\n  }\n  return value\n}\n\nexport function hexToUint8Array(hex: string): Uint8Array {\n  hex = hex.replace(/^0x/, \"\")\n  return new Uint8Array(\n    (hex.match(/.{1,2}/g) ?? []).map((byte) => parseInt(byte, 16))\n  )\n}\n\nexport function decodeString(hex: string): string {\n  const data = hexToUint8Array(hex)\n  const pointer = Number(bytesToBigInt(data.subarray(0, 32)))\n  const length = Number(bytesToBigInt(data.subarray(pointer, pointer + 32)))\n  const bytes = data.subarray(pointer + 32, pointer + 32 + length)\n  return new TextDecoder().decode(bytes)\n}\n\nexport function decodeAddress(hex: string): string {\n  const data = hexToUint8Array(hex)\n  const bytes = data.subarray(0, 32)\n  const decoded = bytesToBigInt(bytes)\n  if (decoded >= BigInt(2) ** BigInt(160))\n    throw new Error(\n      `Encoded value is bigger than the largest possible address.  Decoded value: 0x${decoded.toString(\n        16\n      )}.`\n    )\n  return `0x${decoded.toString(16)}`\n}\n\nexport function methodUriErc721(tokenId: bigint): string {\n  return URI_METHOD_ERC721 + uint256Hex(tokenId)\n}\n\nexport function methodUriErc1155(id: bigint): string {\n  return URI_METHOD_ERC1155 + uint256Hex(id)\n}\n\nexport function methodOwnerOfErc721(tokenId: bigint): string {\n  return OWNER_OF_METHOD_ERC721 + uint256Hex(tokenId)\n}\n\nexport function ethCall(\n  ethereum: EthereumProviderEip1193,\n  to: Address,\n  data: string\n): Promise<string> {\n  return ethereum.request({\n    method: \"eth_call\",\n    params: [{ data, to }, \"latest\"],\n  }) as Promise<string>\n}\n","import type { Address, FetchContext, NftMetadata } from \"../../types\"\nimport type { EthereumFetcherConfig, EthereumProviderEip1193 } from \"./types\"\n\nimport { fetchMetadata } from \"../shared/fetch-metadata\"\nimport {\n  MultipleErrors,\n  normalizeTokenUrl,\n  promiseAny,\n  urlExtensionType,\n} from \"../../utils\"\nimport {\n  decodeAddress,\n  decodeString,\n  ethCall,\n  methodOwnerOfErc721,\n  methodUriErc1155,\n  methodUriErc721,\n} from \"./utils\"\n\nfunction uriMethods(tokenId: string): string[] {\n  return [methodUriErc721(BigInt(tokenId)), methodUriErc1155(BigInt(tokenId))]\n}\n\nasync function url(\n  contractAddress: Address,\n  tokenId: string,\n  ethereum: EthereumProviderEip1193,\n  fetchContext: FetchContext\n): Promise<string> {\n  const uri = await promiseAny(\n    uriMethods(tokenId).map((method) =>\n      ethCall(ethereum, contractAddress, method)\n    )\n  ).catch((errors) => {\n    throw new MultipleErrors(\n      \"An error occurred while trying to fetch the token URI from the NFT\" +\n        \" contract. See the “errors” property on this error for details.\",\n      errors\n    )\n  })\n  return normalizeTokenUrl(decodeString(uri), tokenId, fetchContext)\n}\n\nexport async function fetchStandardNftContractData(\n  contractAddress: Address,\n  tokenId: string,\n  { ethereum }: EthereumFetcherConfig,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  const [metadataUrl, owner] = await Promise.all([\n    url(contractAddress, tokenId, ethereum, fetchContext),\n    ethCall(ethereum, contractAddress, methodOwnerOfErc721(BigInt(tokenId)))\n      .then(decodeAddress)\n      .catch(() => \"\"),\n  ])\n\n  const metadata = await fetchMetadata(metadataUrl, fetchContext)\n  const imageType = urlExtensionType(metadata.image)\n\n  return {\n    ...metadata,\n    imageType,\n    metadataUrl,\n    owner,\n  }\n}\n","import type {\n  Address,\n  FetchContext,\n  ImageProxyFn,\n  NftMetadata,\n} from \"../../types\"\nimport type {\n  EthereumFetcher,\n  EthereumFetcherConfig,\n  EthereumFetcherConfigDeclaration,\n} from \"./types\"\n\nimport { isAddress } from \"../../utils\"\nimport { cryptoPunksMetadata, isCryptoPunks } from \"../shared/cryptopunks\"\nimport { cryptoKittiesMetadata, isCryptoKitties } from \"../shared/cryptokitties\"\nimport {\n  decentralandEstateMetadata,\n  isDecentralandEstate,\n} from \"../shared/decentraland-estate\"\nimport {\n  decentralandParcelMetadata,\n  isDecentralandParcel,\n} from \"../shared/decentraland-parcel\"\nimport { isMoonCats, moonCatsMetadata } from \"../shared/mooncats\"\nimport { cryptoPunksImage } from \"./cryptopunks\"\nimport { moonCatsCatId } from \"./mooncats\"\nimport { fetchStandardNftContractData } from \"./standard-nft\"\n\nasync function fetchNftMetadata(\n  contractAddress: Address,\n  tokenId: string,\n  config: EthereumFetcherConfig,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  if (isDecentralandParcel(contractAddress)) {\n    return decentralandParcelMetadata(tokenId)\n  }\n\n  if (isDecentralandEstate(contractAddress)) {\n    return decentralandEstateMetadata(tokenId)\n  }\n\n  if (isCryptoKitties(contractAddress)) {\n    return cryptoKittiesMetadata(tokenId, fetchContext)\n  }\n\n  if (isCryptoPunks(contractAddress)) {\n    return cryptoPunksMetadata(tokenId, cryptoPunksImage(config))\n  }\n\n  if (isMoonCats(contractAddress)) {\n    return moonCatsMetadata(tokenId, moonCatsCatId(config), fetchContext)\n  }\n\n  return fetchStandardNftContractData(\n    contractAddress,\n    tokenId,\n    config,\n    fetchContext\n  )\n}\n\nfunction addProxyImage(\n  metadata: NftMetadata,\n  imageProxy: ImageProxyFn\n): NftMetadata {\n  return metadata.image.startsWith(\"http\")\n    ? { ...metadata, image: imageProxy(metadata.image, metadata) }\n    : metadata\n}\n\nfunction normalizeConfig(\n  config: EthereumFetcherConfigDeclaration\n): EthereumFetcherConfig {\n  if (!config.ethereum) {\n    if (window.ethereum) {\n      config.ethereum = window.ethereum\n    } else {\n      throw new Error(\"Missing ethereum provider.\")\n    }\n  }\n  return config as EthereumFetcherConfig\n}\n\nexport default function ethereumFetcher(\n  config: EthereumFetcherConfigDeclaration\n): EthereumFetcher {\n  const _config = normalizeConfig(config)\n  return {\n    config: _config,\n    async fetchNft(\n      contractAddress: Address,\n      tokenId: string,\n      fetchContext: FetchContext\n    ): Promise<NftMetadata> {\n      if (!isAddress(contractAddress)) {\n        throw new Error(`Invalid contract address: ${contractAddress}`)\n      }\n      const metadata = await fetchNftMetadata(\n        contractAddress,\n        tokenId,\n        _config,\n        fetchContext\n      )\n      return addProxyImage(metadata, fetchContext.imageProxy)\n    },\n  }\n}\n","import type { ContractMethod } from \"../../types\"\nimport type { EthereumFetcherConfig } from \"./types\"\n\nimport { decodeString, ethCall, uint256Hex } from \"./utils\"\n\nexport function cryptoPunksImage(config: EthereumFetcherConfig) {\n  return async function cryptoPunksImage(\n    index: string,\n    method: ContractMethod\n  ): Promise<string> {\n    if (config.ethereum === undefined) {\n      throw new Error(\"No Ethereum provider\")\n    }\n    return ethCall(\n      config.ethereum,\n      method.address,\n      method.methodHash + uint256Hex(BigInt(index))\n    ).then(decodeString)\n  }\n}\n","import type { ContractMethod } from \"../../types\"\nimport type { EthereumFetcherConfig } from \"./types\"\n\nimport { ethCall, uint256Hex } from \"./utils\"\n\nexport function moonCatsCatId(config: EthereumFetcherConfig) {\n  return async function moonCatsCatId(\n    tokenId: string,\n    method: ContractMethod\n  ): Promise<string> {\n    if (config.ethereum === undefined) {\n      throw new Error(\"No Ethereum provider\")\n    }\n    const result = await ethCall(\n      config.ethereum,\n      method.address,\n      method.methodHash + uint256Hex(BigInt(tokenId))\n    )\n    return result.slice(0, 12) // 12 = 0x prefix + 5 bytes\n  }\n}\n","import type { FC, ReactNode } from \"react\"\nimport type {\n  Address,\n  FetchContext,\n  Fetcher,\n  FetcherDeclaration,\n  FetcherDeclarationEthereum,\n  FetcherDeclarationEthers,\n  FetcherProp,\n  ImageProxyFn,\n  IpfsUrlFn,\n  JsonProxyFn,\n  NftMetadata,\n  NftResult,\n  NftResultDone,\n  NftResultError,\n  NftResultLoading,\n} from \"./types\"\nimport type { EthersFetcherConfig } from \"./fetchers/ethers/types\"\nimport type { EthereumFetcherConfigDeclaration } from \"./fetchers/ethereum/types\"\n\nimport React, { createContext, useCallback, useContext, useMemo } from \"react\"\nimport useSWR, { SWRConfig, useSWRConfig } from \"swr\"\nimport ethersFetcher from \"./fetchers/ethers\"\nimport ethereumFetcher from \"./fetchers/ethereum\"\nimport { identity, ipfsUrlDefault } from \"./utils\"\n\nconst NFT_METADATA_DEFAULT = {\n  name: \"\",\n  description: \"\",\n  image: \"\",\n} as NftMetadata\n\nfunction isFetcherDeclarationEthers(\n  fetcher: FetcherProp\n): fetcher is FetcherDeclarationEthers {\n  return (\n    Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === \"ethers\"\n  )\n}\n\nfunction isFetcherDeclarationEthereum(\n  fetcher: FetcherProp\n): fetcher is FetcherDeclarationEthereum {\n  return (\n    Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === \"ethereum\"\n  )\n}\n\nfunction normalizeFetcher(fetcher: FetcherProp): Fetcher<unknown> {\n  // ethers\n  if (isFetcherDeclarationEthers(fetcher)) {\n    return ethersFetcher(fetcher[1]) as Fetcher<EthersFetcherConfig>\n  }\n\n  // ethereum\n  if (isFetcherDeclarationEthereum(fetcher)) {\n    return ethereumFetcher(\n      fetcher[1]\n    ) as Fetcher<EthereumFetcherConfigDeclaration>\n  }\n\n  // custom fetcher (or wrong value)\n  return fetcher\n}\n\nconst NftContext = createContext<{\n  fetcher: Fetcher<unknown> | null\n  imageProxy: ImageProxyFn\n  ipfsUrl: IpfsUrlFn\n  jsonProxy: JsonProxyFn\n} | null>(null)\n\nconst NftProvider: FC<{\n  children: ReactNode\n  fetcher: Fetcher<unknown> | FetcherDeclaration\n  imageProxy?: ImageProxyFn\n  ipfsUrl?: IpfsUrlFn\n  jsonProxy?: JsonProxyFn\n}> = function NftProvider({\n  children,\n  fetcher,\n  imageProxy = identity,\n  ipfsUrl = ipfsUrlDefault,\n  jsonProxy = identity,\n}) {\n  if (!fetcher) {\n    throw new Error(\"Please set the fetcher prop on <NftProvider />\")\n  }\n\n  const context = {\n    fetcher: normalizeFetcher(fetcher),\n    imageProxy,\n    ipfsUrl,\n    jsonProxy,\n  }\n\n  return (\n    <SWRConfig value={{ provider: () => new Map() }}>\n      <NftContext.Provider value={context}>{children}</NftContext.Provider>\n    </SWRConfig>\n  )\n}\n\nfunction useNft(contractAddress: Address, tokenId: string): NftResult {\n  const context = useContext(NftContext)\n  if (context === null) {\n    throw new Error(\"Please wrap your app with <NftProvider />\")\n  }\n\n  const { fetcher, imageProxy, ipfsUrl, jsonProxy } = context\n  const fetchContext = useMemo<FetchContext>(\n    () => ({ imageProxy, ipfsUrl, jsonProxy }),\n    [imageProxy, ipfsUrl, jsonProxy]\n  )\n\n  const fetchNft = useCallback(() => {\n    return fetcher\n      ? fetcher.fetchNft(contractAddress, tokenId, fetchContext)\n      : { ...NFT_METADATA_DEFAULT }\n  }, [contractAddress, fetcher, fetchContext, tokenId])\n\n  const { cache } = useSWRConfig()\n  const cached = (cache.get(contractAddress + tokenId) ?? false) as boolean\n\n  const result = useSWR<NftMetadata, Error>(\n    contractAddress + tokenId,\n    fetchNft,\n    {\n      revalidateOnMount: !cached,\n      revalidateOnFocus: false,\n      revalidateOnReconnect: false,\n    }\n  )\n\n  return useMemo(() => {\n    const { error, data, mutate } = result\n\n    const reload = () =>\n      mutate()\n        .then(() => true)\n        .catch(() => false)\n\n    if (error === undefined && data === undefined) {\n      return {\n        error: undefined,\n        loading: true,\n        nft: undefined,\n        reload,\n        status: \"loading\",\n      } as NftResultLoading\n    }\n\n    if (error !== undefined) {\n      return {\n        error,\n        loading: false,\n        nft: undefined,\n        reload,\n        status: \"error\",\n      } as NftResultError\n    }\n\n    return {\n      error: undefined,\n      loading: false,\n      nft: data as NftMetadata,\n      reload,\n      status: \"done\",\n    } as NftResultDone\n  }, [result])\n}\n\nexport { useNft, NftProvider }\n","import type {\n  Address,\n  FetchContext,\n  Fetcher,\n  FetcherDeclaration,\n  FetcherDeclarationEthereum,\n  FetcherDeclarationEthers,\n  FetcherProp,\n  ImageProxyFn,\n  IpfsUrlFn,\n  JsonProxyFn,\n  NftMetadata,\n} from \"./types\"\nimport type { EthersFetcherConfig } from \"./fetchers/ethers/types\"\nimport type { EthereumFetcherConfig } from \"./fetchers/ethereum/types\"\n\nimport { identity, ipfsUrlDefault } from \"./utils\"\nimport ethersFetcher from \"./fetchers/ethers\"\nimport ethereumFetcher from \"./fetchers/ethereum\"\n\ntype FetchWrapperOptions = {\n  imageProxy?: ImageProxyFn\n  ipfsUrl?: IpfsUrlFn\n  jsonProxy?: JsonProxyFn\n}\n\nconst NFT_METADATA_DEFAULT = {\n  name: \"\",\n  description: \"\",\n  image: \"\",\n} as NftMetadata\n\nexport class FetchWrapper {\n  private fetcher: Fetcher<unknown>\n  private fetchContext: FetchContext\n\n  constructor(\n    fetcher: Fetcher<unknown> | FetcherDeclaration,\n    options: FetchWrapperOptions = {}\n  ) {\n    this.fetcher = this.normalizeFetcher(fetcher)\n    this.fetchContext = this.fetchContextFromOptions(options)\n  }\n\n  private fetchContextFromOptions({\n    imageProxy,\n    ipfsUrl,\n    jsonProxy,\n  }: FetchWrapperOptions): FetchContext {\n    return {\n      imageProxy: imageProxy ?? identity,\n      ipfsUrl: ipfsUrl ?? ipfsUrlDefault,\n      jsonProxy: jsonProxy ?? identity,\n    }\n  }\n\n  private normalizeFetcher(fetcher: FetcherProp): Fetcher<unknown> {\n    // default fetcher\n    if (!fetcher) {\n      return {\n        config: {},\n        fetchNft: () => Promise.resolve(NFT_METADATA_DEFAULT),\n      } as Fetcher<Record<string, never>>\n    }\n\n    // ethers\n    if (this.isFetcherDeclarationEthers(fetcher)) {\n      return ethersFetcher(fetcher[1]) as Fetcher<EthersFetcherConfig>\n    }\n\n    // ethereum\n    if (this.isFetcherDeclarationEthereum(fetcher)) {\n      return ethereumFetcher(fetcher[1]) as Fetcher<EthereumFetcherConfig>\n    }\n\n    // custom fetcher (or wrong value)\n    return fetcher\n  }\n\n  private isFetcherDeclarationEthers(\n    fetcher: FetcherProp\n  ): fetcher is FetcherDeclarationEthers {\n    return (\n      Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === \"ethers\"\n    )\n  }\n\n  private isFetcherDeclarationEthereum(\n    fetcher: FetcherProp\n  ): fetcher is FetcherDeclarationEthereum {\n    return (\n      Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === \"ethereum\"\n    )\n  }\n\n  public async fetchNft(\n    contractAddress: Address,\n    tokenId: string\n  ): Promise<NftMetadata> {\n    return await this.fetcher.fetchNft(\n      contractAddress,\n      tokenId,\n      this.fetchContext\n    )\n  }\n}\n"],"names":["RARIBLE_MATCH_RE","isAddress","value","test","identity","arg","parseNftUrl","url","raribleMatch","exec","ipfsUrlDefault","cid","path","IPFS_PROTOCOL_RE","IPFS_HASH_RE","ipfsUrlFromString","ipfsString","ipfsUrl","ipfsProtocolMatch","normalizeTokenUrl","tokenId","fetchContext","_url","URL","host","pathname","includes","replace","searchParams","set","String","err","normalizeOpenSeaUrl","normalizeNiftyGatewayUrl","startsWith","jsonProxy","normalizeImageUrl","addressesEqual","addr1","addr2","toLowerCase","promiseAny","promises","reversePromise","Promise","all","map","promise","resolve","reject","then","MultipleErrors","Error","constructor","message","errors","super","this","name","IMAGE_EXT_RE","VIDEO_EXT_RE","urlExtensionType","CRYPTOPUNKS_IMAGE_SVG","address","methodName","methodHash","humanReadableAbi","encodeUriData","dataUri","dataStart","indexOf","slice","encodeURIComponent","cryptoPunksMetadata","index","cryptoPunksImage","description","image","imageType","metadataUrl","owner","rawData","isCryptoPunks","contractAddress","cryptoKittiesMetadata","id","res","fetch","data","json","image_url","bio","isCryptoKitties","body","JSON","stringify","operationName","variables","query","decentralandEstateMetadata","response","method","nft","nfts","_data$nfts","estate","_nft$estate","_nft$estate$data","_nft$owner","isDecentralandEstate","decentralandParcelMetadata","parcel","_parcel$data","x","y","isDecentralandParcel","MOONCATS_WRAPPED","moonCatsMetadata","getCatId","catId","src","scale","padding","width","naturalWidth","height","naturalHeight","_padding","Math","max","canvas","document","createElement","ctx","getContext","imageSmoothingEnabled","drawImage","toDataURL","frameImage","Image","crossOrigin","onload","onerror","error","imageUrl","isMoonCats","fetchMetadata","ok","title","type","properties","_data$properties","_data$properties$name","_data$properties2","_data$properties2$ima","_data$properties3","_data$properties3$des","isNftMetadataMixedInJsonSchema","fixNftMetadataMixedInJsonSchema","fixIncorrectImageField","isNftMetadata","normalizeNftMetadata","ABI","async","contract","tokenURI","uri","catch","ethersFetcher","config","metadata","configWithEthersLoaded","ethers","_config$ethers","Contract","loadEthers","provider","punkImageSvg","wrappedContract","result","_tokenIDToCatID","moonCatsCatId","ownerOf","fetchStandardNftContractData","fetchNftMetadata","imageProxy","uint256Hex","i","BigInt","toString","bytesToBigInt","bytes","byte","hexToUint8Array","hex","Uint8Array","match","parseInt","decodeString","pointer","Number","subarray","length","TextDecoder","decode","decodeAddress","decoded","methodUriErc721","methodOwnerOfErc721","ethCall","ethereum","to","request","params","uriMethods","ethereumFetcher","_config","window","normalizeConfig","undefined","NFT_METADATA_DEFAULT","normalizeFetcher","fetcher","Array","isArray","isFetcherDeclarationEthers","isFetcherDeclarationEthereum","NftContext","createContext","NftProvider","children","context","React","SWRConfig","Map","Provider","useNft","useContext","useMemo","fetchNft","useCallback","cache","useSWRConfig","cached","get","useSWR","revalidateOnMount","revalidateOnFocus","revalidateOnReconnect","mutate","reload","loading","status","FetchWrapper","options","fetchContextFromOptions"],"mappings":"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"}