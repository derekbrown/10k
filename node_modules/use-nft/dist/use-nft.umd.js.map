{"version":3,"file":"use-nft.umd.js","sources":["../src/utils.tsx","../src/known-contracts.tsx","../src/fetchers/shared/cryptopunks.ts","../src/fetchers/shared/cryptokitties.ts","../src/fetchers/shared/decentraland-estate.tsx","../src/fetchers/shared/decentraland-parcel.tsx","../src/fetchers/shared/mooncats.ts","../src/fetchers/shared/fetch-metadata.tsx","../src/fetchers/ethers/standard-nft.tsx","../src/fetchers/ethers/index.tsx","../src/fetchers/ethers/cryptopunks.ts","../src/fetchers/ethers/mooncats.ts","../src/fetchers/ethereum/utils.ts","../src/fetchers/ethereum/standard-nft.tsx","../src/fetchers/ethereum/index.tsx","../src/fetchers/ethereum/cryptopunks.ts","../src/fetchers/ethereum/mooncats.ts","../src/core.tsx","../src/fetchWrapper.ts"],"sourcesContent":["import type {\n  Address,\n  FetchContext,\n  IpfsUrlFn,\n  NftJsonMetadata,\n  NftMetadata,\n} from \"./types\"\n\n// Some NFT minting services misinterpreted the JSON schema from the EIP as\n// literal JSON, e.g. portion.io:\n// https://ipfs.io/ipfs/QmNt5T9HSXKLXZ3kmciU4Tm6q9R8JEm5ifJkPoxapjyRUR\ntype NftMetadataMixedInJsonSchema = {\n  title: string\n  type: \"object\"\n  properties: {\n    name: { type: \"string\"; description: string }\n    image: { type: \"string\"; description: string }\n    description: { type: \"string\"; description: string }\n  }\n}\n\nconst RARIBLE_MATCH_RE =\n  /^https:\\/\\/rarible\\.com\\/token\\/(0x[a-fA-F0-9]{40}):([0-9]+)/\n\nexport function isAddress(value: string): value is Address {\n  return /^0x[a-fA-F0-9]{40}$/.test(value)\n}\n\nexport function identity<T = unknown>(arg: T): T {\n  return arg\n}\n\nexport function parseNftUrl(url: string): [string, string] | null {\n  const raribleMatch = RARIBLE_MATCH_RE.exec(url)\n  if (raribleMatch) {\n    return [raribleMatch[1], raribleMatch[2]]\n  }\n  return null\n}\n\nexport function fetchImage(src: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const image = new Image()\n    image.src = src\n    image.crossOrigin = \"\"\n    image.onload = () => resolve(image)\n    image.onerror = (error) => reject(error)\n  })\n}\n\n// Scale the image and add some extra padding. Returns the image as base64.\n// The padding and scale are expressed as proportions of the image size.\nexport function frameImage(\n  image: HTMLImageElement,\n  { scale = 1, padding = 0 } = {}\n): string | null {\n  const width = image.naturalWidth * scale\n  const height = image.naturalHeight * scale\n  const _padding = Math.max(width * padding, height * padding)\n\n  const canvas = document.createElement(\"canvas\")\n  canvas.width = width + _padding * 2\n  canvas.height = height + _padding * 2\n\n  const ctx = canvas.getContext(\"2d\")\n  if (ctx === null) {\n    return null\n  }\n\n  ctx.imageSmoothingEnabled = false\n  ctx.drawImage(image, _padding, _padding, width, height)\n\n  return canvas.toDataURL()\n}\n\nexport function ipfsUrlDefault(cid: string, path = \"\"): string {\n  return `https://ipfs.io/ipfs/${cid}${path}`\n}\n\nconst IPFS_PROTOCOL_RE = /^ipfs:\\/\\/(?:ipfs\\/)?([^/]+)(\\/.+)?$/\nconst IPFS_HASH_RE = /^Qm[1-9A-HJ-NP-Za-km-z]{44}$/\n\nexport function ipfsUrlFromString(\n  ipfsString: string,\n  ipfsUrl: IpfsUrlFn\n): string {\n  // ipfs:// URI\n  const ipfsProtocolMatch = IPFS_PROTOCOL_RE.exec(ipfsString)\n  if (ipfsProtocolMatch) {\n    const [, cid, path = \"\"] = ipfsProtocolMatch\n    return ipfsUrl(cid, path)\n  }\n\n  // standalone cid, probably\n  if (IPFS_HASH_RE.test(ipfsString)) {\n    return ipfsUrl(ipfsString)\n  }\n\n  // maybe URL\n  return ipfsString\n}\n\nexport function normalizeOpenSeaUrl(url: string, tokenId: string): string {\n  // url can be anything so we need to try / catch to pass it to new URL()\n  try {\n    const _url = new URL(url)\n\n    // 0x%7Bid%7D\" = 0x{id} (url encoded)\n    if (\n      (_url.host !== \"api.opensea.io\" &&\n        _url.host !== \"testnets-api.opensea.io\") ||\n      !_url.pathname.includes(\"0x%7Bid%7D\")\n    ) {\n      return url\n    }\n\n    _url.pathname = _url.pathname.replace(/0x%7Bid%7D/g, tokenId)\n    _url.searchParams.set(\"format\", \"json\")\n\n    return String(_url)\n  } catch (err) {\n    return url\n  }\n}\n\nexport function normalizeNiftyGatewayUrl(url: string): string {\n  try {\n    const _url = new URL(url)\n\n    if (_url.host !== \"api.niftygateway.com\") {\n      return url\n    }\n\n    // Without final slash, the Nifty Gateway API server\n    // doesn’t set the CORS headers properly.\n    _url.pathname = _url.pathname + \"/\"\n    return String(_url)\n  } catch (err) {\n    return url\n  }\n}\n\nexport function normalizeTokenUrl(\n  url: string,\n  tokenId: string,\n  fetchContext: FetchContext\n): string {\n  url = normalizeOpenSeaUrl(url, tokenId)\n  url = normalizeNiftyGatewayUrl(url)\n  url = ipfsUrlFromString(url, fetchContext.ipfsUrl)\n\n  if (url.startsWith(\"http\")) {\n    url = fetchContext.jsonProxy(url)\n  }\n\n  return url\n}\n\nexport function normalizeImageUrl(\n  url: string,\n  fetchContext: FetchContext\n): string {\n  return ipfsUrlFromString(url, fetchContext.ipfsUrl)\n}\n\nexport function normalizeNftMetadata(\n  data: NftJsonMetadata,\n  fetchContext: FetchContext\n): NftJsonMetadata {\n  return {\n    ...data,\n    image: normalizeImageUrl(data.image, fetchContext),\n  }\n}\n\nexport function fixIncorrectImageField(\n  data: Record<string, unknown>\n): Record<string, unknown> {\n  if (!data || typeof data !== \"object\") {\n    return data\n  }\n\n  const _data = data as {\n    image: string\n    imageUrl: string\n  }\n\n  // makersplace.com is using `imageUrl` rather than `image`\n  if (\n    typeof _data?.image === \"undefined\" &&\n    typeof _data?.imageUrl === \"string\"\n  ) {\n    return { ..._data, image: _data?.imageUrl }\n  }\n\n  return data\n}\n\n// See NftMetadataMixedInJsonSchema for why this is needed.\nexport function isNftMetadataMixedInJsonSchema(\n  data: unknown\n): data is NftMetadataMixedInJsonSchema {\n  if (!data || typeof data !== \"object\") {\n    return false\n  }\n  const _data = data as NftMetadataMixedInJsonSchema\n  return (\n    _data.title === \"Asset Metadata\" &&\n    _data.type === \"object\" &&\n    typeof _data.properties?.name?.description === \"string\" &&\n    typeof _data.properties?.image?.description === \"string\" &&\n    typeof _data.properties?.description?.description === \"string\" &&\n    _data.properties?.name?.type === \"string\" &&\n    _data.properties?.image?.type === \"string\" &&\n    _data.properties?.description?.type === \"string\"\n  )\n}\n\nexport function fixNftMetadataMixedInJsonSchema(\n  data: NftMetadataMixedInJsonSchema\n): NftJsonMetadata {\n  return {\n    name: data.properties?.name?.description || \"\",\n    description: data.properties?.description?.description || \"\",\n    image: data.properties?.image?.description || \"\",\n    rawData: { ...data },\n  }\n}\n\nexport function isNftMetadata(data: unknown): data is NftMetadata {\n  if (!data || typeof data !== \"object\") {\n    return false\n  }\n  const _data = data as NftMetadata\n\n  // We don’t test for the exact type here, because some NFT minting services\n  // set some of the fields as null.\n  // We also only test for the presence of either `name` or `image`, as some\n  // NFT formats don’t declare them all (e.g. BAYC only declares `image`).\n  return \"name\" in _data || \"image\" in _data\n}\n\nexport function addressesEqual(addr1: Address, addr2: Address): boolean {\n  return addr1?.toLowerCase() === addr2?.toLowerCase()\n}\n\n// Promise.any() implementation from https://github.com/m0ppers/promise-any\nexport function promiseAny<T>(promises: Promise<T>[]): Promise<T> {\n  return reversePromise(\n    Promise.all([...promises].map(reversePromise))\n  ) as Promise<T>\n}\nexport function reversePromise(promise: Promise<unknown>): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    Promise.resolve(promise).then(reject, resolve)\n  })\n}\n\n// To replace with AggregateError when useNft() will target ES2021 environments\nexport class MultipleErrors extends Error {\n  errors: Error[]\n  constructor(message: string, errors: Error[]) {\n    super(message)\n    this.name = \"MultipleErrors\"\n    this.errors = errors\n  }\n}\n\nconst IMAGE_EXT_RE = /\\.(?:png|svg|jpg|jepg|gif|webp|jxl|avif)$/\nconst VIDEO_EXT_RE = /\\.(?:mp4|mov|webm|ogv)$/\n\n// Guess a file type from the extension used in a URL\nexport function urlExtensionType(url: string): NftMetadata[\"imageType\"] {\n  if (IMAGE_EXT_RE.test(url)) return \"image\"\n  if (VIDEO_EXT_RE.test(url)) return \"video\"\n  return \"unknown\"\n}\n","export const CRYPTOKITTIES = \"0x06012c8cf97BEaD5deAe237070F9587f8E7A266d\"\nexport const CRYPTOPUNKS = \"0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb\"\nexport const CRYPTOPUNKS_IMAGES = \"0x16F5A35647D6F03D5D3da7b35409D65ba03aF3B2\"\nexport const CRYPTOVOXELS = \"0x79986aF15539de2db9A5086382daEdA917A9CF0C\"\nexport const DECENTRALAND_ESTATE = \"0x959e104E1a4dB6317fA58F8295F586e1A978c297\"\nexport const DECENTRALAND_PARCEL = \"0xf87e31492faf9a91b02ee0deaad50d51d56d5d4d\"\n","import type { Address, ContractMethod, NftMetadata } from \"../../types\"\n\nimport { CRYPTOPUNKS, CRYPTOPUNKS_IMAGES } from \"../../known-contracts\"\nimport { addressesEqual } from \"../../utils\"\n\nconst CRYPTOPUNKS_DESCRIPTION = `\n  10,000 unique collectible characters with proof of ownership stored on the\n  Ethereum blockchain. The project that inspired the modern CryptoArt movement.\n  The first \"Non-Fungible Token,\" and inspiration for the Ethereum ERC-721\n  standard that powers most digital art and collectibles.\n`\n\nconst CRYPTOPUNKS_IMAGE_SVG: ContractMethod = {\n  address: CRYPTOPUNKS_IMAGES,\n  methodName: \"punkImageSvg\",\n  methodHash: \"0x74beb047\",\n  humanReadableAbi: [\n    \"function punkImageSvg(uint16 index) view returns (string svg)\",\n  ],\n}\n\nfunction encodeUriData(dataUri: string): string {\n  const dataStart = dataUri.indexOf(\",\") + 1\n  return (\n    dataUri.slice(0, dataStart) +\n      encodeURIComponent(dataUri.slice(dataStart)) ?? \"\"\n  )\n}\n\nexport async function cryptoPunksMetadata(\n  index: string,\n  cryptoPunksImage: (tokenId: string, method: ContractMethod) => Promise<string>\n): Promise<NftMetadata> {\n  const image = await cryptoPunksImage(index, CRYPTOPUNKS_IMAGE_SVG)\n\n  return {\n    description: CRYPTOPUNKS_DESCRIPTION,\n    image: encodeUriData(image),\n    imageType: \"image\",\n    metadataUrl: \"\",\n    name: `CryptoPunk ${index}`,\n    owner: \"\",\n    rawData: null,\n  }\n}\n\nexport function isCryptoPunks(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, CRYPTOPUNKS)\n}\n","import type { Address, FetchContext, NftMetadata } from \"../../types\"\n\nimport { CRYPTOKITTIES } from \"../../known-contracts\"\nimport { addressesEqual } from \"../../utils\"\n\nexport async function cryptoKittiesMetadata(\n  id: string,\n  { jsonProxy }: FetchContext\n): Promise<NftMetadata> {\n  const metadataUrl = jsonProxy(`https://api.cryptokitties.co/v3/kitties/${id}`)\n  const res = await fetch(metadataUrl)\n  const data = (await res.json()) as {\n    name: string\n    bio: string\n    image_url: string\n  }\n  const image = data?.image_url ?? \"\"\n  return {\n    description: data?.bio ?? \"−\",\n    image,\n    imageType: image ? \"image\" : \"unknown\",\n    metadataUrl,\n    name: data?.name ?? \"Unknown\",\n    owner: \"\",\n    rawData: data,\n  }\n}\n\nexport function isCryptoKitties(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, CRYPTOKITTIES)\n}\n","import type { Address, NftMetadata } from \"../../types\"\n\nimport { DECENTRALAND_ESTATE } from \"../../known-contracts\"\nimport { addressesEqual } from \"../../utils\"\n\nconst ENDPOINT =\n  \"https://api.thegraph.com/subgraphs/name/decentraland/marketplace\"\n\nconst QUERY = `\n  query NFTByTokenId($contractAddress: String, $tokenId: String) {\n    nfts(\n      where: { contractAddress: $contractAddress, tokenId: $tokenId }\n      first: 1\n    ) {\n      name\n      image\n      owner {\n        address\n      }\n      estate {\n        size\n        data {\n          description\n        }\n      }\n    }\n  }\n`\n\nfunction body(contractAddress: string, tokenId: string) {\n  return JSON.stringify({\n    operationName: \"NFTByTokenId\",\n    variables: { contractAddress, tokenId },\n    query: QUERY,\n  })\n}\n\nexport async function decentralandEstateMetadata(\n  tokenId: string\n): Promise<NftMetadata> {\n  const response = await fetch(ENDPOINT, {\n    body: body(DECENTRALAND_ESTATE, tokenId),\n    method: \"POST\",\n  })\n\n  const { data } = (await response.json()) as {\n    data: {\n      nfts: [\n        {\n          name: string\n          image: string\n          owner: { address: Address }\n          estate: {\n            size: number\n            data: { description: string }\n          }\n        }\n      ]\n    }\n  }\n\n  const nft = data?.nfts?.[0]\n  const image = nft?.image ?? \"\"\n\n  return {\n    description: nft?.estate?.data?.description ?? \"−\",\n    image,\n    imageType: image ? \"image\" : \"unknown\",\n    metadataUrl: \"\",\n    name: nft?.name ?? \"Unknown\",\n    owner: nft?.owner?.address ?? \"\",\n    rawData: data,\n  }\n}\n\nexport function isDecentralandEstate(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, DECENTRALAND_ESTATE)\n}\n","import type { Address, NftMetadata } from \"../../types\"\n\nimport { DECENTRALAND_PARCEL } from \"../../known-contracts\"\nimport { addressesEqual } from \"../../utils\"\n\nconst ENDPOINT =\n  \"https://api.thegraph.com/subgraphs/name/decentraland/marketplace\"\n\nconst QUERY = `\n  query NFTByTokenId($contractAddress: String, $tokenId: String) {\n    nfts(\n      where: { contractAddress: $contractAddress, tokenId: $tokenId }\n      first: 1\n    ) {\n      name\n      image\n      owner {\n        address\n      }\n      parcel {\n        x\n        y\n        data {\n          description\n        }\n      }\n    }\n  }\n`\n\nfunction body(contractAddress: string, tokenId: string) {\n  return JSON.stringify({\n    operationName: \"NFTByTokenId\",\n    variables: { contractAddress, tokenId },\n    query: QUERY,\n  })\n}\n\nexport async function decentralandParcelMetadata(\n  tokenId: string\n): Promise<NftMetadata> {\n  const response = await fetch(ENDPOINT, {\n    body: body(DECENTRALAND_PARCEL, tokenId),\n    method: \"POST\",\n  })\n\n  const { data } = (await response.json()) as {\n    data: {\n      nfts: [\n        {\n          name: string\n          image: string\n          owner: { address: Address }\n          parcel: {\n            x: number\n            y: number\n            data: {\n              description: string\n            }\n          }\n        }\n      ]\n    }\n  }\n\n  const nft = data?.nfts?.[0]\n  const parcel = nft?.parcel\n  const image = nft?.image ?? \"\"\n\n  return {\n    description: parcel?.data?.description ?? \"-\",\n    image,\n    imageType: image ? \"image\" : \"unknown\",\n    metadataUrl: \"\",\n    name: nft?.name ?? `Parcel ${parcel?.x},${parcel?.y}`,\n    owner: nft?.owner?.address ?? \"\",\n    rawData: data,\n  }\n}\n\nexport function isDecentralandParcel(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, DECENTRALAND_PARCEL)\n}\n","import type {\n  Address,\n  ContractMethod,\n  FetchContext,\n  IpfsUrlFn,\n  NftMetadata,\n} from \"../../types\"\n\nimport {\n  addressesEqual,\n  fetchImage,\n  frameImage,\n  ipfsUrlFromString,\n} from \"../../utils\"\n\nconst MOONCATS_WRAPPED: ContractMethod = {\n  address: \"0x7c40c393dc0f283f318791d746d894ddd3693572\",\n  methodName: \"_tokenIDToCatID\",\n  methodHash: \"0xfe294644\",\n  humanReadableAbi: [\n    \"function _tokenIDToCatID(uint256 tokenId) view returns (bytes5 catId)\",\n  ],\n}\n\n// See https://www.reddit.com/r/MoonCatRescue/comments/m5d7mx/svg_imagery_of_all_rescued_mooncats/\nconst MOONCATS_IPFS_CID =\n  \"bafybeidk4zunuq56w2pf2sncexohlyqae62dzplljkbwswa7jwywh2dava\"\n\nexport async function imageUrl(\n  catId: string,\n  ipfsUrl: IpfsUrlFn\n): Promise<string | null> {\n  const dir = catId.slice(4, 6)\n  const url = ipfsUrlFromString(\n    `ipfs://ipfs/${MOONCATS_IPFS_CID}/${dir}/${catId}.png`,\n    ipfsUrl\n  )\n  const image = await fetchImage(url)\n\n  // Here we increase the resolution of the MoonCats PNG files (4x without\n  // antialias) and add a some padding around it. Doing this image manipulation\n  // rather than using CSS is needed because useNft() only deals with data and\n  // doesn’t have any control over how the images get displayed.\n  return frameImage(image, { scale: 4, padding: 0.125 })\n}\n\nexport async function moonCatsMetadata(\n  tokenId: string,\n  getCatId: (tokenId: string, method: ContractMethod) => Promise<string>,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  const catId = await getCatId(tokenId, MOONCATS_WRAPPED)\n\n  const image = (await imageUrl(catId, fetchContext.ipfsUrl)) ?? \"\"\n  return {\n    description:\n      `The (unofficial) wrapped version of MoonCats Rescue. ` +\n      `Original cat ID: ${catId}.`,\n    image,\n    imageType: image ? \"image\" : \"unknown\",\n    metadataUrl: \"\",\n    name: `Wrapped MoonCat #${tokenId}`,\n    owner: \"\",\n    rawData: null,\n  }\n}\n\nexport function isMoonCats(contractAddress: Address): boolean {\n  return addressesEqual(contractAddress, MOONCATS_WRAPPED.address)\n}\n","import type { FetchContext, NftJsonMetadata } from \"../../types\"\n\nimport {\n  fixIncorrectImageField,\n  fixNftMetadataMixedInJsonSchema,\n  isNftMetadata,\n  isNftMetadataMixedInJsonSchema,\n  normalizeNftMetadata,\n} from \"../../utils\"\n\nexport async function fetchMetadata(\n  url: string,\n  fetchContext: FetchContext\n): Promise<NftJsonMetadata> {\n  const res = await fetch(url)\n\n  if (!res.ok) {\n    throw new Error(\"Error when trying to request \" + url)\n  }\n\n  let rawData\n\n  try {\n    rawData = (await res.json()) as Record<string, unknown>\n  } catch (err) {\n    // If it can’t be parsed as JSON, it must be an image URL\n    rawData = { name: \"\", description: \"\", image: url }\n  }\n\n  let data = { ...rawData }\n\n  if (isNftMetadataMixedInJsonSchema(data)) {\n    data = fixNftMetadataMixedInJsonSchema(data)\n  }\n\n  data = fixIncorrectImageField(data)\n\n  if (!isNftMetadata(data)) {\n    throw new Error(\"Invalid data received\")\n  }\n\n  return normalizeNftMetadata(\n    {\n      description: data.description || \"\",\n      image: data.image || \"\",\n      name: data.name || \"\",\n      rawData,\n    },\n    fetchContext\n  )\n}\n","import type { Contract, ContractFunction } from \"@ethersproject/contracts\"\nimport type { Address, FetchContext, NftMetadata } from \"../../types\"\nimport type { EthersFetcherConfigEthersLoaded } from \"./types\"\n\nimport { fetchMetadata } from \"../shared/fetch-metadata\"\nimport {\n  MultipleErrors,\n  normalizeTokenUrl,\n  promiseAny,\n  urlExtensionType,\n} from \"../../utils\"\n\nconst ABI = [\n  // ERC-721\n  \"function tokenURI(uint256 _tokenId) external view returns (string)\",\n  \"function ownerOf(uint256 _tokenId) external view returns (address)\",\n  // ERC-1155\n  \"function uri(uint256 _id) external view returns (string)\",\n]\n\ntype NftContract = InstanceType<typeof Contract> & {\n  ownerOf: ContractFunction<string>\n  tokenURI: ContractFunction<string>\n  uri: ContractFunction<string>\n}\n\nasync function url(\n  contract: NftContract,\n  tokenId: string,\n  fetchContext: FetchContext\n): Promise<string> {\n  const uri = await promiseAny([\n    contract.tokenURI(tokenId),\n    contract.uri(tokenId),\n  ]).catch((errors) => {\n    throw new MultipleErrors(\n      \"An error occurred while trying to fetch the token URI from the NFT\" +\n        \" contract. See the “errors” property on this error for details.\",\n      errors\n    )\n  })\n  return normalizeTokenUrl(uri, tokenId, fetchContext)\n}\n\nexport async function fetchStandardNftContractData(\n  contractAddress: Address,\n  tokenId: string,\n  config: EthersFetcherConfigEthersLoaded,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  const contract = new config.ethers.Contract(\n    contractAddress,\n    ABI,\n    config.provider\n  ) as NftContract\n\n  const [metadataUrl, owner] = await Promise.all([\n    url(contract, tokenId, fetchContext),\n    contract.ownerOf(tokenId).catch(() => \"\"),\n  ])\n\n  const metadata = await fetchMetadata(metadataUrl, fetchContext)\n  const imageType = urlExtensionType(metadata.image)\n\n  return {\n    ...metadata,\n    imageType,\n    metadataUrl,\n    owner,\n  }\n}\n","import type {\n  Address,\n  FetchContext,\n  ImageProxyFn,\n  NftMetadata,\n} from \"../../types\"\nimport type {\n  EthersFetcher,\n  EthersFetcherConfig,\n  EthersFetcherConfigEthersLoaded,\n} from \"./types\"\n\nimport { isAddress } from \"../../utils\"\nimport { cryptoPunksMetadata, isCryptoPunks } from \"../shared/cryptopunks\"\nimport { cryptoKittiesMetadata, isCryptoKitties } from \"../shared/cryptokitties\"\nimport {\n  decentralandEstateMetadata,\n  isDecentralandEstate,\n} from \"../shared/decentraland-estate\"\nimport {\n  decentralandParcelMetadata,\n  isDecentralandParcel,\n} from \"../shared/decentraland-parcel\"\nimport { isMoonCats, moonCatsMetadata } from \"../shared/mooncats\"\nimport { cryptoPunksImage } from \"./cryptopunks\"\nimport { moonCatsCatId } from \"./mooncats\"\nimport { fetchStandardNftContractData } from \"./standard-nft\"\n\nconst ETHERS_NOT_FOUND =\n  \"Ethers couldn’t be imported. \" +\n  \"Please add the ethers module to your project dependencies, \" +\n  \"or inject it in the Ethers fetcher options.\"\n\nasync function loadEthers(\n  config: EthersFetcherConfig\n): Promise<EthersFetcherConfigEthersLoaded> {\n  if (config.ethers?.Contract) {\n    return config as EthersFetcherConfigEthersLoaded\n  }\n\n  try {\n    const ethers = await import(\"@ethersproject/contracts\")\n    if (!ethers?.Contract) {\n      throw new Error()\n    }\n    return { ...config, ethers }\n  } catch (err) {\n    throw new Error(ETHERS_NOT_FOUND)\n  }\n}\n\nasync function fetchNftMetadata(\n  contractAddress: Address,\n  tokenId: string,\n  config: EthersFetcherConfig,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  if (isDecentralandParcel(contractAddress)) {\n    return decentralandParcelMetadata(tokenId)\n  }\n\n  if (isDecentralandEstate(contractAddress)) {\n    return decentralandEstateMetadata(tokenId)\n  }\n\n  if (isCryptoKitties(contractAddress)) {\n    return cryptoKittiesMetadata(tokenId, fetchContext)\n  }\n\n  const configWithEthersLoaded = await loadEthers(config)\n\n  if (isCryptoPunks(contractAddress)) {\n    return cryptoPunksMetadata(\n      tokenId,\n      cryptoPunksImage(configWithEthersLoaded)\n    )\n  }\n\n  if (isMoonCats(contractAddress)) {\n    return moonCatsMetadata(\n      tokenId,\n      moonCatsCatId(configWithEthersLoaded),\n      fetchContext\n    )\n  }\n\n  return fetchStandardNftContractData(\n    contractAddress,\n    tokenId,\n    configWithEthersLoaded,\n    fetchContext\n  )\n}\n\nfunction addProxyImage(\n  metadata: NftMetadata,\n  imageProxy: ImageProxyFn\n): NftMetadata {\n  return metadata.image.startsWith(\"http\")\n    ? { ...metadata, image: imageProxy(metadata.image, metadata) }\n    : metadata\n}\n\nexport default function ethersFetcher(\n  config: EthersFetcherConfig\n): EthersFetcher {\n  return {\n    config,\n    async fetchNft(\n      contractAddress: Address,\n      tokenId: string,\n      fetchContext: FetchContext\n    ): Promise<NftMetadata> {\n      if (!isAddress(contractAddress)) {\n        throw new Error(`Invalid contract address: ${contractAddress}`)\n      }\n      const metadata = await fetchNftMetadata(\n        contractAddress,\n        tokenId,\n        config,\n        fetchContext\n      )\n      return addProxyImage(metadata, fetchContext.imageProxy)\n    },\n  }\n}\n","import type { Contract, ContractFunction } from \"@ethersproject/contracts\"\nimport type { ContractMethod } from \"../../types\"\nimport type { EthersFetcherConfigEthersLoaded } from \"./types\"\n\nexport function cryptoPunksImage(config: EthersFetcherConfigEthersLoaded) {\n  return async function cryptoPunksImage(\n    index: string,\n    method: ContractMethod\n  ): Promise<string> {\n    const contract = new config.ethers.Contract(\n      method.address,\n      method.humanReadableAbi,\n      config.provider\n    ) as InstanceType<typeof Contract> & {\n      punkImageSvg: ContractFunction<string>\n    }\n    return contract.punkImageSvg(index)\n  }\n}\n","import type { Contract, ContractFunction } from \"@ethersproject/contracts\"\nimport type { ContractMethod } from \"../../types\"\nimport type { EthersFetcherConfigEthersLoaded } from \"./types\"\n\nexport function moonCatsCatId(config: EthersFetcherConfigEthersLoaded) {\n  return async function moonCatsCatId(\n    tokenId: string,\n    method: ContractMethod\n  ): Promise<string> {\n    const wrappedContract = new config.ethers.Contract(\n      method.address,\n      method.humanReadableAbi,\n      config.provider\n    ) as InstanceType<typeof Contract> & {\n      _tokenIDToCatID: ContractFunction<string>\n    }\n    const result = await wrappedContract._tokenIDToCatID(tokenId)\n    return result ?? \"\"\n  }\n}\n","import type { Address } from \"../../types\"\nimport type { EthereumProviderEip1193 } from \"./types\"\n\n// Pre encoded method names to avoid embedding a keccak256 library.\n// See https://docs.soliditylang.org/en/v0.5.3/abi-spec.html#function-selector-and-argument-encoding\nconst URI_METHOD_ERC721 = \"0xc87b56dd\" // tokenURI(uint256)\nconst URI_METHOD_ERC1155 = \"0x0e89341c\" // uri(uint256)\nconst OWNER_OF_METHOD_ERC721 = \"0x6352211e\" // ownerOf(uint256)\n\n// Utilities adapted from https://github.com/Zoltu/ethereum-abi-encoder/\nexport function uint256Hex(value: bigint): string {\n  let result = \"\"\n  for (let i = 0; i < 32; ++i) {\n    result += (\n      \"0\" + ((value >> BigInt(8 * 32 - i * 8 - 8)) & BigInt(255)).toString(16)\n    ).slice(-2)\n  }\n  return result\n}\n\nexport function bytesToBigInt(bytes: Uint8Array): bigint {\n  let value = BigInt(0)\n  for (const byte of bytes) {\n    value = (value << BigInt(8)) + BigInt(byte)\n  }\n  return value\n}\n\nexport function hexToUint8Array(hex: string): Uint8Array {\n  hex = hex.replace(/^0x/, \"\")\n  return new Uint8Array(\n    (hex.match(/.{1,2}/g) ?? []).map((byte) => parseInt(byte, 16))\n  )\n}\n\nexport function decodeString(hex: string): string {\n  const data = hexToUint8Array(hex)\n  const pointer = Number(bytesToBigInt(data.subarray(0, 32)))\n  const length = Number(bytesToBigInt(data.subarray(pointer, pointer + 32)))\n  const bytes = data.subarray(pointer + 32, pointer + 32 + length)\n  return new TextDecoder().decode(bytes)\n}\n\nexport function decodeAddress(hex: string): string {\n  const data = hexToUint8Array(hex)\n  const bytes = data.subarray(0, 32)\n  const decoded = bytesToBigInt(bytes)\n  if (decoded >= BigInt(2) ** BigInt(160))\n    throw new Error(\n      `Encoded value is bigger than the largest possible address.  Decoded value: 0x${decoded.toString(\n        16\n      )}.`\n    )\n  return `0x${decoded.toString(16)}`\n}\n\nexport function methodUriErc721(tokenId: bigint): string {\n  return URI_METHOD_ERC721 + uint256Hex(tokenId)\n}\n\nexport function methodUriErc1155(id: bigint): string {\n  return URI_METHOD_ERC1155 + uint256Hex(id)\n}\n\nexport function methodOwnerOfErc721(tokenId: bigint): string {\n  return OWNER_OF_METHOD_ERC721 + uint256Hex(tokenId)\n}\n\nexport function ethCall(\n  ethereum: EthereumProviderEip1193,\n  to: Address,\n  data: string\n): Promise<string> {\n  return ethereum.request({\n    method: \"eth_call\",\n    params: [{ data, to }, \"latest\"],\n  }) as Promise<string>\n}\n","import type { Address, FetchContext, NftMetadata } from \"../../types\"\nimport type { EthereumFetcherConfig, EthereumProviderEip1193 } from \"./types\"\n\nimport { fetchMetadata } from \"../shared/fetch-metadata\"\nimport {\n  MultipleErrors,\n  normalizeTokenUrl,\n  promiseAny,\n  urlExtensionType,\n} from \"../../utils\"\nimport {\n  decodeAddress,\n  decodeString,\n  ethCall,\n  methodOwnerOfErc721,\n  methodUriErc1155,\n  methodUriErc721,\n} from \"./utils\"\n\nfunction uriMethods(tokenId: string): string[] {\n  return [methodUriErc721(BigInt(tokenId)), methodUriErc1155(BigInt(tokenId))]\n}\n\nasync function url(\n  contractAddress: Address,\n  tokenId: string,\n  ethereum: EthereumProviderEip1193,\n  fetchContext: FetchContext\n): Promise<string> {\n  const uri = await promiseAny(\n    uriMethods(tokenId).map((method) =>\n      ethCall(ethereum, contractAddress, method)\n    )\n  ).catch((errors) => {\n    throw new MultipleErrors(\n      \"An error occurred while trying to fetch the token URI from the NFT\" +\n        \" contract. See the “errors” property on this error for details.\",\n      errors\n    )\n  })\n  return normalizeTokenUrl(decodeString(uri), tokenId, fetchContext)\n}\n\nexport async function fetchStandardNftContractData(\n  contractAddress: Address,\n  tokenId: string,\n  { ethereum }: EthereumFetcherConfig,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  const [metadataUrl, owner] = await Promise.all([\n    url(contractAddress, tokenId, ethereum, fetchContext),\n    ethCall(ethereum, contractAddress, methodOwnerOfErc721(BigInt(tokenId)))\n      .then(decodeAddress)\n      .catch(() => \"\"),\n  ])\n\n  const metadata = await fetchMetadata(metadataUrl, fetchContext)\n  const imageType = urlExtensionType(metadata.image)\n\n  return {\n    ...metadata,\n    imageType,\n    metadataUrl,\n    owner,\n  }\n}\n","import type {\n  Address,\n  FetchContext,\n  ImageProxyFn,\n  NftMetadata,\n} from \"../../types\"\nimport type {\n  EthereumFetcher,\n  EthereumFetcherConfig,\n  EthereumFetcherConfigDeclaration,\n} from \"./types\"\n\nimport { isAddress } from \"../../utils\"\nimport { cryptoPunksMetadata, isCryptoPunks } from \"../shared/cryptopunks\"\nimport { cryptoKittiesMetadata, isCryptoKitties } from \"../shared/cryptokitties\"\nimport {\n  decentralandEstateMetadata,\n  isDecentralandEstate,\n} from \"../shared/decentraland-estate\"\nimport {\n  decentralandParcelMetadata,\n  isDecentralandParcel,\n} from \"../shared/decentraland-parcel\"\nimport { isMoonCats, moonCatsMetadata } from \"../shared/mooncats\"\nimport { cryptoPunksImage } from \"./cryptopunks\"\nimport { moonCatsCatId } from \"./mooncats\"\nimport { fetchStandardNftContractData } from \"./standard-nft\"\n\nasync function fetchNftMetadata(\n  contractAddress: Address,\n  tokenId: string,\n  config: EthereumFetcherConfig,\n  fetchContext: FetchContext\n): Promise<NftMetadata> {\n  if (isDecentralandParcel(contractAddress)) {\n    return decentralandParcelMetadata(tokenId)\n  }\n\n  if (isDecentralandEstate(contractAddress)) {\n    return decentralandEstateMetadata(tokenId)\n  }\n\n  if (isCryptoKitties(contractAddress)) {\n    return cryptoKittiesMetadata(tokenId, fetchContext)\n  }\n\n  if (isCryptoPunks(contractAddress)) {\n    return cryptoPunksMetadata(tokenId, cryptoPunksImage(config))\n  }\n\n  if (isMoonCats(contractAddress)) {\n    return moonCatsMetadata(tokenId, moonCatsCatId(config), fetchContext)\n  }\n\n  return fetchStandardNftContractData(\n    contractAddress,\n    tokenId,\n    config,\n    fetchContext\n  )\n}\n\nfunction addProxyImage(\n  metadata: NftMetadata,\n  imageProxy: ImageProxyFn\n): NftMetadata {\n  return metadata.image.startsWith(\"http\")\n    ? { ...metadata, image: imageProxy(metadata.image, metadata) }\n    : metadata\n}\n\nfunction normalizeConfig(\n  config: EthereumFetcherConfigDeclaration\n): EthereumFetcherConfig {\n  if (!config.ethereum) {\n    if (window.ethereum) {\n      config.ethereum = window.ethereum\n    } else {\n      throw new Error(\"Missing ethereum provider.\")\n    }\n  }\n  return config as EthereumFetcherConfig\n}\n\nexport default function ethereumFetcher(\n  config: EthereumFetcherConfigDeclaration\n): EthereumFetcher {\n  const _config = normalizeConfig(config)\n  return {\n    config: _config,\n    async fetchNft(\n      contractAddress: Address,\n      tokenId: string,\n      fetchContext: FetchContext\n    ): Promise<NftMetadata> {\n      if (!isAddress(contractAddress)) {\n        throw new Error(`Invalid contract address: ${contractAddress}`)\n      }\n      const metadata = await fetchNftMetadata(\n        contractAddress,\n        tokenId,\n        _config,\n        fetchContext\n      )\n      return addProxyImage(metadata, fetchContext.imageProxy)\n    },\n  }\n}\n","import type { ContractMethod } from \"../../types\"\nimport type { EthereumFetcherConfig } from \"./types\"\n\nimport { decodeString, ethCall, uint256Hex } from \"./utils\"\n\nexport function cryptoPunksImage(config: EthereumFetcherConfig) {\n  return async function cryptoPunksImage(\n    index: string,\n    method: ContractMethod\n  ): Promise<string> {\n    if (config.ethereum === undefined) {\n      throw new Error(\"No Ethereum provider\")\n    }\n    return ethCall(\n      config.ethereum,\n      method.address,\n      method.methodHash + uint256Hex(BigInt(index))\n    ).then(decodeString)\n  }\n}\n","import type { ContractMethod } from \"../../types\"\nimport type { EthereumFetcherConfig } from \"./types\"\n\nimport { ethCall, uint256Hex } from \"./utils\"\n\nexport function moonCatsCatId(config: EthereumFetcherConfig) {\n  return async function moonCatsCatId(\n    tokenId: string,\n    method: ContractMethod\n  ): Promise<string> {\n    if (config.ethereum === undefined) {\n      throw new Error(\"No Ethereum provider\")\n    }\n    const result = await ethCall(\n      config.ethereum,\n      method.address,\n      method.methodHash + uint256Hex(BigInt(tokenId))\n    )\n    return result.slice(0, 12) // 12 = 0x prefix + 5 bytes\n  }\n}\n","import type { FC, ReactNode } from \"react\"\nimport type {\n  Address,\n  FetchContext,\n  Fetcher,\n  FetcherDeclaration,\n  FetcherDeclarationEthereum,\n  FetcherDeclarationEthers,\n  FetcherProp,\n  ImageProxyFn,\n  IpfsUrlFn,\n  JsonProxyFn,\n  NftMetadata,\n  NftResult,\n  NftResultDone,\n  NftResultError,\n  NftResultLoading,\n} from \"./types\"\nimport type { EthersFetcherConfig } from \"./fetchers/ethers/types\"\nimport type { EthereumFetcherConfigDeclaration } from \"./fetchers/ethereum/types\"\n\nimport React, { createContext, useCallback, useContext, useMemo } from \"react\"\nimport useSWR, { SWRConfig, useSWRConfig } from \"swr\"\nimport ethersFetcher from \"./fetchers/ethers\"\nimport ethereumFetcher from \"./fetchers/ethereum\"\nimport { identity, ipfsUrlDefault } from \"./utils\"\n\nconst NFT_METADATA_DEFAULT = {\n  name: \"\",\n  description: \"\",\n  image: \"\",\n} as NftMetadata\n\nfunction isFetcherDeclarationEthers(\n  fetcher: FetcherProp\n): fetcher is FetcherDeclarationEthers {\n  return (\n    Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === \"ethers\"\n  )\n}\n\nfunction isFetcherDeclarationEthereum(\n  fetcher: FetcherProp\n): fetcher is FetcherDeclarationEthereum {\n  return (\n    Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === \"ethereum\"\n  )\n}\n\nfunction normalizeFetcher(fetcher: FetcherProp): Fetcher<unknown> {\n  // ethers\n  if (isFetcherDeclarationEthers(fetcher)) {\n    return ethersFetcher(fetcher[1]) as Fetcher<EthersFetcherConfig>\n  }\n\n  // ethereum\n  if (isFetcherDeclarationEthereum(fetcher)) {\n    return ethereumFetcher(\n      fetcher[1]\n    ) as Fetcher<EthereumFetcherConfigDeclaration>\n  }\n\n  // custom fetcher (or wrong value)\n  return fetcher\n}\n\nconst NftContext = createContext<{\n  fetcher: Fetcher<unknown> | null\n  imageProxy: ImageProxyFn\n  ipfsUrl: IpfsUrlFn\n  jsonProxy: JsonProxyFn\n} | null>(null)\n\nconst NftProvider: FC<{\n  children: ReactNode\n  fetcher: Fetcher<unknown> | FetcherDeclaration\n  imageProxy?: ImageProxyFn\n  ipfsUrl?: IpfsUrlFn\n  jsonProxy?: JsonProxyFn\n}> = function NftProvider({\n  children,\n  fetcher,\n  imageProxy = identity,\n  ipfsUrl = ipfsUrlDefault,\n  jsonProxy = identity,\n}) {\n  if (!fetcher) {\n    throw new Error(\"Please set the fetcher prop on <NftProvider />\")\n  }\n\n  const context = {\n    fetcher: normalizeFetcher(fetcher),\n    imageProxy,\n    ipfsUrl,\n    jsonProxy,\n  }\n\n  return (\n    <SWRConfig value={{ provider: () => new Map() }}>\n      <NftContext.Provider value={context}>{children}</NftContext.Provider>\n    </SWRConfig>\n  )\n}\n\nfunction useNft(contractAddress: Address, tokenId: string): NftResult {\n  const context = useContext(NftContext)\n  if (context === null) {\n    throw new Error(\"Please wrap your app with <NftProvider />\")\n  }\n\n  const { fetcher, imageProxy, ipfsUrl, jsonProxy } = context\n  const fetchContext = useMemo<FetchContext>(\n    () => ({ imageProxy, ipfsUrl, jsonProxy }),\n    [imageProxy, ipfsUrl, jsonProxy]\n  )\n\n  const fetchNft = useCallback(() => {\n    return fetcher\n      ? fetcher.fetchNft(contractAddress, tokenId, fetchContext)\n      : { ...NFT_METADATA_DEFAULT }\n  }, [contractAddress, fetcher, fetchContext, tokenId])\n\n  const { cache } = useSWRConfig()\n  const cached = (cache.get(contractAddress + tokenId) ?? false) as boolean\n\n  const result = useSWR<NftMetadata, Error>(\n    contractAddress + tokenId,\n    fetchNft,\n    {\n      revalidateOnMount: !cached,\n      revalidateOnFocus: false,\n      revalidateOnReconnect: false,\n    }\n  )\n\n  return useMemo(() => {\n    const { error, data, mutate } = result\n\n    const reload = () =>\n      mutate()\n        .then(() => true)\n        .catch(() => false)\n\n    if (error === undefined && data === undefined) {\n      return {\n        error: undefined,\n        loading: true,\n        nft: undefined,\n        reload,\n        status: \"loading\",\n      } as NftResultLoading\n    }\n\n    if (error !== undefined) {\n      return {\n        error,\n        loading: false,\n        nft: undefined,\n        reload,\n        status: \"error\",\n      } as NftResultError\n    }\n\n    return {\n      error: undefined,\n      loading: false,\n      nft: data as NftMetadata,\n      reload,\n      status: \"done\",\n    } as NftResultDone\n  }, [result])\n}\n\nexport { useNft, NftProvider }\n","import type {\n  Address,\n  FetchContext,\n  Fetcher,\n  FetcherDeclaration,\n  FetcherDeclarationEthereum,\n  FetcherDeclarationEthers,\n  FetcherProp,\n  ImageProxyFn,\n  IpfsUrlFn,\n  JsonProxyFn,\n  NftMetadata,\n} from \"./types\"\nimport type { EthersFetcherConfig } from \"./fetchers/ethers/types\"\nimport type { EthereumFetcherConfig } from \"./fetchers/ethereum/types\"\n\nimport { identity, ipfsUrlDefault } from \"./utils\"\nimport ethersFetcher from \"./fetchers/ethers\"\nimport ethereumFetcher from \"./fetchers/ethereum\"\n\ntype FetchWrapperOptions = {\n  imageProxy?: ImageProxyFn\n  ipfsUrl?: IpfsUrlFn\n  jsonProxy?: JsonProxyFn\n}\n\nconst NFT_METADATA_DEFAULT = {\n  name: \"\",\n  description: \"\",\n  image: \"\",\n} as NftMetadata\n\nexport class FetchWrapper {\n  private fetcher: Fetcher<unknown>\n  private fetchContext: FetchContext\n\n  constructor(\n    fetcher: Fetcher<unknown> | FetcherDeclaration,\n    options: FetchWrapperOptions = {}\n  ) {\n    this.fetcher = this.normalizeFetcher(fetcher)\n    this.fetchContext = this.fetchContextFromOptions(options)\n  }\n\n  private fetchContextFromOptions({\n    imageProxy,\n    ipfsUrl,\n    jsonProxy,\n  }: FetchWrapperOptions): FetchContext {\n    return {\n      imageProxy: imageProxy ?? identity,\n      ipfsUrl: ipfsUrl ?? ipfsUrlDefault,\n      jsonProxy: jsonProxy ?? identity,\n    }\n  }\n\n  private normalizeFetcher(fetcher: FetcherProp): Fetcher<unknown> {\n    // default fetcher\n    if (!fetcher) {\n      return {\n        config: {},\n        fetchNft: () => Promise.resolve(NFT_METADATA_DEFAULT),\n      } as Fetcher<Record<string, never>>\n    }\n\n    // ethers\n    if (this.isFetcherDeclarationEthers(fetcher)) {\n      return ethersFetcher(fetcher[1]) as Fetcher<EthersFetcherConfig>\n    }\n\n    // ethereum\n    if (this.isFetcherDeclarationEthereum(fetcher)) {\n      return ethereumFetcher(fetcher[1]) as Fetcher<EthereumFetcherConfig>\n    }\n\n    // custom fetcher (or wrong value)\n    return fetcher\n  }\n\n  private isFetcherDeclarationEthers(\n    fetcher: FetcherProp\n  ): fetcher is FetcherDeclarationEthers {\n    return (\n      Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === \"ethers\"\n    )\n  }\n\n  private isFetcherDeclarationEthereum(\n    fetcher: FetcherProp\n  ): fetcher is FetcherDeclarationEthereum {\n    return (\n      Array.isArray(fetcher) && fetcher.length == 2 && fetcher[0] === \"ethereum\"\n    )\n  }\n\n  public async fetchNft(\n    contractAddress: Address,\n    tokenId: string\n  ): Promise<NftMetadata> {\n    return await this.fetcher.fetchNft(\n      contractAddress,\n      tokenId,\n      this.fetchContext\n    )\n  }\n}\n"],"names":["RARIBLE_MATCH_RE","isAddress","value","test","identity","arg","ipfsUrlDefault","cid","path","IPFS_PROTOCOL_RE","IPFS_HASH_RE","ipfsUrlFromString","ipfsString","ipfsUrl","ipfsProtocolMatch","exec","normalizeTokenUrl","url","tokenId","fetchContext","_url","URL","host","pathname","includes","replace","searchParams","set","String","err","normalizeOpenSeaUrl","normalizeNiftyGatewayUrl","startsWith","jsonProxy","normalizeImageUrl","addressesEqual","addr1","addr2","toLowerCase","promiseAny","promises","reversePromise","Promise","all","map","promise","resolve","reject","then","MultipleErrors","message","errors","_this","name","Error","IMAGE_EXT_RE","VIDEO_EXT_RE","urlExtensionType","DECENTRALAND_ESTATE","DECENTRALAND_PARCEL","cryptoPunksMetadata","index","cryptoPunksImage","CRYPTOPUNKS_IMAGE_SVG","image","description","CRYPTOPUNKS_DESCRIPTION","dataUri","dataStart","indexOf","slice","encodeURIComponent","imageType","metadataUrl","owner","rawData","address","methodName","methodHash","humanReadableAbi","isCryptoPunks","contractAddress","cryptoKittiesMetadata","id","fetch","res","json","data","image_url","bio","isCryptoKitties","decentralandEstateMetadata","ENDPOINT","body","method","response","nft","nfts","_data$nfts","estate","_nft$estate","_nft$estate$data","_nft$owner","JSON","stringify","operationName","variables","query","isDecentralandEstate","decentralandParcelMetadata","parcel","_parcel$data","x","y","isDecentralandParcel","moonCatsMetadata","getCatId","MOONCATS_WRAPPED","catId","imageUrl","dir","MOONCATS_IPFS_CID","src","Image","crossOrigin","onload","onerror","error","scale","padding","width","naturalWidth","height","naturalHeight","_padding","Math","max","canvas","document","createElement","ctx","getContext","imageSmoothingEnabled","drawImage","toDataURL","frameImage","isMoonCats","fetchMetadata","title","type","properties","_data$properties","_data$properties$name","_data$properties2","_data$properties2$ima","_data$properties3","_data$properties3$des","isNftMetadataMixedInJsonSchema","fixNftMetadataMixedInJsonSchema","isNftMetadata","fixIncorrectImageField","normalizeNftMetadata","ok","contract","tokenURI","uri","ABI","ethersFetcher","config","fetchNft","ethers","_config$ethers","Contract","import","loadEthers","configWithEthersLoaded","provider","punkImageSvg","wrappedContract","_tokenIDToCatID","result","moonCatsCatId","ownerOf","metadata","fetchStandardNftContractData","fetchNftMetadata","imageProxy","addProxyImage","uint256Hex","i","BigInt","toString","bytesToBigInt","bytes","byte","hexToUint8Array","hex","Uint8Array","match","parseInt","decodeString","pointer","Number","subarray","length","TextDecoder","decode","decodeAddress","decoded","methodUriErc721","methodOwnerOfErc721","ethCall","ethereum","to","request","params","uriMethods","ethereumFetcher","_config","window","normalizeConfig","undefined","NFT_METADATA_DEFAULT","normalizeFetcher","fetcher","Array","isArray","isFetcherDeclarationEthers","isFetcherDeclarationEthereum","NftContext","createContext","options","this","fetchContextFromOptions","children","context","React","SWRConfig","Map","Provider","raribleMatch","useContext","useMemo","useCallback","cached","useSWRConfig","cache","get","useSWR","revalidateOnMount","revalidateOnFocus","revalidateOnReconnect","mutate","reload","loading","status"],"mappings":"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"}